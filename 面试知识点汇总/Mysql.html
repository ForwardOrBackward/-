<html>
<head>
  <title>Mysql</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="8997"/>
<h1>Mysql</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/7/25 22:25</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/9/21 14:52</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>三个范式</div><div>     1NF:强调列的原子性(域原子性),保证每一列都是单一属性且不可再分的</div><div>     2NF: 在满足1NF的基础上再满足依赖性: <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: no-common-ligatures;">非主键类必须完全依赖于主键，而不能只依赖主键的一部分</span>(主要针对联合主键而言?)</div><div>     3NF: 在满足2NF的基础上再满足: <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: no-common-ligatures;">非主键列必须直接依赖于主键，不能存在传递依赖。</span> (<span style="font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(75, 75, 75); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">确保每列都和主键列直接相关,而不是间接相关)</span></div><div>什么是事务</div><div>    事务是逻辑上的一组操作, 要么都执行, 要么都不执行。(最经典的就是转账问题)</div><div>并发事务可能存在的问题:</div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">脏读</span>（Dirty read） : <span style="color: rgb(255, 0, 0);">当⼀个事务正在访问数据并且对数据进⾏了修改，⽽这种修改还没有提交</span></div><div style="margin-left: 40px;"><span style="color: rgb(255, 0, 0);">到数据库中，这时另外⼀个事务也访问了这个数据</span>，然后使⽤了这个数据。因为这个数据是还没</div><div style="margin-left: 40px;">有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是</div><div style="margin-left: 40px;">不正确的。</div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">不可重复读</span>（Unrepeatableread） : <span style="color: rgb(255, 0, 0);">指⼀个事务多次读同⼀数据。在这个事务多次读之间</span></div><div style="margin-left: 40px;"><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">，另⼀个事务修改了该数据</span></span><span style="font-size: unset; color: unset; font-family: unset;">。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修</span></div><div style="margin-left: 40px;">改导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不</div><div style="margin-left: 40px;">⼀样的情况，因此称为不可重复读。</div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">幻读</span>（Phantom read） : 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据，接</div><div style="margin-left: 40px;">着另⼀个并发事务（T2）插⼊或删除了⼀些数据时。在随后的查询中，T1就会发现多了或少了</div><div style="margin-left: 40px;">⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。</div><div>事务的隔离级别</div><div style="margin-left: 40px;">READ-UNCOMMITTED(<span style="color: rgb(166, 0, 196);">读未提交</span>)： 最低的隔离级别，允许读取尚未提交的数据变更， 可能会导</div><div style="margin-left: 40px;">致脏读、幻读或不可重复读。</div><div style="margin-left: 40px;">READ-COMMITTED(<span style="color: rgb(166, 0, 196);">读已提交</span>)： 允许读取并发事务已经提交的数据， 可以阻⽌脏读，但是幻读</div><div style="margin-left: 40px;">或不可重复读仍有可能发⽣。</div><div style="margin-left: 40px;">REPEATABLE-READ(<span style="color: rgb(166, 0, 196);">可重复读</span>)： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务</div><div style="margin-left: 40px;">⾃⼰所修改， 可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</div><div style="margin-left: 40px;">SERIALIZABLE(<span style="color: rgb(166, 0, 196);">可串⾏化</span>)： 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个</div><div style="margin-left: 40px;">执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说， 该级别可以防⽌脏读、不可重复读以及</div><div style="margin-left: 40px;">幻读。</div><div><br/></div><div><br/></div><div><br/></div><div>1、常见sql题:</div><div>排名问题: </div><div>排名是数据库中的一个经典题目，实际上又根据排名的具体细节可分为3种场景：</div><div><span>    </span>连续排名，例如薪水3000、2000、2000、1000排名结果为1-2-3-4，体现同薪不同名，排名类似于编号</div><div><span>    </span>同薪同名但总排名不连续，例如同样的薪水分布，排名结果为1-2-2-4</div><div><span>    </span>同薪同名且总排名连续，同样的薪水排名结果为1-2-2-3</div><div><b>常问的问题是找第N大的值:</b></div><div>(1)思路一: 直接用order by + limit , 然后看是上面哪种排名方式, 考虑再加上limit或group by配合使用。</div><div>(2)思路二: 关联子查询。用count([distinct] 某列) 作为子查询的结果,然后父查询用&quot;where 子查询 = N-1&quot;, 即可达到目的。</div><div>(3)思路三: 自连接。连接条件是e1.某列 &lt;= e2.某列。然后再group by 某列 having count([distinct] 某列) = N</div><div>(4)思路四: 窗口函数</div><div style="margin-left: 40px;">实际上，在mysql8.0中有相关的内置函数，而且考虑了各种排名问题：</div><div style="margin-left: 80px;">row_number(): 同薪不同名，相当于行号，例如3000、2000、2000、1000排名后为1、2、3、4</div><div style="margin-left: 80px;">rank(): 同薪同名，有跳级，例如3000、2000、2000、1000排名后为1、2、2、4</div><div style="margin-left: 80px;">dense_rank(): 同薪同名，无跳级，例如3000、2000、2000、1000排名后为1、2、2、3</div><div style="margin-left: 80px;">ntile(): 分桶排名，即首先按桶的个数分出第一二三桶，然后各桶内从1排名，实际不是很常用</div><div style="margin-left: 40px;">另外这三个函数必须要要与其搭档over()配套使用，over()中的参数常见的有两个，分别是</div><div style="margin-left: 80px;">partition by，按某字段切分</div><div style="margin-left: 80px;">order by，与常规order by用法一致，也区分ASC(默认)和DESC，因为排名总得有个依据</div><div>详情见: <a href="https://leetcode-cn.com/problems/nth-highest-salary/solution/mysql-zi-ding-yi-bian-liang-by-luanz/">https://leetcode-cn.com/problems/nth-highest-salary/solution/mysql-zi-ding-yi-bian-liang-by-luanz/</a></div><div><br/></div><div>开窗函数:</div><div>case when: </div></span>
</div></body></html> 