<html>
<head>
  <title>day11-shuffle阶段的三大核心组件</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="2070"/>
<h1>day11-shuffle阶段的三大核心组件</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/8/17 20:27</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2020/8/27 9:49</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-weight: bold;">1、combiner的使用</span></div><div><br/></div><div>（1）combiner组件的作用</div><div><br/></div><div>     <span style="color: rgb(166, 0, 196);">* Combiner 是 MapReduce 程序中 Mapper 和 Reducer 之外的一种组件，它的作用是在maptask</span></div><div><span style="color: rgb(166, 0, 196);">     * 之后给</span><span style="color: rgb(255, 0, 0);"> 每一个</span><span style="color: rgb(166, 0, 196);">maptask 的结果</span><span style="color: rgb(255, 0, 0);">分别</span><span style="color: rgb(166, 0, 196);">进行局部汇总</span><span style="color: rgb(255, 0, 0);">(也就是说combiner只是把每一个maptask中的结果进行了单独汇总,      </span></div><div><span style="color: rgb(166, 0, 196);">     *</span><span style="color: rgb(255, 0, 0);">一个</span><span style="color: rgb(255, 0, 0);">maptask一份汇</span><span style="color: rgb(255, 0, 0);">总之后再在reduce阶段对所有maptask的数据再统一汇总一次)</span><span style="color: rgb(166, 0, 196);">，以减轻 reducetask 的计算负载，</span></div><div><span style="color: rgb(166, 0, 196);">     * </span><span style="color: rgb(166, 0, 196);">减少网络传输,</span> <span style="color: rgb(166, 0, 196);">以免在shuffle阶段出现大量的数据在网络传输</span></div><div>     *</div><div>     * <span style="color: rgb(166, 0, 196);">combine发送在map阶段之后,shuffle阶段之前,当然也就在reduce阶段之前</span></div><div>     * 因为map阶段之后就是shuffle,对数据进行混洗,进行网络传输。如果有combine阶段,</div><div>     <span style="color: rgb(166, 0, 196);">* 先对数据进行局部汇总,会大大减少shuffle混洗的数据的量,减小网络压力，</span></div><div><span style="color: rgb(166, 0, 196);">     * 之后再在reduce阶段对数据进行最终的汇总</span></div><div><br/></div><div><span style="color: rgb(166, 0, 196);"><img src="day11-shuffle阶段的三大核心组件_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><img src="day11-shuffle阶段的三大核心组件_files/WordCount逻辑图.png" type="image/png" data-filename="WordCount逻辑图.png"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">     *  combiner的输入key-value类型就是 mapper的输出key value类型</span></div><div><span style="color: rgb(166, 0, 196);">     *  combiner的输出key-value类型就是 reducer的输入key value类型</span></div><div>    </div><div>     * 如果combiner逻辑和reduce逻辑完全一样,可以直接不写,</div><div>     * 调用combiner时直接将reduce当做combiner来使用</div><div><br/></div><div><br/></div><div>（2）combiner组件的使用</div><div><br/></div><div>    具体使用见</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>         <span style="color: rgb(166, 0, 196);">* 在默认的模型实现中是没有自带的Combiner组件的</span></div><div><span style="color: rgb(166, 0, 196);">         * 如果没有指定，表示不使用Combiner</span></div><div>         *</div><div>         * 因为在这个计算实现中,reducer类和combiner类的逻辑完全一样,</div><div>         * 直接使用reducer类来代替combiner类启动combiner组件也是可以的</div><div>         *</div><div>         * 一般来说， max， min， sum, count (avg是不能使用的)等逻辑可以使用 Reducer直接充当 Combiner</div><div>         * 如果  Reducer逻辑的  输入和输出的key-value的类型一致的话， 也基本可用</div><div>         *</div><div>         *</div><div>         *  如果reducer的输入为：  key：Text，    value : LongWritable</div><div>         *             输出为：  key： Text,  value ： IntWritable</div><div>         *             那显然不能直接使用reducer来代替combiner,</div><div>         *             因为用reducer的逻辑执行完combiner后,</div><div>         *             再执行reducer组件,combiner的输出已经不能作为reducer的输入</div><div><br/></div><div>（3）combiner的作用如图所示：（<span style="color: rgb(166, 0, 196);">此图只解释逻辑，没有表示执行顺序，所以不要误以为combiner在map阶段之前</span>）</div><div><img src="day11-shuffle阶段的三大核心组件_files/Combiner.png" type="image/png" data-filename="Combiner.png"/></div><div>（4）combiner用法总结</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">2、序列化机制-二次排序（Sorter组件）</span></div><div><br/></div><div>(1)详情见eclipse案例如下图：（主要着手方向是 如何自定义key类型(即图里的Flow类)进行排序，因为排序只能对key进行排序，而无法对value进行排序）</div><div><br/></div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>(2)Flow类如何实现:</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div> <img src="day11-shuffle阶段的三大核心组件_files/Image [5].png" type="image/png" data-filename="Image.png" width="612"/></div><div><br/></div><div>(3)Mapper阶段的业务逻辑设计思路:</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>(4)Sort的使用:</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>      <img src="day11-shuffle阶段的三大核心组件_files/Image [8].png" type="image/png" data-filename="Image.png" width="925"/></div><div><br/></div><div><span style="font-weight: bold;">3、自定义Partitioner</span></div><div><br/></div><div>(1)Partitioner组件的默认实现:</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div>                <img src="day11-shuffle阶段的三大核心组件_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>(2)自定义Partitioner的目的主要是按自己的想法对数据进行分区,一个分区启动一个ReduceTask,一个ReduceTask输出一个结果文件</div><div>详情见eclipse案例如下图:</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>(3)Partitioner的相关原理:</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>(4)ReduceTask如何设置:</div><div><img src="day11-shuffle阶段的三大核心组件_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">4、</span><span style="font-weight: bold;">shuffle阶段的三大组件的执行逻辑</span></div><div><img src="day11-shuffle阶段的三大核心组件_files/mapreduce中的三大组件的执行逻辑.png" type="image/png" data-filename="mapreduce中的三大组件的执行逻辑.png"/></div><div><span style="color: rgb(166, 0, 196);">然后对所有maptask依次执行上图所示操作。</span></div><div><br/></div><div><br/></div><div><br/></div><div style="text-align: center;"><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">————————————————————</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手写与上传资料分割线</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><a href="day11-shuffle阶段的三大核心组件_files/hadoop-mr-part2-MR三大组件和序列化.pdf"><img src="day11-shuffle阶段的三大核心组件_files/7f5eec6f9c2efe4d4ad61c02603b3fff.png" alt="hadoop-mr-part2-MR三大组件和序列化.pdf"></a></div><div><br/></div><div><br/></div><div>1、mapreduce简单案例</div><div><br/></div><div>     max</div><div>     min</div><div>     avg</div><div>     sum</div><div>     count</div><div>     count distinct</div><div><br/></div><div><br/></div><div>2、两大块内容</div><div><br/></div><div>     序列化框架（用用户自定义的POJO对象作为key）</div><div><br/></div><div>     MapReduce当中的三大核心组件</div><div><br/></div><div>          Sorter</div><div>          Combiner</div><div>          Partitioner</div><div><br/></div><div><br/></div><div>     围绕三个需求：</div><div><br/></div><div>     1、普通的汇总</div><div><br/></div><div>          结合 Combiner</div><div><br/></div><div>     2、二次排序</div><div><br/></div><div>          1、要把排序的总流量字段提升到 key 当中</div><div>          2、为了不改变原来的数据的输出样式，那么直接把所有四个字段都看做是一个POJO类的四个属性</div><div>          3、该pojo对象就可以直接当做key</div><div>          4、必须对key进行序列化，而且还要指定排序规则</div><div>          5、mapreduce的key和value都可以有一个为空</div><div><br/></div><div><br/></div><div>          异常解释：</div><div><br/></div><div>          1、Initialization of all the collectors failed</div><div><br/></div><div>          如果用户自定义的pojo类充当key,  必须要进行序列化</div><div><br/></div><div>          在每个MapTask的节点上都会有一个输出组件在收集数据。 其实就是一个MapOutBuffer（内存缓冲区： 100M）</div><div>          mapper中的 context.write(key,value)的key-value会收集到收集器中。 </div><div><br/></div><div>          方便后来的shuffle过程中进行分区、排序和聚合</div><div><br/></div><div>          因为context.write(key, value)其实是有可能，而且最终是一定要把key-value序列化到 磁盘文件</div><div>          那么收集器在每个MapTask运行之前都会进行初始化。 这个收集器在进行初始化的时候。同时也会进行 序列</div><div><span>    </span><span>    </span><span>    </span><span>    </span>化器 和 反序列化器的 初始化</div><div><br/></div><div><br/></div><div>     3、自定义Partitioner</div><div><br/></div><div>     使用Combiner组件做局部聚合</div><div>     使用自定义的POJO对象作为key</div><div><br/></div><div>使用Combine前后的reduce处理的记录数对比：</div><div><br/></div><div>Combine input records=0</div><div>Combine output records=0</div><div>Reduce input groups=21</div><div>Reduce shuffle bytes=7359666</div><div>Reduce input records=304920</div><div><br/></div><div><br/></div><div>Combine input records=304920</div><div>Combine output records=21</div><div>Reduce input groups=21</div><div>Reduce shuffle bytes=673</div><div>Reduce input records=21</div><div><br/></div><div><br/></div></span>
</div></body></html> 