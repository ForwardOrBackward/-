<html>
<head>
  <title>day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="2216"/>
<h1>day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/10/12 18:25</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/5/17 19:05</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-weight: bold;">1 、</span><span style="font-weight: bold;">多job串联运行</span></div><div>详情参考求eclipse里的&quot;求共同好友&quot;的案例</div><div><br/></div><div>题目:</div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image.png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [1].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [2].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [3].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><span style="font-weight: bold;">但最终实现串联主要是看其中的下图这个类</span></div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [4].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [5].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">2、自定义分组规则求TopN</span></div><div>详情参考求eclipse里的&quot;求每门课程的平均成绩的第一名&quot;的案例</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(166, 0, 196);">自定义的分组规则主要在</span><span style="min-height: 16pt; font-size: 16pt; background: rgb(212, 212, 212); color: rgb(166, 0, 196); font-family: &quot;Courier New&quot;;">CSGroupComparator</span><span style="color: rgb(166, 0, 196);">类里,排序规则主要在自定义key类型</span><span style="min-height: 16pt; font-size: 16pt; background: rgb(212, 212, 212); color: rgb(166, 0, 196); font-family: &quot;Courier New&quot;;">Student</span><span style="color: rgb(166, 0, 196);">类里</span></div><div><br/></div><div><br/></div><div>题目:</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div> <img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>主要矛盾如下:(这次代码的主要特点就是解决了以下问题)</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>在自定义分组规则时,在对数据进行分组之前,要想到要先对数据进行反序列化。</div><div><br/></div><div>也就是写分组规则的代码之前要先调用父类WritableComparator()的构造方法来实现反序列化(应该是默认的分组规则类已经反序列化过了,所以自定义分组规则类才需要调用构造方法进行反序列化)</div><div>具体分组前反序列化代码写法参见eclipse下图所示项目</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>MapReduce共有两次序列化,一次是快速排序阶段结束时(有combiner的话是在combiner结束。不太确定有combine的话会不会也是在快速排序结束后序列化到磁盘，再在combine之前反序列化回内存),将数据项写到磁盘,然后进行网络传输,另一次是reducer阶段结束时,将数据写成结果文件(这个结论其实不太重要)</div><div>    也可能有两次反序列化，一次是在combine开始前（因为combine毕竟是继承的reduce类），一次是在reduce阶段开始前，入读测阶段开始前当然要把在磁盘中的数据反序列化回内存。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">3、</span><span style="font-weight: bold;">MapReduce 全局计数器</span></div><div>自定义全局计数器的实例详情参考eclipse里的的案例:</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/skitch.png" type="image/png" data-filename="skitch.png"/></div><div><br/></div><div>代码主要有两个目的:</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>实际实现自定义全局计数器的代码</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [16].png" type="image/png" data-filename="Image.png"/><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [17].png" type="image/png" data-filename="Image.png" width="1079"/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [18].png" type="image/png" data-filename="Image.png"/><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">最终程序的结果并不是体现在输出的结果文件上,因为并不输出任何文件,而是体现在控制台打印的信息上:</span></div><div><br/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">4、join的实现思路</span></div><div><br/></div><div>(1)join即两份或多份数据连接,类似于数据库表的内连接</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>(2)join的实现思路（这里是reduceJoin）:</div><div>    </div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/join实现思路.png" type="image/png" data-filename="join实现思路.png" width="748"/></span></div><div><br/></div><div>(3)ReduceJoin和MapJoin的优缺点:</div><div>使用ReduceJoin时,如果某个ReduceTask的数据非常多(某个ReduceTask中的数据量占比数据总量非常大,其他的ReduceTask处理的数据非常少,称为数据热点现象),可能会造成内存溢出,当前的任务会出现数据倾斜,也就说任务的规模极度不均衡。并且,如果唯有一个ReduceTask要处理的数据很大的话, 其他ReduceTask运行结束后要单独等待这个ReduceTask完成, 整个MapReduce程序才算运行结束,所以可能运行时间会大大超出预期</div><div><br/></div><div>如果使用MapJoin,那么不会有上述问题（因为MapJoin没有reduce阶段）,但是每个maptask要读取两个文件的数据进行连接, 会使得编码的复杂度增加。</div><div><br/></div><div>所以,如果每个id所对应的数据分布比较均衡,那么肯定是用ReduceJoin方便一些(虽然方便,但还是MapJoin要效率高一些,毕竟没有reduce阶段),如果是极度不均衡,那么最好使用MapJoin。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">(4)ReduceJoin的具体实现</span></div><div>详情参考求eclipse里的&quot;求user表和movie表的内连接&quot;的案例</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [23].png" type="image/png" data-filename="Image.png" width="748"/></div><div><br/></div><div><br/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-weight: bold;">(5)MapJoin的具体实现(</span><span style="font-weight: bold;">DistributedCache的应用</span><span style="font-weight: bold;">)</span></div><div>详情参考求eclipse里的&quot;求user表和rating表的内连接&quot;的案例</div><div><span style="font-weight: bold;"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [26].png" type="image/png" data-filename="Image.png"/></span></div><div>1)MapJoin的编程思路：</div><div><br/></div><div>a、编写一个MapReduce程序， 只读取 大表数据(<span style="color: rgb(166, 0, 196);">大表就是指数据量非常大的文件,或者说数据量远大于小表的文件</span>)</div><div>b、在该mapReduce程序中的mapper阶段，要把小表的所有数据先加载到内存</div><div>c、在setup方法中初始化一个hashmap</div><div>    通过流的方式去进行读取小表数据，然后解析出来对应的key-value存储进入该hashmap中</div><div>d、在mapper组件中的map方法中， map方法每调用一次，就是每从大表中读取到的一条记录, <span style="font-size: unset; color: unset; font-family: unset;">解析出来之后，去hashmap中进行匹配连接， 如果匹配，则输出。</span></div><div>e、如果可以不用管其他的操作， 仅仅只是做链接， 那么就可以直接只使用mapper阶段就ok，</div><div>不需要reduce阶段</div><div><br/></div><div><br/></div><div>2)实现的思想:(主要是第二个图)</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/reduceJoin改编成mapJoin的存在问题.png" type="image/png" data-filename="reduceJoin改编成mapJoin的存在问题.png"/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/mapjoin的实现思路以及存在的问题解析.png" type="image/png" data-filename="mapjoin的实现思路以及存在的问题解析.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>3)题目:</div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [27].png" type="image/png" data-filename="Image.png" width="748"/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/skitch [1].png" type="image/png" data-filename="skitch.png"/></div><div><span style="font-weight: bold;">(6)心得</span></div><div><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/Image [30].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手写与上传资料分割线</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—————————————————————</span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><a href="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/hadoop-mr-part3-典型编程场景1-.pdf"><img src="day12-多job串联、自定义分组规则、全局计数器、mapJoin、reduceJoin_files/57d17dba50bd0dd002bb3d5606b18dcf.png" alt="hadoop-mr-part3-典型编程场景1-.pdf"></a></div><div><br/></div><div><br/></div><div><br/></div><div>mapreduce编程模型中的三大核心组件：</div><div><br/></div><div>要点：</div><div><br/></div><div>1、partitioner</div><div><br/></div><div>     1、mapreduce编程模型中的默认实现是HashPartitioner</div><div><br/></div><div>     2、HashPartitioner的原理是按照key的hash值取模除以redcueTask个数的余数</div><div>     这个余数就决定了传入该getPartition方法参数key-value到底要被分配到哪个编号的reduceTask</div><div><br/></div><div>     3、在mapreduce编程模型中的对应关系：</div><div><br/></div><div>          分区个数 == reduceTask个数 == 结果文件个数</div><div><br/></div><div>     4、如果需要自带的默认实现HashPartitioner不能满足我们的要求，需要做自定义实现：</div><div>         </div><div>          按照 HashPartitioner的实现方式，编写一个自定义的Parititoner类去继承 Parititoner抽象类</div><div><br/></div><div>          实现其中的getPartition方法</div><div>    </div><div>     5、设置reduceTask的要点:</div><div><br/></div><div>          1、在driver中的main方法中，一定要给对应的job设置要是使用自定义的Parititoner</div><div>          job.setPartitionerClass();</div><div><br/></div><div>          2、关于设置reduceTask的个数</div><div><br/></div><div>               1、设置为1，表示设置的Partiioner不起作用</div><div>               2、设置成对应需求的reDduceTask，正常</div><div>               3、大于1，并且小于redcueTask的个数，程序会抛错</div><div>               4、设置大于reduceTask的个数，会启动很多的无效JVM进程，reduceTask</div><div><br/></div><div><br/></div><div>2、sort</div><div><br/></div><div>     1、如果mapreduce编程中有reducer阶段，那么排序就一定会进行</div><div><br/></div><div>     而且排序只会对key排序</div><div>     所以， 作为key的那个类必须要指定排序规则</div><div><br/></div><div>     2、如果作为key的类是自定义的类， 那么必须指定排序规则，而且还要进行序列化实现，</div><div>     所以要实现WritableComparable接口</div><div><br/></div><div>     3、如果一个mapreduce程序中没有recducer阶段， 那么就没有shuffle， 就没有排序阶段</div><div><br/></div><div>     4、在代码中没有设置reduceTask的个数 不代表没有redcueTask任务，</div><div>     默认运行一个默认实现的RedcuerTask</div><div><br/></div><div>     5、当一个作为key的自定义类要实现WritableComparable借口，要实现三个方法：</div><div><br/></div><div>          1、序列化方法： write(DataOutput out)</div><div>          2、反序列化方法： readFields(DataInput in)</div><div>          3、排序规则：compareTo(Flow o)</div><div><br/></div><div>     6、当用户自定义类 要作为value的时候， 仅仅只需要实现Writable接口</div><div>        当用户自定义类 要作为 key 的时候， 仅仅只需要实现WritableComprable接口</div><div><br/></div><div><br/></div><div>3、combiner</div><div><br/></div><div>     1、combiner的实现方法： 和redcuer的编写一样： 继承REdcuer抽象类， 重写redcue方法</div><div><br/></div><div>     2、combiner的作用：仅仅只是运行在每一个mapTask节点，为了在mapTask运行的节点中做一个局部聚合</div><div>     以减少shuffle阶段参数shuffle的数据量。 其实就是为了介绍网络数据传输</div><div><br/></div><div>     3、combiner的使用： 如果在不影响业务逻辑的情况下，咱们可以直接使用Redcuer组件充当Combiner</div><div>         </div><div>          那些场景适用：</div><div><br/></div><div>               max, count, min, sum 这些操作基本都使用。并不是决定</div><div>         </div><div>          那些场景不适用：</div><div><br/></div><div>               avg   也不是绝对的。 需要改写原来的Reducer逻辑以使用Conbiner</div><div>         </div><div>          经验推荐：</div><div><br/></div><div>               如果当combiner的输入 和 输出的key-value的类型一致的话， 才基本适用说让 Redcuer充当 Combiner</div><div><br/></div><div><br/></div><div>servlet:</div><div><br/></div><div>     init（）</div><div>     service（）</div><div>     destroy（）</div><div><br/></div><div>mapper</div><div><br/></div><div>     setup（）</div><div>     map（）</div><div>     cleanup（）</div><div><br/></div><div><br/></div><div>真正的业务逻辑一定是编写在Mapper和Reducer中</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>普通的编程场景：</div><div>min</div><div>max</div><div>sum</div><div>count</div><div>count distinct</div><div><br/></div><div><br/></div><div>高级的编程场景：</div><div>topn</div><div>join</div><div><br/></div><div><br/></div><div><br/></div><div>hadoop fs -mkdir -p /cf/input</div><div>hadoop jar cf.jar com.CFMR /input /output</div><div><br/></div><div><br/></div><div>结合两个技能：</div><div><br/></div><div>1、采用MapReduce编程模型中的源码实现方式中的一种</div><div><br/></div><div>     extends Configured implements Tool</div><div><br/></div><div>     编写一个main作为 程序的入口</div><div><br/></div><div>     实现tool接口中的run方法</div><div><br/></div><div>     使用这种技能去编写MapReduce的时候，就应该把原来的 main 方法中的代码编写在run方法中</div><div>    </div><div>     然后再main方法中通过一个工具类调用当前MR程序的一个实例对象的run</div><div>     方法去执行</div><div><br/></div><div><br/></div><div>2、采用全局计数器来实现  单词计数</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>join</div><div><br/></div><div>SQL语句：  </div><div><br/></div><div>select a.*, b.* from a join b on a.id = b.id;    内连接</div><div><br/></div><div>select a.*, b.* from a,b;     笛卡尔积</div><div><br/></div><div><br/></div><div>笛卡尔积  和  内连接的 区别</div><div><br/></div><div>笛卡尔积 就是  没有连接条件的  连接</div><div><br/></div><div>如果说 以上两种编程场景需要我们去使用MapReduce来实现，  思路。！！！！！</div><div><br/></div><div><br/></div><div>分析问题：</div><div><br/></div><div>1、既然是两张表连接， MapReduce程序读取到的数据 不是  统一的一种格式，而是两种格式</div><div><br/></div><div>2、输入数据既然是两份不同格式的数据，那么一定会存在一个问题</div><div>     要判断出当前的mapTask所处理的数据到底是来自于哪个表</div><div><br/></div><div>3、怎么做链接？</div><div>    </div><div>     把两份能链接上的数据按照id分组，然后把所有要查询的字段都当做value来进行两层循环的拼接</div><div><br/></div><div><br/></div><div><br/></div><div>MapJoin的编程思路：</div><div><br/></div><div>1、编写一个MapReduce程序， 只读取 大表数据</div><div><br/></div><div>2、在该mapReduce程序中的mapper阶段，要把小表的所有数据加载到内存</div><div><br/></div><div>3、在setup方法中初始化一个hashmap</div><div><br/></div><div>     小表数据：<a href="hdfs://hadoop02:9000/join_e/input/b.txt">hdfs://hadoop02:9000/join_e/input/b.txt</a></div><div>     通过流的方式去进行读取小表数据，然后解析出来对应的key-value存储进入该hashmap中</div><div><br/></div><div>4、在mapper组件中的map方法中， map方法每调用一次，就是从大表中读取到的一条记录</div><div>  解析出来之后，去hashmap中进行匹配连接， 如果匹配，则输出。</div><div><br/></div><div>5、如果可以不用管其他的操作， 仅仅只是做链接， 那么就可以直接只使用mapper阶段就oK</div><div>不需要reducre阶段</div><div><br/></div></span>
</div></body></html> 