<html>
<head>
  <title>zookeeper-day1</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="6281"/>
<h1>zookeeper-day1</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/8/27 11:10</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/4/27 18:44</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>整个hadoop生态环境中只有zookeeper没有替代品, 其他都有替代品。</div><div><br/></div><div>1、第一周 ： LINUX</div><div>2、第二周 ： Hadoop 之  集群搭建  和  HDFS</div><div>3、第三周 ： Hadoop 之 MapReduce</div><div>4、第四周 ： Hive数据仓库工具</div><div><span style="font-size: unset; color: unset; font-family: unset;">5、第五周 ： zookeeper + 工具组件 + 基础增强</span></div><div><br/></div><div><br/></div><div>HBase ： HDFS    NDFS    nutch（索引库 + 分布式的爬虫）</div><div>mapreduce  结合 hdfs 和 hbase 的特征  最终设计出来的能够做一些的普通的统计分析的问题</div><div><br/></div><div>谷歌三篇论文：</div><div>     GFS</div><div>     MAPREDUCE</div><div>     BigTable</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">HDFS集群架构</span></div><div>HDFS集群是一主多从的架构</div><div><span style="font-size: unset; color: unset; font-family: unset;">一主多从的架构都会有一个问题 ： SPOF(单点故障)</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">必须要解决主从架构中的单点故障问题, </span><span style="font-size: unset; color: unset; font-family: unset;">在当前的HFDS中需要解决, </span><span style="font-size: unset; color: unset; font-family: unset;">在YARN集群中也需要。</span><span style="font-size: unset; color: unset; font-family: unset;">在所有的主从架构的集群中都需要解决。</span></div><div>分布式场景当中的 一致性的 问题 ,是一个非常复杂非常困难的问题, <span style="font-size: unset; color: unset; font-family: unset;">有些大牛，终其一生就在研究怎么去设计一个非常优良的分布式系统</span></div><div><br/></div><div>Zookeeper就是用来 协调所有 分布式场景 中的不一致的问题。大数据生态体系就相当于一个动物园,而Zookeeper就相当于一个动物园管理员, 让分布式的系统能够正常的流畅的运行起来。</div><div><br/></div><div>habse ： 主从架构 </div><div>Cassandra ： 无主架构（或者说多主架构） 因为它的主节点是动态的 可移动的 任何节点都有可能成为主节点</div><div><br/></div><div>Zookeeper能解决的hdfs的单点故障问题,而Zookeeper底层解决这个问题所用的就是paxos算法,解决两个问题:</div><div>    1、主节点的 active - standby 的选举算法</div><div>    2、分布式一致性算法 </div><div><br/></div><div>分布式场景中最重要的问题就是 数据不一致</div><div><br/></div><div>Zookeeper不是独一无二的,但却是唯一开源的,谷歌自己在用一个类似于Zookeeper的产品,叫chubby,但是只有谷歌自己在用, 而且并不开源。chubby  就是 zookeeper 的  前身。Zookeeper是Apache公司根据chubby开发出来的</div><div><br/></div><div>Zookeeper也是分布式的,HDFS也是分布式的,但是HDFS有单点故障(spof)问题,而Zookeeper作为一个管理员是没有单点故障的,它<span style="color: rgb(166, 0, 196);">自身具有很强的数据同步的功</span><span style="color: rgb(166, 0, 196);">能</span>和<span style="color: rgb(166, 0, 196);">很强的生命力</span></div><div style="margin-left: 40px;">&quot;<span style="color: rgb(166, 0, 196);">自身具有很强的数据同步</span><span style="color: rgb(166, 0, 196);">的功</span><span style="color: rgb(166, 0, 196);">能</span>&quot;是因为:</div><div style="margin-left: 80px;">zookeepr集群中的任意两个节点的数据状态一模一样。而且都是最新的数据信息。<span style="font-size: unset; color: unset; font-family: unset;">那么zookeeper中的数据是否能太多？不能。因为数据量过大, 导致一个节点都存不下的话反而更难保证数据的一致性, 只有每个节点都保存的是一份完整的数据, 才能更好的保证数据同步。所以zookeeper的数据量不能超过一个节点的存储能力。Zookeeper</span><span style="font-size: unset; color: unset; font-family: unset;">只能存储非常少量的关键数据, 像真实的数据是不可能存的,只有像元数据这样的信息才可以。</span></div><div style="margin-left: 80px;"><span style="font-size: unset; color: unset; font-family: unset;">保证每个节点的数据都一致，其实就是为了保证服务的高可用。</span><span style="font-size: unset; color: unset; font-family: unset;">既然要让所有节点都保持一致，那么节点的个数越多，数据同步的复杂度越高。</span></div><div style="margin-left: 40px;">&quot;<span style="color: rgb(166, 0, 196);">很强的生命力</span>&quot;是指如果集群当中宕机的节点的个数要小于半数， 那么整个集群是可用的。</div><div><br/></div><div><br/></div><div><br/></div><div>Zookeeper中的选举算法是按照一定的标准去选择，最终评判选举结果的方式是：少数服从多数</div><div><br/></div><div><br/></div><div>ZAB  ： zookeepr atomic broadcast (原子广播)</div><div style="margin-left: 40px;">是选举算法的一个变种。讲的是如果发送一条消息,超过一半的节点是接收成功的,则认为这条消息发送成功, 如果接收到的人不超过一半, 则认为这条消息发送失败</div><div style="margin-left: 40px;">zookeeper里,各节点通过ZAB来发起一次事务或投票,所有的节点都要参与,如果半数以上通过,则认为本次事务或投票成功,否则失败。</div><div><br/></div><div>zookeeper能提供的各种高级服务有很多：</div><div><img src="zookeeper-day1_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>甚至分布式的负载均衡也能实现。</div><div><br/></div><div>现在这些服务要基于底层最基础的两大核心功能：</div><div>1、znode系统。(在每一个节点上都有一份完整的znode系统)</div><div>     znode是一个数据存储系统, 数据存储系统区别与<span style="font-size: unset; color: unset; font-family: unset;">数据库、数据仓库和文件系统。znode不具备这三者的特性,它的目的仅仅只是给我们存储了一些简单的数据而已。(也有人叫znode系统为文件系统)</span></div><div>2、监听机制</div><div>    如果HDFS中有这样的需求: 配置信息一被修改,就能立刻同步到所有节点中。那么就需要先把这份配置信息先存到znode系统中去, 然后让HDFS中的节点都监控这一份数据。如果这份数据被某个节点把配置修改了,则所有节点立马就能知道配置信息也被修改, 而且也能得到新的配置信息</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>znode系统：</div><div>1、他是一个抽象的 跟linux的文件系统类似的 一种树形结构。也就是说znode系统<span style="font-size: unset; color: unset; font-family: unset;">也是一棵树,但他和文件系统中的树不一样</span></div><div>     文件系统：树中的每个节点一般来说都是 file  或者  directory</div><div>     zookeeper : 每个树中的节点都是znode</div><div><br/></div><div><br/></div><div>2、znode</div><div>首先区分一下file和directory:</div><div>     file： 存储真实数据</div><div>     directory：给所有的存储数据的file进行分类管理的。directory就是用来管理有某种相同特征的file的。(directory本身是不能直接存储数据的)</div><div><br/></div><div>     znode ：</div><div>          他既是文件夹 也是 文件, 也可以说 <span style="font-size: unset; color: unset; font-family: unset;">他既不是文件夹 也不是 文件</span></div><div>          因为znode同时拥有了 文件夹 和 文件功能, 也就是说<span style="font-size: unset; color: unset; font-family: unset;">znode既能存储数据，又能像文件夹一样挂载子节点</span></div><div>Linux文件系统目录树的树形结构和znode系统的目录树的树形结构如下:</div><div>    Linux文件系统和znode系统的根目录都是&quot;/&quot;</div><div><img src="zookeeper-day1_files/Image [1].png" type="image/png" data-filename="Image.png" width="748"/></div><div>上面的znode系统树形结构树抽象出来的,其实真正的存储格式是一个一个的znode对象, znode当中的数据有子结点和父节点的概念。所以把所有znode对象放在一起看,就可以抽象为一棵树。znode结点在底层的数据存储文件当中, 实际上真正存储的数据就是一个一个被序列化了的序列化的对象</div><div><br/></div><div>区分  znode节点  和 <span style="font-size: unset; color: unset; font-family: unset;">节点:</span></div><div>znode节点(其实正确的写法应该是znode<span style="color: rgb(166, 0, 196);">结</span>点),是znode系统中的一个结点, 而节点是指集群当中的一台服务器</div><div> </div><div><img src="zookeeper-day1_files/Image [2].png" type="image/png" data-filename="Image.png"/>   </div><div>也就是说一个znode结点的数据量最好小于1kb。因为数据存储的越多,数据同步的复杂度就越高,数据太多会导致数据同步的效率低下, 导致zookeeper服务的可用性就不高了。</div><div><br/></div><div><span style="font-weight: bold;">znode的分类:</span></div><div>znode在存储数据上没有任何区别(即在底层实现没有任何区别), 提供的功能上没有任何区别,只是使用上有所区别。</div><div><span style="color: rgb(166, 0, 196);">第一种分类方式如下: (断开连接是指退出当前会话)</span></div><div><img src="zookeeper-day1_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>        ephemeral结点下不能有子结点(也就是说就算是<span style="font-size: unset; color: unset; font-family: unset;">ephemeral类型的</span><span style="font-size: unset; color: unset; font-family: unset;">子</span><span style="font-size: unset; color: unset; font-family: unset;">结点</span><span style="font-size: unset; color: unset; font-family: unset;">也不行</span><span style="font-size: unset; color: unset; font-family: unset;">)</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">        即使是创建的是ephemeral结点对于其他会话来说也是可见的吗???</span></div><div><span style="color: rgb(166, 0, 196);">另一种分类的方式则分为四种:</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">persistent (持久的不带顺序编号的)</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">persistent_sequential (持久的带顺序编号的)</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">ephemeral (短暂的不带顺序编号的)</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">ephemeral_sequential (短暂的带顺序编号的)</span></div><div style="margin-left: 40px;">也就是将第一种分类方式再细分了一下。</div><div>        其中, sequential和非sequential的区别如下:</div><div><img src="zookeeper-day1_files/Image [4].png" type="image/png" data-filename="Image.png" width="748"/></div><div><br/></div><div>下面这句话的意思是创建sequential的znode结点的话,如果删除父节点下的sequential结点,则再在该父结点下创建一个sequential 的znode结点的话,它的编号不会是删除了的结点编号,而会是上一次创建的sequential 的znode结点的编号的下一个编号(不管上一次创建的结点还存不存在)。而&quot;由父节点维护&quot;的意思就是改顺序编号规则只在当前父结点有效,在另外的父结点中创建sequential 的znode结点的话,会是另外一套递增的编号,两套编号不冲突(也就是说两个不同的父结点里,编号可以相同)。</div><div><img src="zookeeper-day1_files/Image [5].png" type="image/png" data-filename="Image.png" width="710"/></div><div><span style="font-weight: bold;">监听机制</span></div><div>监听器 和 事件</div><div>    事件和监听器的关系是: 发生了某个事件，然后触发了监听器</div><div><br/></div><div>zookepeer为什么能让HDFS集群能够感知到所有的datanode的实时上下线?</div><div>    就是通过监听机制, 在某个znode结点下创建N个子结点,N为datanode节点的个数, 一个znode子结点代表一个datanode, 然后监控该znode结点下的子结点个数变化,如果增加1(增加了一个znode子结点),就表示上线了一个节点, 如果减少1 <span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">(减少了一个znode子结点)</span>,则表示宕机了一个节点</div><div><br/></div><div>触发事件的分类表:</div><div>getChildren只监听当前结点的子结点的数量的变化,不监听子结点的具体数据的变化 。</div><div>当删除子结点时, 如果某父结点有监听器getChildren, 该父结点的某个子结点同时有监听器exist, 则删除该子结点的时候会触发两个事件,子结点响应给客户端NodeDeleted事件, 父结点会响应给客户端NodeChildrenChange事件, 而客户端接受到通知会有个先后顺序, 会以当前节点的操作为主,也就是说会先响应该子结点的删除, 才会响应父结点的NodeChildrenChange(因为毕竟删除的不是父结点自身,而是他的孩子结点, 所以才会先响应其孩子结点自身的删除事件, 后面才会响应该父结点的NodeChildrenChange事件)。</div><div><img src="zookeeper-day1_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-weight: bold;">监听工作原理:</span></div><div><img src="zookeeper-day1_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>首先客户端向zookeeper服务器注册一个监听, 注册监听的同时会生成一个watcher对象存储到WatchManager里,(如果是当前会话第一次注册监听,注册一个监听的同时就会在客户端内部生成一个WatchManager对象,这个对象就是一个线程, 他会管理该客户端的<span style="color: rgb(209, 0, 255);">所有</span>监听器对象, 因为WatchManager对象管理的Watcher对象可以有很多个。) 不同的Watcher对象的process方法里的逻辑有可能都是不一样的。Zookeeper服务器(或者说其他客服端)发生了某事件,触发某监听后,会向客户端发送通知, 客户端就会自动去调用对应watcher对象的process方法。</div><div>// 如果有其他的客户端触发了当前的这次会话所添加的某某监听, <span style="font-size: unset; color: unset; font-family: unset;">其实zookeeper系统就会发送对应的监听的通知到该监听所对应的客户端,然后客户端就会去判断由哪个watcher对象的process方法来进行响应</span></div><div><span style="font-size: unset;"><br/></span></div><div>当前监听机制就是基于 观察者 设计模式实现的。</div><div><br/></div><div><span style="font-weight: bold;">监听器代码示例:</span></div><div><span style="color: rgb(166, 0, 196);">/**</span></div><div><span style="color: rgb(166, 0, 196);">* </span> <span style="color: rgb(166, 0, 196);">zk</span><span style="color: rgb(166, 0, 196);">对象内部有一个sessionID,记录的是哪个客户端拿到了一个会话连接</span></div><div><span style="color: rgb(166, 0, 196);">        客户端拿到这个会话连接后,通过这个会话连接就可以去注册各种监听事件。</span></div><div><span style="color: rgb(166, 0, 196);">   </span> <span style="color: rgb(166, 0, 196);">zk</span><span style="color: rgb(166, 0, 196);">内部还有一个 WatchManager  即一个监听器管理器。监听器管理器就是在当前获取到连接的客户端本地的一个线程, 这个线程就是管理当前会话所添加的所有的监听对象(Watcher对象)</span></div><div><span style="color: rgb(166, 0, 196);">*/</span></div><div>ZooKeeper <span style="color: rgb(166, 0, 196);">zk</span> = new ZooKeeper();</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">/**</span></div><div><span style="color: rgb(166, 0, 196);">    当前这个方法有三方面的含义:</span></div><div><span style="color: rgb(166, 0, 196);">*       哪个会话添加的监听(由sessionID来唯一区分)</span></div><div><span style="color: rgb(166, 0, 196);">*       添加的监听是作用于在哪个znode节点上(由sessionID来唯一区分)</span></div><div><span style="color: rgb(166, 0, 196);">*       该监听器监听的事件是什么(这里是getChildren方法,所以可以是NodeChildrenChanged或者NodeDeleted事件)</span></div><div><span style="color: rgb(166, 0, 196);">    childNodeList拿到的是&quot;/zk&quot;下的所有子结点的列表</span></div><div><span style="color: rgb(166, 0, 196);">    zk.getChildren()方法就是向zookeeper服务器发送一个请求去注册一个监听,并且在客户端本地新生成一个Watcher对象</span></div><div><span style="color: rgb(166, 0, 196);">*/</span></div><div>List&lt;String&gt;  childNodeList = zk.getChildren(&quot;/zk&quot;, new Watcher() {</div><div><span style="color: rgb(166, 0, 196);">     /**</span></div><div><span style="color: rgb(166, 0, 196);">     *   当前这个process方法如果要响应一个监听，那么这个监听是当前这个会话创建的,这是毋庸置疑的 </span></div><div><span style="color: rgb(166, 0, 196);">         那么这个监听到底是哪个znode上的什么事件？就是由WatchedEvent的对象来获得这些信息的。</span></div><div><span style="color: rgb(166, 0, 196);">        WatchedEvent的event对象就是zookeeper系统在意识到系统内的某个节点发了什么对应的变化之后就会给客户端发送的</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">监听的通知, 也就是说</span><span style="color: rgb(166, 0, 196);">event是zookeeper发送过来的那个通知(也就是说zookeeper发送给客服端的通知是一个WatchedEvent对象)。所以里面才会包含信息:</span></div><div><span style="color: rgb(166, 0, 196);">          type = event.getEventType();  (type得到的值即是监听的事件的类型)</span></div><div><span style="color: rgb(166, 0, 196);">          path = event.getPath();    (path得到的就是绝对路径, 也就是得到了是哪个节点的响应事件)</span></div><div><span style="color: rgb(166, 0, 196);">        由type和path就知道了当前监听是哪个znode上的什么事件</span></div><div><span style="color: rgb(166, 0, 196);">        因为是getChildren方法,所以这里type的类型可以是NodeChildrenChanged或者NodeDeleted事件,所以用if语句判断一下你想响应的事件是哪种。</span></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">        要想做到循环监听, 只需要在process的内部添加一个监听就行了,这样就会一直像递归一样调用自身。</span></div><div><span style="color: rgb(166, 0, 196);">     */</span></div><div>     public process(WatchedEvent event){</div><div>  <span style="color: rgb(166, 0, 196);">       // 这个process方法的内部就是  对应的监听的事件被响应了之后需要做的业务逻辑的代码编写的地方。 直观上理解是某事件发生触发了监听器,在代码上理解某事件发生触发的就是process方法的运行</span></div><div>          type = event.getEventType();</div><div>          path = event.getPath();</div><div>     }</div><div>});</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">基于znode系统 和  监听机制 就能实现各种高级服务,如:</span></div><div>分布式锁</div><div>配置管理</div><div>集群管理</div><div>队列管理</div><div>......</div><div><br/></div><div>比如集群管理中对namenode的管理。如下图所示:</div><div>    假设是一个高可用集群,集群中有三个namenode节点分别是hadoop02、hadoop03、hadoop04,而hadoop02是active状态, 其他则是standby状态。就可以通过zookeeper来监听/namenodes目录下的子结点状态, 如果hadoop02被删除了,则说明它宕机了,则可以用zookeeper通过选举算法立刻从hadoop03和hadoop04中选出一个新节点来作为新的active的namenode节点。</div><div>   <img src="zookeeper-day1_files/Image [8].png" type="image/png" data-filename="Image.png" style="color: unset; font-family: unset; font-size: unset;" width="452"/></div><div><br/></div><div><span style="font-weight: bold;">锁:</span></div><div>读锁  +  写锁</div><div>读锁  ==  共享锁, <span style="font-size: unset; color: unset; font-family: unset;">写锁  ==  独占锁(排它锁)</span></div><div>假如有一个key-vlaue对：    name=&quot;huangbo&quot;;</div><div style="margin-left: 40px;">读取的时候 加 读锁，   其他的客户端在意识到当前这份数据被加了读锁的话，那么所有客户端就只能做读的操作,<span style="font-size: unset; color: unset; font-family: unset;">不能做写的操作</span></div><div style="margin-left: 40px;">如果有一个客户端线程过来去进行该值的修改，那么请加 写锁</div><div style="margin-left: 40px;">如果加入了写锁，那就意味着当前这个key的值   其他客户端线程的读写操作都不能进行了。</div><div>加读写锁 和 直接加锁 哪种好?</div><div>当然是加读写锁好, 因为直接加锁是某客户端线程不管是读还是写,都是直接加锁,不允许别的线程读和写。这样比分为读写锁效果差了很多。</div><div><br/></div><div>设计zookeeper的读写锁机制:</div><div>    也是同样用znode系统来实现, 如果以某个目录来作为某个文件的读写锁:</div><div>    如果目录下要添加一个子结点为read(也就是说有一个客户端线程要读该文件), 如果该目录里没有write(也就是说有一个客户端线程要写该文件)结点,则允许添加,否则阻塞该read结点,直到该writer结点被删除; 如果目录下全是read结点, 则允许其他read结点添加到该目录下,但是如果是write结点要添加进来,则阻塞该写线程, 直到前面的所有read结点被删除。当目录下有个write结点时,则不管新来的是read结点还是write结点, 都不能再添加进来</div><div><img src="zookeeper-day1_files/Image [9].png" type="image/png" data-filename="Image.png" width="440"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Zookeeper搭建思路：(注意, zookeeper只需在hadoop用户下安装, 不需要在root用户下)</span></div><div>        (我是在hadoop02、hadoop03、hadoop04搭建的,hadoop05没有</div><div>            但hadoop05中有zookeeper的安装包以及安装目录)</div><div>注意: 安装zookeeper集群有一个特点：集群的节点个数，必须是奇数。</div><div>    奇数个数  是为了方便进行选举(因为是选举是少数服从多数,所以要避免出现平票的情况)。</div><div><span style="color: rgb(255, 0, 0);">1、获取安装包(这里用的是zookeeper-3.4.10.tar.gz),上传到虚拟机。</span></div><div><span style="color: rgb(255, 0, 0);">    put D:/暑假Hadoop/软件/学习zookeeper时用到的软件/zookeeper-3.4.10.tar.gz</span></div><div><span style="color: rgb(255, 0, 0);">2、解压，安装</span></div><div><span style="color: rgb(255, 0, 0);">     tar -zxvf zookeeper-3.4.10.tar.gz -C ~/apps/</span></div><div><span style="color: rgb(255, 0, 0);">3、修改配置文件 (到安装目录的conf文件夹下修改)</span></div><div><span style="color: rgb(255, 0, 0);">     cd /home/hadoop/apps/zookeeper-3.4.10/conf</span></div><div><span style="color: rgb(255, 0, 0);">     cp zoo_sample.cfg zoo.cfg</span></div><div><span style="color: rgb(255, 0, 0);">     vim zoo.cfg  </span></div><div>zoo.cfg里的配置信息如下:</div><div><img src="zookeeper-day1_files/Image [10].png" type="image/png" data-filename="Image.png" width="748"/></div><div>    <span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">修改对应的配置信息如下:</span></span></div><div>    <span style="color: rgb(255, 0, 0);">zoo.cfg配置文件中有一个非常重要的配置信息要修改: </span></div><div><span style="color: rgb(255, 0, 0);">     // znode数据存储系统中的所有znode节点的数据存储目录,默认是dataDir=/tmp/zookeeper, 修改为如下</span></div><div>     <span style="color: rgb(255, 0, 0);">dataDir=/home/hadoop/data/zkdata/</span></div><div>  <span style="color: rgb(255, 0, 0);">  并在zoo.cfg文件的末尾添加如下几行,然后保存、退出: </span></div><div><span style="color: rgb(255, 0, 0);">         server.2=hadoop02:2888:3888</span></div><div><span style="color: rgb(255, 0, 0);">         server.3=hadoop03:2888:3888</span></div><div><span style="color: rgb(255, 0, 0);">         server.4=hadoop04:2888:3888</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    注意：</span></div><div>     配置信息中, server.<span style="color: rgb(166, 0, 196);">3</span>=hadoop03:2888:3888    的意思如下</div><div style="margin-left: 40px;">     server是一个固定的名称</div><div style="margin-left: 40px;">     <span style="color: rgb(166, 0, 196);">3</span>就是对应的hadoop03这台服务器的myid</div><div style="margin-left: 40px;">     2888：心跳端口的默认值(任意两台服务器进行连接通信时所使用的端口)</div><div style="margin-left: 40px;">     3888：选举端口的默认值(选举是通信用的端口)</div><div>修改结果如下: </div><div><img src="zookeeper-day1_files/Image [11].png" type="image/png" data-filename="Image.png" width="748"/></div><div>  </div><div><span style="color: rgb(255, 0, 0);">4、配置环境变量</span></div><div>  <span style="color: rgb(255, 0, 0);">  vim /home/hadoop/.bashrc</span></div><div><span style="color: rgb(255, 0, 0);">    末尾添加如下两行:</span></div><div><span style="color: rgb(255, 0, 0);">         export ZOOKEEPER_HOME=/home/hadoop/apps/zookeeper-3.4.10</span></div><div><span style="color: rgb(255, 0, 0);">         export PATH=$PATH:$ZOOKEEPER_HOME/bin</span></div><div><span style="color: rgb(255, 0, 0);">    再重新加载配置文件: source /home/hadoop/.bashrc</span></div><div>5、群发配置好的zookeeper安装目录和环境变量文件。<span style="color: rgb(255, 0, 0);">在&quot;Send chat to all sessions&quot;窗口</span><span style="color: rgb(255, 0, 0);">输入下列命令群发:(</span>假设前面这些安装步骤都是在hadoop04上进行的<span style="color: rgb(255, 0, 0);">)</span></div><div><span style="color: rgb(255, 0, 0);">    scp -r</span> <span style="color: rgb(77, 206, 29);">hadoop</span><span style="color: rgb(255, 0, 0);">@</span><span style="color: rgb(255, 0, 0);">hadoop0</span><span style="color: rgb(77, 206, 29);">4</span><span style="color: rgb(255, 0, 0);">:</span><span style="color: rgb(77, 206, 29);">/home/hadoop</span><span style="color: rgb(255, 0, 0);">/apps/</span><span style="color: rgb(255, 0, 0);">zookeeper-3.4.10/</span> <span style="color: rgb(77, 206, 29);">/home/hadoop</span><span style="color: rgb(255, 0, 0);">/apps/</span><span style="color: rgb(255, 0, 0);">zookeeper-3.4.10/</span></div><div><span style="color: rgb(255, 0, 0);">    s</span><span style="color: rgb(255, 0, 0);">cp -r</span> <span style="color: rgb(77, 206, 29);">hadoop</span><span style="color: rgb(255, 0, 0);">@</span><span style="color: rgb(255, 0, 0);">hadoop0</span><span style="color: rgb(77, 206, 29);">4</span><span style="color: rgb(255, 0, 0);">:</span><span style="color: rgb(77, 206, 29);">/home/hadoop</span><span style="color: rgb(255, 0, 0);">/.bashrc</span> <span style="color: rgb(77, 206, 29);">/home/hadoop</span><span style="color: rgb(255, 0, 0);">/</span><span style="color: rgb(255, 0, 0);">.bashrc</span></div><div><span style="color: rgb(255, 0, 0);">    </span><span style="color: rgb(255, 0, 0);">source /home/hadoop/.bashrc</span></div><div>6、<span style="color: rgb(166, 0, 196);">zookeeper集群</span>中的每个节点都有参与选举的能力。每个参与选举的节点都有一个对应的ID叫做myid。这个myid每个zookeeper节点都必须分配一个。</div><div>     myid ： 每个节点都必须分配一个不重复的数值范围在 1 - 255 之间的任意一个数</div><div>     也即是要在/home/hadoop/data/zkdata/目录下创建一个myid的文件, <span style="font-size: unset; color: unset; font-family: unset;">该文件中只存储一个id值。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    所以</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">命令如下:</span></span></div><div><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">        在hadoop02中写:</span></span></div><div><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">            mkdir </span><span style="color: rgb(255, 0, 0);">/home/hadoop/data/zkdata/</span></div><div><span style="color: rgb(255, 0, 0);">            echo   2 &gt; /home/hadoop/data/zkdata/myid</span></div><div><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    </span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    在hadoop03中写:</span></div><div><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    </span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    </span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    mkdir </span><span style="color: rgb(255, 0, 0);">/home/hadoop/data/zkdata/</span></div><div><span style="color: rgb(255, 0, 0);">            echo   3 &gt; /home/hadoop/data/zkdata/myid</span></div><div><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    </span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    在hadoop04中写:</span></div><div><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    </span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    </span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">    mkdir </span><span style="color: rgb(255, 0, 0);">/home/hadoop/data/zkdata/</span></div><div><span style="color: rgb(255, 0, 0);">            echo   4 &gt; /home/hadoop/data/zkdata/myid   </span></div><div>7、直接启动即可</div><div>        在<span style="color: rgb(166, 0, 196);">每个节点上</span>都要执行以下命令: 可使用<span style="color: rgb(255, 0, 0);">&quot;Send chat to all sessions&quot;窗口的群发功能</span></div><div>            <span style="color: rgb(255, 0, 0);">zkServer.sh start</span></div><div>    注意: 如果只是在已经存在的zookeeper集群新添加一个zookeeper节点,则需要先启动以前已经有了的节点,才能启动新加入集群的节点。</div><div>8、验证</div><div>        首先在每个节点上执行以下命令: (可使用<span style="color: rgb(255, 0, 0);">&quot;Send chat to all sessions&quot;窗口的群发功能</span>)</div><div>            <span style="color: rgb(255, 0, 0);">zkServer.sh status</span></div><div><span>    </span><span>    </span>每个节点的打印信息为下面两图中的两种状态之一即可: </div><div><span>    </span><span>   <span>    </span> </span><img src="zookeeper-day1_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><span>    </span><span>  <span>    </span>  </span><img src="zookeeper-day1_files/Image [13].png" type="image/png" data-filename="Image.png" width="741"/></div><div>        再使用jps命令查看是否有守护进程如下:</div><div>       <img src="zookeeper-day1_files/Image [14].png" type="image/png" data-filename="Image.png" width="272"/>      </div><div>  </div><div><br/></div><div><br/></div><div><br/></div><div> </div><div>选举： <span style="color: rgb(166, 0, 196);">在刚初始完的时候</span>，集群的leader的选举只会有一个因素： myid的大小</div><div><span style="font-size: unset; color: unset; font-family: unset;">        规则就是：  myid小的同意大的。 少数服从多数 (也即是myid大的会成为leader)</span></div><div>    所以可以通过zkServer.sh stop 停用leader节点来观察leader节点会如何变化</div><div>安装过程容易出现以下错误:</div><div>     1、zookeeper集群的安装目录不一致</div><div>     2、zookeepr集群中的任意节点的myid文件不齐全</div><div>     3、myid重复</div><div>     4、有的节点没有myid (myid每个节点都必须有,而且不能重复)</div><div><br/></div><div>  整个zookeeper的集群的角色其实分为三种：</div><div>     leader ： <span style="color: rgb(166, 0, 196);">整个集群中的所有写数据请求都是由leader进行处理</span></div><div>     follower ： <span style="color: rgb(166, 0, 196);">能接收所有的读写请求，但是读数据请求自己处理，写数据请求转发给leader</span></div><div>     observer ： <span style="color: rgb(166, 0, 196);">跟follower的唯一的区别就是</span> <span style="color: rgb(166, 0, 196);">observer</span><span style="color: rgb(166, 0, 196);">没有 选举权 和 被选举权</span></div><div>     observer其实跟follower类似， 只不过是为了给zookeeper进行扩充之使用。observer<span style="font-size: unset; color: unset; font-family: unset;">不会改变原来集群的主从所属关系, </span><span style="font-size: unset; color: unset; font-family: unset;">仅仅只是接受请求，然后进行处理，没有投票的权利，也没有被选举成为leader的权利。也就是说observer的作用就是用来分担一部分数据查询的压力</span></div><div><br/></div><div>zookeeper集群的个数必须是奇数个其实是要求参与选举的集群的节点个数必须是奇数个。所以说observer角色的节点不包括在内,加上observer角色的节点的集群有偶数个节点也没关系,只要能投票的节点是奇数个即可。所以zookeeper集群倘若是按如下配置的,也是正确的配法(但我没这样配)。</div><div>     server.2=hadoop02:2888:3888</div><div>     server.3=hadoop03:2888:3888</div><div>     server.4=hadoop04:2888:3888</div><div>     server.5=hadoop05:2888:3888:observer</div><div>observer角色的节点用zkServer.sh status查看如下:</div><div><img src="zookeeper-day1_files/Image [15].png" type="image/png" data-filename="Image.png" width="724"/></div><div><br/></div><div>为什么myid要每个节点都必须分配一个不重复的数值范围在 1 - 255 之间的任意一个数???如果zookeeper集群超过255个咋办?</div><div>Zookeeper集群的节点数不能过多, zookeeper集群节点数如果超过100台的话不仅节点越多对zookeeper没用,而且zookeeper的执行效率会越来越低。所以根本不推荐zookeeper集群超过255台。因为节点越多,进行数据同步的难度就越大。</div><div>zookeeper的性能 随着节点数的增加 大概如下图所示:</div><div>    所以一般小公司的集群zookeeper搭个3~5个节点已经够了, 大一点的集群则搭个几十个zookeeper节点就已经很厉害了。如果hadoop集群有1000个节点, 那么zookeeper集群可能就5~7个节点,。如果hadoop集群有10000个节点, 那么zookeeper集群最多搭个20多台就足够了。</div><div><img src="zookeeper-day1_files/Image [16].png" type="image/png" data-filename="Image.png" width="419"/></div><div><br/></div><div><br/></div><div>cZxid = 0x0</div><div>ctime = Thu Jan 01 08:00:00 CST 1970</div><div>mZxid = 0x0</div><div>mtime = Thu Jan 01 08:00:00 CST 1970</div><div>pZxid = 0x0</div><div>cversion = -1</div><div>dataVersion = 0</div><div>aclVersion = 0</div><div>ephemeralOwner = 0x0</div><div>dataLength = 0</div><div>numChildren = 1</div><div><br/></div><div><br/></div><div>zxid ：zookeeper集群内部在工作的时候所使用的一个全局的分布式事务的编号</div><div><br/></div><div>zxid分成两部分： 它一个64位的一个长整型的数</div><div><br/></div><div>高32位表示当前的leader关系是否改变</div><div>低32位表示当前这个leader领导期间的所有事务编号</div><div><br/></div><div>道光3年</div><div>民国33年  == 1944年</div><div><br/></div><div><br/></div><div><a href="zookeeper-day1_files/zookeeper-part1-理论和使用.pdf"><img src="zookeeper-day1_files/77234d766a9d8d940f6c493cfbcd2eb1.png" alt="zookeeper-part1-理论和使用.pdf"></a></div><div><br/></div></span>
</div></body></html> 