<html>
<head>
  <title>day4-shell编程</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="844"/>
<h1>day4-shell编程</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/7/9 20:33</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/9/13 0:02</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-weight: bold;">1.source的使用</span></div><div>（1）使用source时</div><div>在a.sh中使用source调用b.sh时，就相当于把b.sh文件里的代码原封不动的放到了a.sh中source命令当前的位置处，然后程序按照从上往下的顺序依次执行代码，程序始终是在系统中的同一个进程中执行，没有从一个进程跳转到另一个进程。所以结果如图所示:</div><div><img src="day4-shell编程_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>  （2）不使用source时</div><div>在a.sh中直接用路径调用b.sh时(直接用路径调用b.sh需要b.sh有执行权限,用source则不用)，则程序会在执行到路径所在位置时，会直接跳转到b.sh去执行，待b.sh执行完后，才回到a.sh继续执行。也就是说：在系统为a.sh分配了一个进程执行a.sh里的内容时，执行到/root/bin/b.sh处时，系统重新为执行a.sh的进程分配一个<span style="color: rgb(166, 0, 196);">子进程</span>执行b.sh，待执行b.sh的子进程执行完毕后，<span style="color: rgb(255, 0, 0);">子进程终止，该进程所占用的内存空间释放，</span>同时继续回到执行a.sh的父进程继续执行。所以b.sh中的B变量的声明定义并不能被文件a.sh知晓, 同理a.sh中的A变量的声明定义也并不能被文件b.sh知晓，就如同高级编程语言中的函数调用一样，/root/bin/b.sh命令就像是将b.sh函数在a.sh函数中调用一样。<span style="color: rgb(235, 0, 115);">而与高级编程语言的函数调用一样，在A函数内部调用B函数，若不传参，B函数同样无法使用A函数里面的局部变量。所以，没有source，子进程同样无法使用父进程的变量。而在(1)中</span><span style="color: rgb(235, 0, 115);">使用了source则不一样, b.sh是可以访问到a.sh的局部变量的, 而在source语句后面如果还有代码的话, a.sh也可以访问到b.sh的局部变量了</span></div><div><img src="day4-shell编程_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>在使用该文件（脚本）的路径作为语句调用别的脚本文件时（如上图的/root/bin/b.sh也就是不用source或 . 命令的情况下）：</div><div style="margin-left: 40px;">如果一个变量由关键字export修饰，那么该变量将会变成全局变量。那么该变量所在的进程的所有<span style="color: rgb(166, 0, 196);">子</span>进程都能访问该全局变量，但和上面相同的道理，该变量即使用export修饰变为全局变量，也无法被他的<font style="color: rgb(166, 0, 196);">父</font>进程使用（其实就是因为子进程执行完毕后其内存空间将会被释放，其中所存储的全局变量也会不见，所以父进程根本访问不到）</div><div><span style="font-weight: bold;">2.运算符</span></div><div><span style="font-weight: bold;"><img src="day4-shell编程_files/Image [2].png" type="image/png" data-filename="Image.png" width="598"/></span></div><div>用双括号比较适合我们平常的使用，不用去记那么多shell编程自定义的新符号，[[]]双括号不仅可以直接使用我们常用的逻辑运算符与或非（&amp;&amp; || ! ），还能正常使用关系运算符的(&lt; &gt; =)等，如 [[ 1 &gt; 2 ]] 可以正确判断出里面的含义，但是注意使用双括号时,里面的内容左右两边各必须要有一个空格，且内容和运算符之间也必须要有空格，即[[ 1 &gt; 2 ]]等价于[[空格1空格&gt;空格2空格]]。</div><div><span style="color: rgb(255, 0, 0);">需要注意: shell对运算符附近的空格管理比较严格。如a.sh文件里有如下内容:</span></div><div style="margin-left: 40px;"><span style="color: rgb(255, 0, 0);">#!/bin/bash</span></div><div style="margin-left: 40px;"><span style="color: rgb(255, 0, 0);">A=&quot;hello world&quot;</span></div><div style="margin-left: 40px;"><span style="color: rgb(255, 0, 0);">echo $A</span></div><div><span style="color: rgb(255, 0, 0);">但如果A=&quot;hello world&quot;写成了A = &quot;hello world&quot; , 执行就会报错, 就只是在等号左右加了两个空格, 都不行。</span></div><div><br/></div><div><span style="font-weight: bold;">3.函数</span></div><div>例一：</div><div><span style="font-weight: bold;"><img src="day4-shell编程_files/Image [3].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div>例二：</div><div><span style="font-weight: bold;"><img src="day4-shell编程_files/Image [4].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="font-weight: bold;"><img src="day4-shell编程_files/Image [5].png" type="image/png" data-filename="Image.png"/></span></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">    特殊变量</span></div><div><br/></div><div>        $$   进程号</div><div>        $#   参数个数</div><div>        $?   上一句代码的返回状态码</div><div>        $*   参数列表</div><div>        $@   参数列表</div><div>        $1   第一个位置上的参数</div><div>        $2   第二个位置的参数</div><div>        ${12}  第十二个位置上的参数</div><div>        $0   执行命令中的脚本的名称</div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">shell脚本中if语言的各种参数:</span></div><div><br/></div><div>查看文件或者目录是否存在，经常用到-d,-e,-f，其中区别如下</div><div><span style="font-size: unset; color: unset; font-family: unset;">-e filename 如果 filename存在，则为真</span></div><div>-d filename 如果 filename为目录，则为真</div><div>-f filename 如果 filename为<a href="http://www.so.com/s?q=%E5%B8%B8%E8%A7%84&amp;ie=utf-8&amp;src=internal_wenda_recommend_textn">常规</a>文件，则为真</div><div>-L filename 如果 filename为<a href="http://www.so.com/s?q=%E7%AC%A6%E5%8F%B7&amp;ie=utf-8&amp;src=internal_wenda_recommend_textn">符号</a>链接，则为真</div><div>-r filename 如果 filename可读，则为真</div><div>-w filename 如果 filename可写，则为真</div><div>-x filename 如果 filename可执行，则为真</div><div>-s filename 如果文件长度不为0，则为真</div><div>-h filename 如果文件是软链接，则为真</div><div>filename1 -nt filename2 如果 filename1比 filename2新，则为真。</div><div>filename1 -ot filename2 如果 filename1比 filename2旧，则为真。</div><div>-eq 等于</div><div>-ne 不等于</div><div>-gt 大于</div><div>-ge 大于等于</div><div>-lt 小于</div><div>-le 小于等于</div><div style="margin-top: 1em;margin-bottom: 1em;-en-paragraph:true;"></div><div>字符串变量表达式 </div><div>if [ $a = $b ] 如果string1等于string2，则为真，字符串允许使用赋值号做等号 </div><div>if [ $string1 != $string2 ] 如果string1不等于string2，则为真 </div><div>if [ -n $string ] 如果string 非空(非0），返回0(true) ,否则为假</div><div>if [ -z $string ] 如果string 为空，则为真 </div><div>if [ $sting ] 如果string 非空，返回0 (和-n类似) 逻辑非 ! 条件表达式的相反 </div><div>if [ ! 表达式 ] </div><div>if [ ! -d $num ] 如果不存在目录$num 逻辑与 –a 条件表达式的并列 </div><div>if [ 表达式1 –a 表达式2 ] 逻辑或 -o 条件表达式的或 </div><div>if [ 表达式1 –o 表达式2 ]</div><div><br/></div><div>举例:</div><div>shell 中利用 -n 来判定字符串非空。</div><div>错误用法：</div><div style="margin-left: 40px;">ARGS=$*</div><div style="margin-left: 40px;">if [ -n $ARGS  ]</div><div style="margin-left: 40px;">then</div><div style="margin-left: 40px;">   print &quot;with argument&quot;</div><div style="margin-left: 40px;">fi</div><div style="margin-left: 40px;">print &quot; without argument&quot;</div><div>这样写的结果是,不管$ARGS具体参数是啥，if语句都是true, 打印的结果都会是: with argument</div><div>原因：因为$ARGS不加双引号时该if语句等价于if [ -n ]，也就是说, shell 会把该if语句当成if [ str1 ]来处理(其中str1的值为-n)，所以自然str1不为空，所以if为真。</div><div>正确用法：需要在$ARGS上加入双引号，即if语句变为if [ -n &quot;$ARGS&quot; ]。</div><div><span style="color: rgb(134, 0, 164); font-weight: bold;">—————————————————手写与上传资料分割线—————————————————</span></div><div><br/></div><div><br/></div><div><a href="day4-shell编程_files/linux-part4-Shell编程.pdf"><img src="day4-shell编程_files/922a664afa9dfcc4951794b59f357f01.png" alt="linux-part4-Shell编程.pdf"></a></div><div><br/></div><div>1、shell概述</div><div><br/></div><div>    程序设计语言</div><div><br/></div><div>        linux的shell也是一种编程语言 --- 程序设计语言</div><div>        shell ：外壳</div><div>        Linux的内核</div><div><br/></div><div>        操作这个内核：通过外壳协议。 shell编程语言</div><div><br/></div><div>        shell操作：  应用软件    shell命令</div><div><br/></div><div>        每次执行一个shell命令都能立即得到该命令的执行结果，这种过程： 叫做交互式</div><div><br/></div><div>        java编程语言。 没有。   javac java</div><div><br/></div><div>        静态/脚本 + 动态</div><div><br/></div><div>        编译型 + 解释型</div><div><br/></div><div>        区别：静态的不需要编译，直接直接解释执行</div><div><br/></div><div>        一般来说，静态编程语言，都会提供交互的客户端</div><div>        动态语言。一般来说不提供。</div><div><br/></div><div>        shell就是一个交互式的脚本编程语言</div><div><br/></div><div>    静态、脚本、动态</div><div>    shell常用的解释器</div><div><br/></div><div>        解释器：  shell的解释器</div><div><br/></div><div>        默认的shell解释器： bash  </div><div>        csh  tsh ksh</div><div><br/></div><div>    shell编程语言的工作原理</div><div><br/></div><div>        shell脚本的工作原理：</div><div><br/></div><div>        1、代码的执行机制</div><div><br/></div><div>            脚本语言：从上到下顺序执行</div><div>            编译型：java ，代码执行顺序没有顺序</div><div>                </div><div>        2、shell脚本其实就是通过一些流程控制来组织一些单个的shell命令</div><div><br/></div><div>            1、shell 编程中有流程控制 + 变量的定义</div><div>            2、其实shell编程中的关键字，除了流程控制的那些关键字之外，全部都是 命令</div><div>               shell命令就是shell编程中的关键字</div><div><br/></div><div>            shell命令是关键字。</div><div>            能不能定义一个变量的名称即是一个命令的名称？  </div><div>            cd=3</div><div><br/></div><div>            变量定义的取值范围，不能是该编程语言当中的 关键字 和 保留字</div><div><br/></div><div>2、shell编程的基本格式</div><div><br/></div><div>    shell命令 + 关键字 + 其他语法（|  &gt;&gt; ）</div><div><br/></div><div>    shell编程的入门程序</div><div><br/></div><div>        helloworld.sh</div><div><br/></div><div>        #!/bin/bash     ####  用来声明该脚本在某些情况下是用什么样的解释器去执行</div><div>        echo &quot;hello world&quot;</div><div><br/></div><div>        文件名变量的命名规则： 最好采用驼峰规则</div><div><br/></div><div><br/></div><div>3、shell脚本的执行方式</div><div><br/></div><div>    1、调用解释执行 sh    bash 等</div><div><br/></div><div>        sh helloworld.sh</div><div>        bash helloworld.sh    直接调用某个解释去执行脚本</div><div><br/></div><div>    2、source 或者 .</div><div><br/></div><div>        使用默认的解释器去执行</div><div><br/></div><div>    3、赋予执行权限，直接执行该脚本</div><div>    </div><div>        可以直接调用脚本文件的全路径来执行该脚本：必须要给执行该脚本的用户赋予执行权限</div><div>        chmod u+x helloworld.sh</div><div><br/></div><div>    在默认情况下， 如果没有声明解释器，那么就调用当前会话的那个bash的解释器去执行</div><div><br/></div><div><br/></div><div>4、shell注释</div><div><br/></div><div>    单行 注释</div><div>    多行注释</div><div><br/></div><div>    推荐： 不管用什么编程语言写代码，要养成写注释的好习惯</div><div><br/></div><div>    核心精髓：  贵精 不  贵多</div><div><br/></div><div>5、shell变量</div><div><br/></div><div>    系统变量</div><div><br/></div><div>        set</div><div><br/></div><div>    自定义变量</div><div><br/></div><div>        自定义的变量名称的规范： 都大写</div><div><br/></div><div>        在使用该脚本的可执行权限去执行时：</div><div><br/></div><div>        如果一个变量用export去修饰，那么该变量能够提升为全局变量。 那么该进程的所有子进程都能访问</div><div>        如果一个变量用export去修饰，该变量无论如何都没法让它的父进程去使用</div><div><br/></div><div>        source 和 . 的执行方式，是把 b.sh 脚本的内容读取出来放到a.sh的进程中一起顺序执行。</div><div><br/></div><div>        问题：为什么在配置环境变量时，要把JAVA_HOME 和 PATH 要用export去修饰？</div><div><br/></div><div>        每个用户在登录的时候，都会自动去寻找对应的用户环境变量的配置文件去加载。</div><div>        所以每个用户在登录的时候时候。该登录命令的执行进程都会加载该环境变量配置文件中的所有变量</div><div>        如果使用export去修饰，那么该用户以后无论执行什么脚本 都能访问得到在环境变量中用</div><div>        export修饰的变量</div><div><br/></div><div>    特殊变量</div><div><br/></div><div>        $$   进程号</div><div>        $#   参数个数</div><div>        $?   上一句代码的返回状态码</div><div>        $*   参数列表</div><div>        $@   参数列表</div><div>        $1   第一个位置上的参数</div><div>        $2   第二个位置的参数</div><div>        ${12}  第十二个位置上的参数</div><div>        $0   执行命令中的脚本的名称</div><div><br/></div><div><br/></div><div>6、运算符</div><div><br/></div><div>    算术运算符  + - * / %</div><div>    关系运算符  &gt; &gt;= &lt; &lt;= !=</div><div>    布尔运算符  true false</div><div>    位运算符    &amp; |   </div><div>    逻辑运算符  &amp;&amp; || ！</div><div>    字符串运算符  -z -n</div><div>    文件运算符  -d -f -l -e</div><div><br/></div><div>    [ $(echo &quot;2.2 &gt; 2&quot; |bc) -eq 1 ] &amp;&amp; echo yes || echo no</div><div><br/></div><div><br/></div><div>7、流程控制</div><div><br/></div><div>    if</div><div>    while</div><div>    case</div><div>    for</div><div>    until</div><div>    跳出循环</div><div><br/></div><div><br/></div><div>    字符串的处理（截取， 替换，  查找）</div><div>    日期时间的处理</div><div><br/></div><div><br/></div><div>8、数组</div><div><br/></div><div>    数组的定义</div><div>    数组的访问</div><div>    数组的遍历</div><div><br/></div><div><br/></div><div>9、shell读取文件内容</div><div><br/></div><div>    读取文件  读</div><div>    定向符   &gt;   &gt;&gt;   写</div><div>    管道符   cmd1 | cmd2 | cmd3 | cmd4</div><div><br/></div><div><br/></div><div>10、函数</div><div><br/></div><div>    函数的定义</div><div><br/></div><div>        function myfunc(){</div><div>            echo &quot;hello&quot;</div><div>        }</div><div>        1、定义函数必须使用function来声明</div><div>        2、函数名追随变量名的取名规范， 函数名最好不要跟系统中的某些命令重复</div><div>        3、shell的函数本身不用声明传参，在使用的时候，进行传参</div><div>        传参的方式跟对脚本传参的方式一样  sh for.sh 1 2 3</div><div>        4、函数的使用方式和普通命令一样。把函数当做是普通命令即可</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>    函数的调用</div><div>    函数的传参</div><div><br/></div><div>        function myfunc(){</div><div>            echo &quot;hello&quot;</div><div>            echo $#</div><div>            echo $1</div><div>        }</div><div>        echo $1</div><div>        echo $#</div><div>        myfunc 1 2 a b</div><div>    </div><div>        执行脚本： sh func.sh a b 1 2</div><div>    </div><div>    函数的返回值</div><div><br/></div><div>        function myfunc(){</div><div>            echo &quot;hello&quot;</div><div>            echo $#</div><div>            return 254</div><div>        }</div><div>        echo $#</div><div>        myfunc 1 2 a b</div><div>        echo $?</div><div><br/></div><div>    跨脚本调用函数</div><div><br/></div><div>        </div><div><br/></div><div><br/></div><div>11、shell编程综合案例</div><div><br/></div><div>    99乘法表</div><div>    集群自动安装JDK</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>12、shell编程其他有用小技巧</div><div><br/></div></span>
</div></body></html> 