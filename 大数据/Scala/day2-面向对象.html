<html>
<head>
  <title>day2-面向对象</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="8520"/>
<h1>day2-面向对象</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/5/19 11:52</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/7/24 17:18</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><div>java中的print和println中只能输出一个某种类型的变量(比如字符串里面夹杂多个变量, 但最终输出的就只是一个字符串), 而scala中的print和println可以用&quot;,&quot;分隔从而直接打印多种类型的多个变量,这样打印出来的其实是一个元组, 里面包含各种元素, 所以本质上打印的也是一个变量,一个元组变量。</div><div><br/></div><hr/><div><br/></div><div>为什么创建Scala类时有以下三种种类: </div><div>其实下面这三种都是关键字, 而不是类型, </div><div>1、class关键字类似于Java中的class关键字,用来定义一个类</div><div>2、object关键字相较于class的区别就是object定义的类里可以定义main方法, class关键字定义的类不可以</div><div>    java中Object类是所有类的父类, Scala中的object是一个关键字, 表示定义了一个带main方法的实例或者一个单例对象。</div><div>3、Trait</div><div><img src="day2-面向对象_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div><span style="font-size: unset; color: unset; font-family: unset;">变量的定义: </span></div><div><br/></div><div style="border: 0px; margin: 0px; padding: 0px; overflow-wrap: break-word; word-break: break-all; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="border: 0px; overflow-wrap: break-word; word-break: break-all; font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 2em;">Scala 访问修饰符基本和Java的一样，分别有：private，protected，public (没有默认访问修饰符)。</span></div><div style="border: 0px; margin: 0px; padding: 0px; overflow-wrap: break-word; word-break: break-all; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="border: 0px; overflow-wrap: break-word; word-break: break-all; font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 13px; color: rgb(255, 0, 0); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 2em;">如果没有指定访问修饰符，默认情况下，Scala 对象的访问级别都是 public </span></span><span style="border: 0px; overflow-wrap: break-word; word-break: break-all; font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 2em;">(java中不指定的话是默认访问修饰符)</span></div><div style="border: 0px; margin: 0px; padding: 0px; overflow-wrap: break-word; word-break: break-all; font-size: 13px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><span style="border: 0px; overflow-wrap: break-word; word-break: break-all; font-size: 13px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;Noto Sans CJK SC&quot;, &quot;WenQuanYi Micro Hei&quot;, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 2em;">Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</span></div><div style="font-size: 9.8pt;"><br/></div><div style="background-color: rgb(255, 255, 255); font-size: 9.8pt;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div style="color: rgb(8, 8, 8);">class Dog {</div><div style="color: rgb(8, 8, 8);"><div><br/></div></div><div style="color: rgb(8, 8, 8);">  // val关键字修饰, 表示能访问，不能修改, 编译后, 就相当于java中的final关键字</div><div style="color: rgb(8, 8, 8);">  // 相当于java中定义的一个private的成员变量，有getter方法，没有setter方法</div><div><font color="#080808">  </font><font color="#A600C4">val id:Int = 9527</font></div><div style="color: rgb(8, 8, 8);"><div><br/></div><div><br/></div></div><div style="color: rgb(8, 8, 8);">  // var关键字修饰, 表示能访问，也能修改。</div><div style="color: rgb(8, 8, 8);">  // 相当于java中定义的一个private?的成员变量，有getter方法，也有setter方法</div><div><span style="color: rgb(8, 8, 8);">  </span><font color="#A600C4">var age:Int = 3</font></div><div style="color: rgb(8, 8, 8);"><div><br/></div></div><div style="color: rgb(8, 8, 8);"><div><br/></div></div><div style="color: rgb(8, 8, 8);">  // private + val修饰的变量表示只能自己访问, (private关键字一般不搭配var,只搭配val)</div><div style="color: rgb(8, 8, 8);">  // 在class Dog类中，声明了一个 private 的变量:</div><div style="color: rgb(8, 8, 8);">  // 第一种情况：如果还有一个object的类型，名称和这个变量所在的类的名称不一致，则不能访问使用private修饰的变量</div><div style="color: rgb(8, 8, 8);">  // 第二种情况：如果还有一个object声明的类型，和这个变量所在的类的名称一致，那么这个private变量修饰的就能访问。实际上,</div><div style="color: rgb(8, 8, 8);">  //  经过编译后, object Dog和class Dog会编译到一个类里, 所以object和class修饰的同名类当然能相互访问其private的</div><div style="color: rgb(8, 8, 8);">  //  变量了,就像java中的private变量只能在本类中访问一样。</div><div><span style="color: rgb(8, 8, 8);">  </span><font color="#A600C4">private val nickname: String = &quot;旺财&quot;</font></div><div style="color: rgb(8, 8, 8);"><div><br/></div><div><br/></div></div><div style="color: rgb(8, 8, 8);">  // 用private[this]就是用来区分object和class修饰的同名</div><div style="color: rgb(8, 8, 8);">  // 类的, 此时object和class修饰的同名类不能再相互跨类访问private[this]修饰的变量了</div><div><span style="color: rgb(8, 8, 8);">  </span><font color="#A600C4">private[this] val name:String = &quot;小黄&quot;</font></div><div style="color: rgb(8, 8, 8);">}</div></div></div><div style="background-color: rgb(255, 255, 255); color: rgb(8, 8, 8); font-family: &quot;JetBrains Mono&quot;, monospace; font-size: 9.8pt;"></div><div><br/></div><div><br/></div><div><br/></div><div>如果有两个同名的分别用class和object修饰的类, 那么class修饰的类叫做伴生类, object修饰的类叫做伴生对象。<span style="color: rgb(166, 0, 196);">互为伴生关系的类和对象可以互相访问对方的使用private修饰的变量和方法。</span></div><div>object修饰的类里, 所有的属性、方法都默认是静态的, Scala中将所有静态的东西都放到了object修饰的类里(所以scala中没有static修饰符), class修饰的类里没有。这也是为什么main函数要在object修饰的类里。同时意味着, object修饰的类里的所有的属性以及方法都只有一份, 所以object修饰的类是单例的。更准确地说, <span style="color: rgb(166, 0, 196);">一个类既有object修饰, 也有class修饰的, 把class修饰的类叫做伴生类, 把object修饰的类叫做伴生对象; 一个类只有object修饰的, 没有class修饰的, 就把object修饰的类叫做单例类。</span></div><div><span style="color: rgb(166, 0, 196);">class访问object的变量时要用&quot;</span><span style="color: rgb(255, 0, 0);">类名</span><span style="color: rgb(166, 0, 196);">.变量名&quot;, 而object访问class的变量时要用&quot;</span><span style="color: rgb(255, 0, 0);">对象名</span><span style="color: rgb(166, 0, 196);">.变量名&quot;(</span><span style="color: rgb(255, 0, 0);">也就是说object要访问class里的东西就要先创建对象</span><span style="color: rgb(166, 0, 196);">), 因为object里的变量是静态的, 而class里的不是。</span></div><div><br/></div><div>跨文件? 跨包? 这些访问修饰符会不会有影响?</div><div><br/></div><div>如果要使用class修饰的类里的东西, 需要new,也就是如下: </div><div>    val dog:Dog = new Dog()</div><div>如果要使用object修饰的类里的东西, 是不需要new的,如下: </div><div><img src="day2-面向对象_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>直接在方法里像如下一样使用object Dog1,这其实就是定义了一个引用去引用Dog1: (由于是单例的, 最终打印true)</div><div><img src="day2-面向对象_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div>构造器: </div><div>构造器只会出现在class修饰的类中, 因为object修饰的类不用创建对象,使用new的方式创建对象就是调用构造器来创建对象, 如果直接用类名来作为一个对象, 那么得到的是伴生对象</div><div>调用某个类的构造器时, 该类里所有的语句都会执行一遍, 以此来初始化所有的成员变量(<span style="color: rgb(166, 0, 196);">注意: 该类自定义的方法和该类的内部类不会在调用构造器时立即执行, 只有在调用他们时才会执行</span>), </div><div>scala中的主构造器直接就在类名后定义, 只不过如果是无参构造, 那么可以省略&quot;()&quot;不写, 如果要带参的主构造器, 则定义类时写成:</div><div style="margin-left: 40px;">class XXX(参数1, 参数2, ...){</div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;">}</div><div>需要注意的是: 主构造器的参数可以用修饰符修饰, 比如var、val、private, 就像成员变量一样。</div><div>scala中的构造器参数会直接作为该类的一个成员变量, 可供其他类直接调用, 该成员变量的访问修饰符可以自由指定。并且构造器参数也可以赋默认值, 这样的话, 调用构造器时可以省略该参数不写(前提是有默认值的参数放在参数列表后面)。构造器的&quot;()&quot;前加一个private表示将构造器私有化, 也就是不允许<span style="color: rgb(166, 0, 196);">用主构造器</span>创建对象。</div><div><img src="day2-面向对象_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;">构造器使用举例:</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div> <font color="#A600C4"> * 一个class类, 在使用new的方式创建对象的时候，其实是调用了构造器</font></div><div><font color="#A600C4">  * 结果：这个构造器执行的时候，会执行这个类定义的&quot;{}&quot;中包含的所有能执行的代码</font></div><div>  *</div><div>  *  scala的构造器的定义，就是跟在类名定义的后面的一个（）</div><div>  *  而且这个构造器，我们把它叫做：主构造器</div><div>  *  scala中还有辅助构造器</div><div>  */</div><div>class Cat private (val salary:Double, var name:String) {</div><div>  </div><div>  var abc:Int = _</div><div><br/></div><div><font color="#A600C4">  /**</font></div><div><font color="#A600C4">    * 如果把一个类的主构造器给私有了，那么就相当于没有方式再可以构造对象了</font></div><div><font color="#A600C4">    * 所以补充了额外的两种方式：</font></div><div><font color="#A600C4">    *     1、提供辅助构造器的定义。辅助构造器用def this来定义, 辅助构造器的参数就和普通方法的参数一样, 不能使用修饰符修饰了。辅助构造器的第一行必须调用别的辅助构造器或者主构造器,不能是其他代码, 否则会报错。所以, 可以发现, 不管是哪个辅助构造器, 即使经过多次调用别的构造器,最后也必然会调用主构造器(因为创建第一个辅助构造器时的第一行代码必然会调用主构造器)。辅助构造器是用来囊括主构造器的功能, 所以辅助构造器相当于对主构造器的扩展</font></div><div><font color="#A600C4">    *     2、提供apply方法的定义</font></div><div><font color="#A600C4">    */</font></div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>  // 创建第一个辅助构造器</div><div>  def this(salary:Double, name:String, abc:Int){</div><div>      this(salary, name)<font style="color: rgb(255, 0, 0);">//用this来调用主构造器,。</font></div><div>      println(&quot;ssss&quot;)</div><div>      this.abc = abc;</div><div>  }</div><div><br/></div><div>  // 创建第二个辅助构造器</div><div>  def this(salary:Double, name:String, abc:Int, abcd:Int){</div><div>    this(salary, name, abc)</div><div>    println(&quot;ssss&quot;)</div><div>    this.abc = abc;</div><div>  }</div><div><br/></div><div><br/></div><div>  println(&quot;hello world  111&quot;)</div><div><br/></div><div>  val id:Int = {</div><div>    println(&quot;init field&quot;)</div><div>    10 + 1</div><div>  }</div><div><br/></div><div>  var age:Int = 18;</div><div>  println(&quot;hello world  222&quot;)</div><div><font color="#A600C4"><br/></font></div><div><font color="#A600C4">  //方法定义中，定义的代码逻辑， 在对象初始化(new)的时候， 是不会调用执行。 </font></div><div>  def myPrint(): Unit ={</div><div>    println(id, age)</div><div>    println(&quot;hello world  4444&quot;)</div><div>  }</div><div><br/></div><div>  myPrint() <font color="#A600C4">//虽然自定义的方法不会在new时执行, 但是对该方法的调用语句还是会执行的</font></div><div>  println(&quot;hello world  333&quot;)</div><div>}</div><div><br/></div></div><div><br/></div><hr/><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;">关于创建数组的两种方式的讨论:</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>object MainTest {</div><div>  def main(args: Array[String]): Unit = {</div><div>    /**</div><div>      * 下面的第一种方式中：</div><div>      *    在获取对象的时候，直接使用类名，没有使用new,这种方式，是直接调用<font color="#A600C4">object</font> Array构建的数组对象,而不是<font color="#A600C4">class </font>Array</div><div>      *    那么就有个矛盾：object Array是没有构造器的, 所以这个对象的定义在使用<font color="#A600C4">object</font> Array的时候，是不能在后面传入参数&quot;(1,2,3,4,5)&quot;的。</div><div>      *    问题的解决方法就是：scala还给所有的伴生对象和伴生类之间，提供了一个纽带： apply方法,就是让object Array在传入参数时, 去调用其Array.apply方法,apply方法的作用就是让object Array也能创建新对象(当然底层实际是通过class Array创建的。与apply方法对应的还有unapply方法。</div><div>           apply方法的定义是: def apply(x : Int, xs : Int*) : Array[Int] = {...}</div><div>            可以发现参数是一个Int型的x和一个Int型的可变参数xs(当然Int是由泛型的具体类型决定的),所以传入参数&quot;(1,2,3,4,5)&quot;即x = 1, xs = 2,3,4,5。</div><div><font color="#A600C4">      *    数组Array类型中的 apply 方法的逻辑：</font></div><div><font color="#A600C4">      *        1、先计算元素的个数，然后使用普通的方式，调用class object来用</font><font color="#FF0000">new</font><font color="#A600C4">构建一个对应长度的新的定长数组</font></div><div><font color="#A600C4">      *        2、然后把所有元素，分别赋值到该新数组的对应的位置上</font></div><div>      *</div><div>      */</div><div><font color="#A600C4">    //方式一 </font></div><div>    <font style="color: rgb(255, 0, 0);">val intArray: Array[Int] = Array(1,2,3,4,5)</font></div><div><br/></div><div>    <font color="#A600C4">//方式二。这种方式是标准的new调用构造器创建对象的方式, &quot;[Int]&quot;是泛型, &quot;10&quot;是构造器参数 </font></div><div>    <font color="#FF0000">val intArray2:Array[Int] = new Array[Int](10)</font></div><div>  }</div><div>}</div></div><div>ctrl+ 鼠标左键点击第一种方式的Array类, 提示下面两种跳转方式,选择apply方法就可以看到其具体实现</div><div><img src="day2-面向对象_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>apply方法的具体实现如下:</div><div><img src="day2-面向对象_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>也就是说使用new的方式去创建对象一定是直接使用class类的构造器。而不用new的方式获取对象就一定是使用了object类, 区别就是有没有带参数, 没带就是直接用别名来引用了object类, 如果带参了, 那就肯定是通过apply方法来获取对象的。所以可以认为apply方法就相当于object类的构造器。</div><div>自定义apply方法举例如下:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>  *  如果使用和java类似的效果和方式去构建对象，那么必须使用new来调用对应的构造器来构建对象</div><div>  *  但是scala提供了一种新的方式，可以不使用new也能构建对象(不这里不是指object的单例对象)</div><div>  *  那就是：apply方法</div><div>  *  scala底层提供了对应的apply方法，帮助我们去构建对象，简化构建对象的复杂度</div><div>  */</div><div>class Pig(val name:String) {</div><div>    println(&quot;调用了主构造器&quot;)</div><div>}</div><div><br/></div><div><font color="#A600C4">object Pig {</font></div><div><font color="#A600C4">  def apply(name:String):Pig = {</font></div><div><font color="#A600C4">    println(&quot;调用了apply方法  1111 &quot;)</font></div><div><font color="#A600C4">    new Pig(name)</font></div><div><font color="#A600C4">  }</font></div><div>  def apply(name:String,newName:String):Pig = {</div><div>    println(&quot;调用了apply方法   2222&quot;)</div><div>    new Pig(name)</div><div>  }</div><div>}</div><div><br/></div><div>object PigTest{</div><div>  def main(args: Array[String]): Unit = {</div><div><font color="#FF0000">    <b>//创建或者获取对象的两种方法如下:</b></font></div><div>    val pig1:Pig = new Pig(&quot;猪猪侠&quot;)</div><div><font color="#A600C4">    //下面这种方式构建对象，就相当于是调用了这个类的object中的一个apply方法</font></div><div><font color="#A600C4">    val pig3 = Pig(&quot;猪猪侠&quot;)</font></div><div><font color="#A600C4"><br/></font></div><div>    println(&quot;------------------------&quot;)</div><div>    val pig4 = Pig(&quot;猪猪侠&quot;, &quot;蜘蛛侠&quot;)</div><div><br/></div><div><font color="#FF0000">    //注意下面这种方式并不是获取对象, 只是pig2引用了object Pig而已,和pig1、pig3、pig4</font></div><div><font color="#FF0000">    //的区别就是pig1、pig3、pig4能调用到name属性, 而pig2是不行的, 因为没创建对象。</font></div><div>    val pig2 = Pig</div><div>  }</div><div>}</div><div><br/></div></div><div>上面的代码打印结果如下:</div><div><img src="day2-面向对象_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><hr/><div>将一个object的类继承App类, 那么, 不用main方法, 也可以run该类。</div><div><img src="day2-面向对象_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>因为jvm只认main方法, 那么这里的原理就是App类里有main方法, 然后再在main方法里, 将AppTest里的代码使用类似反射的方式来执行(其实是用交互式命令行的方式去执行shell命令)。下图是App类里的main方法:</div><div><img src="day2-面向对象_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><hr/><div>抽象类</div><div><span style="font-size: unset; color: unset; font-family: unset;">scala的抽象类使用和java中一样,只有一点小小的区别:</span></div><div style="margin-left: 40px;">1、在子类中覆盖抽象类的<span style="color: rgb(255, 0, 0);">抽象</span>方法时，可以不需要写 override 关键字(java中必须要),当然写了也可以。在子类中覆盖抽象类的普通方法时, 则必须使用override关键字(这点和java一样)。<span style="color: rgb(166, 0, 196);">(这点区别其实无关紧要, 全部加上override关键字就行了, 就和java一模一样了, 也便于记忆。抽象属性同理也可以不写override)</span></div><div style="margin-left: 40px;">2、<span style="color: rgb(166, 0, 196);">在scala的抽象类中除了方法可以抽象, 属性也可以有抽象的属性(也就是不对属性进行初始化)</span>,如下图。在scala的普通类里, 属性是必须要初始化的, 否则会报错,而在抽象类里则可以不初始化。而在java中, 不管是不是抽象类,属性不进行初始化的话, 编译器都会自动赋上一个默认初始值。</div><div><img src="day2-面向对象_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(166, 0, 196);">所以scala的抽象类中既可以有抽象属性, 也可以有普通属性;既可以有抽象方法, 也可以有普通方法。仅仅比java多了个抽象方法而已。</span></div><div>scala中子类继承父类使用的关键字也是extends。当然scala也可以像java一样使用匿名内部类的方式来直接定义一个匿名子类并重写实现父类的抽象方法。</div><div>java不支持多继承, 但scala可以。 </div><hr/><div><span style="font-weight: bold;">trait关键字</span></div><div>trait是<span style="color: rgb(166, 0, 196);">特质</span>的意思</div><div><br/></div><div>scala中创建类有三种方式:</div><div>    class</div><div>    object</div><div>    trait</div><div><br/></div><div>1、trait关键字首先拥有java中的interface关键字的功能, 也就是定义接口:</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">(首先要注意到, 视频课的老师在做上课资料的pdf时, 并不知道java中关于在jdk1.8时</span><span style="color: rgb(255, 0, 0); font-weight: bold;">接口</span><span style="color: rgb(255, 0, 0); font-weight: bold;">可以定义default方法的特性, 所以可能在这方面,文末的pdf可能会有些错误)</span></div><div>java中的接口里定义的属性(成员变量)都是常量,而且还必须是在定义时就进行初始化（因为被static final修饰, 如果只是被final修饰, 则可以不在定义时就初始化）,接口里的成员变量不管写不写修饰符,都是被public static final修饰的,不能用其他修饰符)。而scala中的接口中的属性就没有要求一定是常量了, 并且可以是抽象属性或非抽象属性,</div><div>java中的接口里可以有抽象方法, 还可以有default修饰的有默认实现的方法(不能直接定义普通方法), 而scala的接口中, 可以有抽象方法, 也可以直接定义普通方法。 </div><div>在java和scala中, 接口都可以有普通实现类和抽象实现类(abstract修饰的类), java和scala的抽象实现类可以不用实现接口的抽象方法(也可以实现)。scala中类实现接口用的也是extends关键字, 和继承一样。</div><div>scala中也可以有子接口继承父接口, 也是用trait关键字定义子接口, 如 trait Child extends Parent{ }</div><div>trait关键字定义的类不能有构造器(和java的接口一样), 因此trait A(i: Int){ }是不可以的</div><div>2、trait的底层就是用java中的抽象类来实现的, 因为在java中, 接口可以看做是抽象类的一种特例, 接口能有的操作, 抽象类都具备, 所以scala用java中即支持抽象的方法, 也支持非抽象的方法, 而且对属性的支持也很全面的抽象方法来实现trait, 使它不仅可以实现接口, 还有其他更强大的功能。</div><div>3、<span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">scala 不支持对类进行多继承，但是支持多重继承 trait，使用 with 关键字即可</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">因为trait其实相当于java中的接口, 所以scala其实相当于也是单继承, 多实现, 只不过继承和实现都是用extends, 多实现时scala用with相连, 而java用implement实现接口, 并用&quot;,&quot;连接多个接口</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div><font color="#A600C4">  * 其中AA1可以是抽象类，也可以是特质trait(也就是说extends关键字后面跟的可以是</font></div><div><font color="#A600C4">  * 抽象类, 也可以是特质), 但with后面跟的只能是特质，不能是抽象类。所以能使用特质就</font></div><div><font color="#A600C4">    尽量不要使用抽象类, 只有当这个组件需要定义构造器的时候, 才使用抽象类, 否则定义了</font></div><div><font color="#A600C4">    多个抽象类的话,scala中的类是继承不了多个抽象类的</font></div><div>  */</div><div>class DD1 extends AA1 with BB1 with CC1{</div><div>  override def run1(distanct: Int): Int = 1</div><div><br/></div><div>  override def run2(distanct: Int): Int = 2</div><div><br/></div><div>  override def run3(distanct: Int): Int = 3</div><div>}</div><div><br/></div><div><br/></div><div>abstract class AA1{</div><div>    def run1(distanct:Int):Int</div><div>}</div><div>trait BB1{</div><div>  def run2(distanct:Int):Int</div><div>}</div><div>trait CC1{</div><div>  def run3(distanct:Int):Int</div><div>}</div></div><div><span style="font-size: unset;"><br/></span></div><div>使用with为实例对象<span style="color: rgb(166, 0, 196);">混入</span>Trait:</div><div>有时我们可以在创建类的对象时，指定该对象混入某个 Trait，这样，就只有这个对象混入该<span style="font-size: unset; color: unset; font-family: unset;">Trait 的方法，而类的其他对象则没有</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>trait MyLogger {</div><div>  def log(msg:String){}</div><div>}</div><div>trait Logger_A <font color="#A600C4">extends MyLogger</font>{</div><div>  override def log(msg:String): Unit ={</div><div>    println(&quot;AAAAAA : &quot;+msg)</div><div>  }</div><div>}</div><div>trait Logger_B <font color="#A600C4">extends MyLogger</font>{</div><div>  override def log(msg:String): Unit ={</div><div>    println(&quot;BBBBBB : &quot;+msg)</div><div>  }</div><div>}</div><div>class Person123(val name:String) <font color="#A600C4">extends Logger_A</font>{</div><div>  def sayHello(): Unit ={</div><div>    println(&quot;Hi ,i'm name&quot;, name)</div><div><font color="#A600C4">    //该类本身没有实现log方法,而是调用了父类的log方法</font></div><div>   <font color="#A600C4"> log(&quot;sayHello is invoked!&quot;) </font></div><div>  }</div><div>}</div><div>object  MyLogger_Trait_Test{</div><div>  def main(args: Array[String]) {</div><div>    //简单的使用Person123类创建对象来调用方法, 此时log方法调用的是其父类Logger_A的方法</div><div><font color="#A600C4">    val p1=new Person123(&quot;liudehua&quot;)</font></div><div><font color="#A600C4">    p1.sayHello()</font></div><div>    //使用with Logger_B 后,Person123中使用到了Logger_B也有实现的方法时, 则会直接调用           //Logger_B中方法, 不管Logger_B是不是Person123的父类</div><div><font style="color: rgb(166, 0, 196);">    val p2=new Person123(&quot;zhangxueyou&quot;)</font> <font color="#FF0000">with</font> <font color="#A600C4">Logger_B</font></div><div><font color="#A600C4">    p2.sayHello()</font></div><div>  }</div><div>}</div></div><div>上面的代码打印结果如下:</div><div><img src="day2-面向对象_files/Image [10].png" type="image/png" data-filename="Image.png" width="323"/></div><div>上面的代码的类的架构图如下:</div><div><img src="day2-面向对象_files/混入语法.png" type="image/png" data-filename="混入语法.png" width="365"/></div><div><span style="color: rgb(166, 0, 196);">混入的作用是AOP, 即面向切面编程, 在不修改源码的基础之上, 进行代码逻辑的增强。</span>放在上面的例子中就是, 原来没有Logger_B类, 但我觉得Logger_A里的log方法的旧逻辑有些不够用了, 但Logger_A中还有些其他方法的逻辑还在使用, 那就新建一个Logger_B类, 也继承与Mylogger类, 实现log方法的新的逻辑, 让需要用新逻辑Logger_A中其他一些方法的老逻辑的新子类依然继承Logger_A类但是用with关键字使用Logger_B中的log方法。这样也不会影响原来的业务。<span style="color: rgb(166, 0, 196);">符合软件设计中的开闭原则的思想:</span> <span style="color: rgb(166, 0, 196);">对修改关闭, 对扩展开放。开闭原则是设计模式的总原则。</span></div><div><br/></div><div><br/></div><div>Scala 中支持让类继承多个 Trait 后，依次调用多个 Trait 中的同一个方法，那么对这同一个方法的调用顺序是怎么样的? 见pdf的4.3.6节的内容</div><hr/><div><span style="font-weight: bold;">模式匹配</span></div><div><span style="font-weight: bold;"><img src="day2-面向对象_files/Image [11].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="color: rgb(166, 0, 196);">match的第一个功能, 匹配值(类似于java中的switch的功能, 但有一点和java不一样, java中是如果不写break, 满足某分支后,后面的所有分支不管满不满足,都会执行, match里的case语句不写break也只会执行一个分支, 也就是说scala中的match只会执行一个分支, 相当于java中每个case都写了break语句,scala中的match每个case自带break效果): </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import java.util.Random</div><div><br/></div><div>/**</div><div>  * <font color="#A600C4">match用来匹配值,不同的值走不通的分支,相当于java中的switch的功能,比switch要强大的地方就</font></div><div><font color="#A600C4">    是java的switch只能匹配一种类型的值, 而match匹配时值可以是各种类型。</font></div><div>  */</div><div>object MatchTest1 {</div><div>  def main(args: Array[String]): Unit = {</div><div>    var array: Array[Any] = Array(1, 2.2, false, &quot;aa&quot;)</div><div>    val random = new Random()</div><div>    val index = random.nextInt(array.length)</div><div>    val value = array(index)</div><div>    println(value)</div><div><br/></div><div>    value match {</div><div>      <font color="#FF0000">case</font> 1 <font color="#FF0000">=&gt;</font> {println(&quot;结果为：1&quot;)}</div><div>      case 2.2 <font color="#FF0000">=&gt;</font> {println(&quot;结果为：2.2&quot;)}</div><div>      case false <font color="#FF0000">=&gt;</font> {println(&quot;结果为：false&quot;)}</div><div>//      case &quot;aa&quot; <font color="#FF0000">=&gt;</font> {println(&quot;结果为：aa&quot;)}</div><div>      <font color="#FF0000">//&quot;_&quot;下划线的又一种用法, 当做match里的其他情况(用处类似于java中的switch里的default)  </font></div><div>      case <font color="#FF0000">_</font> =&gt; println(&quot;见鬼了&quot;)  </div><div>    }</div><div>  }</div><div>}</div></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">match匹配值的强化, 按类型或条件来匹配值:</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import java.util.Random</div><div><br/></div><div>object MatchTest2_Type {</div><div>  def main(args: Array[String]): Unit = {</div><div>    var array: Array[Any] = Array(1, 2.2, false, &quot;aa&quot;, 3, 4, 5, 6)</div><div>    val random = new Random()</div><div>    val index = random.nextInt(array.length)</div><div>    val value = array(index)</div><div>    println(value)</div><div><br/></div><div>    <font color="#FF0000">//case后面不仅可以加常量值(或常量表达式, 还可以加变量, 这点不同于java)</font></div><div>    value match {</div><div><font color="#FF0000">      //如果是Double类型的变量, 则走这个分支, 并且还能</font></div><div><font color="#FF0000">      //取得该变量的具体值,所以取到的值会随着具体值的变化而变化 </font>     </div><div>      <font style="color: rgb(166, 0, 196);">case y:Double =&gt; println(&quot;double&quot;,y )</font></div><div><font color="#FF0000">      //甚至match匹配的目标可以只有类型没有变量, 下面这种写法也是正确的,上面那句代码带个y是</font></div><div><font><font color="#FF0000">      //为了得到匹配到的值传给该变量y,好在&quot;=&gt;&quot;推导符后面进行使用</font></font></div><div><font color="#A600C4">      //case Double =&gt; println(&quot;double&quot;)</font><font color="#A600C4">    </font></div><div><font color="#FF0000">      //match匹配的目标还可以只有变量没有类型, 这样的话该变量将默认是Any类型,这样的话</font></div><div><font color="#FF0000">      //所有类型都能匹配上这个分支了,这样的话就和&quot;case</font> <font color="#A600C4">_</font> <font color="#FF0000">=&gt; ...&quot; 差不多了, 只是多了一</font></div><div><font color="#FF0000">      //个变量给&quot;=&gt;&quot;推导符后面进行使用</font></div><div><font color="#A600C4">      //case Double =&gt; println(&quot;double&quot;) </font> </div><div><br/></div><div><font color="#FF0000">      //如果是Boolean类型的变量, 则走这个分支</font></div><div>      <font color="#A600C4">case z:Boolean =&gt; println(&quot;boolean&quot;, z)</font></div><div><font color="#FF0000">      /*</font></div><div><font color="#FF0000">case的变量后面还可以加守卫条件, 就像scala的for循环可以加守卫条件一样。需要注意守卫条件是整个函数推导式的一部分,在if语句前后不能加任何的&quot;()&quot;,它们是一个整体, 要加只能在参数列表处加&quot;()&quot;, 如下面这句代码改为case (x:Int) if x &gt; 2 =&gt; println(&quot;int &gt;= 2&quot;, x) 是可以的</font></div><div><font color="#FF0000">      */</font></div><div><font color="#A600C4">      case x:Int if x &gt; 2 =&gt; println(&quot;int &gt;= 2&quot;, x)</font></div><div>      <font color="#FF0000">/*注意下面这句代码守卫条件&quot;&lt;=&quot;是小于等于号, 不要和&quot;=&gt;&quot;搞混了。 注意, 允许case语句的范围有重合, 如上下这两句代码, 但需要注意的是,比如value为3,因为同时满足这两句case分支的条件, 但执行完上面这个case分支后, 不会再执行下面这句case分支, 也说明了scala中的match只会执行一个分支, 相当于</font><font color="#FF0000">java中每个case都写了break语句</font></div><div><font color="#FF0000">      */</font></div><div>      <font color="#A600C4">case x:Int if x &lt;= 5 =&gt; println(&quot;int&quot;, x)</font></div><div><br/></div><div>      case _ =&gt; println(&quot;str&quot;)</div><div>    }</div><div>  }</div><div>}</div></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">match除了能匹配相应类的类型外,还能匹配集合</span>。 比如匹配List时, 还能按照元素的个数来匹配, 甚至还可以指定某一位元素是特定的元素值来作为匹配条件。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import java.util.Random</div><div><br/></div><div>object MatchTest3_Collection {</div><div>  def main(args: Array[String]): Unit = {</div><div><br/></div><div><font color="#FF0000">    val list1 = 3 :: 4 :: 0 :: 5 :: Nil</font></div><div><font color="#FF0000">    val list2 = 3 :: 4 :: 5 :: Nil</font></div><div><font color="#FF0000">    val list3 = 4 :: 5 :: 3 :: 4 :: Nil</font></div><div><font color="#FF0000">    val list4 = 3 :: 4 :: 3 :: 4 :: Nil</font></div><div><br/></div><div>    val array = Array(list1, list2, list3, list4)</div><div>    val random = new Random()</div><div>    val index = random.nextInt(array.length)</div><div>    val value = array(index)</div><div>    println(value)</div><div><br/></div><div>    value match {</div><div><font color="#FF0000">      //当value是List类型,并且该List里恰好有三个元素时匹配</font></div><div>      case <font color="#FF0000">x :: y :: z :: Nil</font> =&gt; {</div><div>        println(&quot;3&quot;)</div><div>        println(x, y, z)</div><div>      }</div><div><br/></div><div>      <font color="#FF0000">//当value是List类型且</font><font color="#FF0000">该List里恰好有4个元素且该list的第一、二个元素值分别为4和5时匹配</font></div><div>      case <font color="#FF0000">4 :: 5 :: a :: b ::  Nil</font> =&gt; {</div><div>        println(&quot;4&quot;)</div><div>        println(a, b)</div><div>      }</div><div>      <font color="#FF0000">//上面的代码中的x,y,z和a,b还可以被占位符&quot;_&quot;所代替,表示任意元素均可,如下:</font></div><div>      case <font color="#FF0000">3 :: 4 :: _ :: b ::  Nil</font> =&gt; {</div><div>        println(&quot;4&quot;)</div><div>        println(b)</div><div>      }</div><div><br/></div><div>      case _ =&gt; {</div><div>        println(&quot;5&quot;)</div><div>      }</div><div>    }</div><div>  }</div><div>}</div></div><div><br/></div><div><br/></div><div>我们知道, map有三种传入key得到value的方式:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    val map = Map((&quot;a&quot;,1), (&quot;b&quot;,2), (&quot;c&quot;,3))</div><div>    val key = &quot;d&quot;</div><div><br/></div><div>    //如果key存在,直接返回对应的类型的value,如果value不存在, 会报错</div><div>    println(map(key))</div><div><br/></div><div>    //如果key存在,返回被Some类型包裹的value,如果key不存在, 返回None</div><div>    println(map.get(key))</div><div><br/></div><div>    //如果key存在,直接返回对应的类型的value,如果key不存在, 返回默认值</div><div>    println(map.getOrElse(key, 100))</div></div><div>如果要你用match和map.get(key)来实现map.getOrElse()方法, 那么实现的方法肯定是如下:</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    val value = map.get(key)</div><div>    val result = value match {</div><div>      case Some(x) =&gt; x</div><div>      case None =&gt; 100</div><div>    }</div></div><div>实际上, scala中也正是这样实现的:</div><div><img src="day2-面向对象_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div>上面说的也是match的一种用法, 实际上, Some是样例类, None是样例对象, <span style="color: rgb(166, 0, 196);">样例类和样例对象存在的目的就是用来做模式匹配的</span></div><div><img src="day2-面向对象_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(118, 0, 216);">样例类的对象经过特殊的序列化与反序列化的设计, 序列化时对象里只会包含你添加在主构造器里的那些属性, 不会携带那些有默认实现的方法, 所以序列化后的对象字节数会很少, 所以在进行网络传输时负载会比较低。如果是java的原生序列化机制, 在序列化时, 除了携带对象的属性值外, 序列化还要携带该类的定义的方法之类的所有信息, 字节数就会多很多。所以说样例类可以理解为装数据的容器, 因为样例类的对象真正拥有的东西就只有自己定义的那几个属性而已。</span></div><div><span style="color: rgb(118, 0, 216);">上上图的Some就是样例类,Some(v)是样例类的一个实例, 而None就是样例对象。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import java.util.Random</div><div><br/></div><div><font color="#A600C4">// 样例类就是用case关键字来定义的类, 样例类可以理解为一个装数据的容器对象</font></div><div><font color="#A600C4">// 样例类和普通的类有什么区别?区别就是样例类里面的各种常见的方法，都已经按照默认的方式</font></div><div><font color="#A600C4">// 帮你实现了, 比如equals toString hashCode apply ....这些方法,定义case class AAAA后,</font></div><div><font color="#A600C4">//会自动创建case object AAAA(因为apply方法是静态的,要在object里实现)。所以叫做样例类。</font></div><div><font color="#A600C4">//那么, 定义类的时候, 你只需要定义好属性就可以了, 因为scala的主构造器参数会作为属性, 所</font></div><div><font color="#A600C4">// 以样例类一般直接用主构造来定义属性, 所以样例类的定义会非常简洁, 如下:</font></div><div><font style="color: rgb(255, 0, 0);">case class AAAA(var id:Int, var age:Int)</font></div><div><br/></div><div><font color="#FF0000">case class BBBB(var name:String)</font></div><div><font color="#FF0000">case class CCCC(var salary:Double)</font></div><div><br/></div><div><font style="color: rgb(166, 0, 196);">//和普通object类一样, 如果要定义case object 类, 那么就不能带构造器参数,因为object类</font></div><div><font color="#A600C4">//是没有构造器的。</font><font color="#A600C4">case object 类叫做样例对象, 样例对象没有其他作用, 其实就是一个信号, 用来</font></div><div><font color="#A600C4">//表示某种信息或代表某种标志。样例类可以有多个不同的对象, 因为可以传给构造器不同的参数,而样</font></div><div><font color="#A600C4">//例对象由于没有构造器, 所以只有一个, 类似于单例对象</font></div><div>case object DDDD    // 信号</div><div><br/></div><div>object MatchTest_CaseClass {</div><div>  def main(args: Array[String]): Unit = {</div><div><br/></div><div><font color="#A600C4">    //因为实现了apply方法, 所以样例类默认可以通过apply方法来创建对象的, 不使用new,</font></div><div><font color="#A600C4">    //其实也可以new, 但一般样例类不推荐这种用法。使用如下:</font></div><div>    val array = Array(<font color="#FF0000">AAAA(1,18), BBBB(&quot;huangbo&quot;), CCCC(1000000),</font><font color="#7600D8"> new AAAA(2,19)</font>)</div><div>    val random = new Random()</div><div>    val index = random.nextInt(array.length)</div><div>    val value = array(index)</div><div>    println(value)</div><div><br/></div><div>    value match {</div><div>      <font color="#FF0000">//匹配AAAA样例类的对象的一种用法。这种用法和普通的类型的匹配一样。  </font></div><div><font color="#A600C4">//      case AAAA =&gt; {</font></div><div><font color="#A600C4">//        println(&quot;111&quot;)</font></div><div><font color="#A600C4">//      }  </font></div><div><font color="#FF0000">      //匹配AAAA(var id:Int, var age:Int)样例类的对象, 构造器参数可以随便用同类型的变量代替</font></div><div><font color="#FF0000">      //但要注意, 构造器的参数个数一定要对应, 否则会报错(注意:普通类(包括有apply方法的类)是 </font></div><div><font color="#FF0000">      //没有带构造器参数这一匹配用法的,普通类匹配时直接用类名匹配)。 样例类匹配时使用构造器</font></div><div><font color="#FF0000">      //参数的目的是拿到样例类的属性值,赋给变量, 以便于在&quot;=&gt;&quot;推导符后面使用</font></div><div><font color="#A600C4">      case AAAA(x,y) =&gt; {</font></div><div><font color="#A600C4">        println(x, y)</font></div><div><font color="#A600C4">      }</font></div><div><font color="#FF0000">      //当然, 也可以将构造器参数的值固定为某个特定的值进行匹配</font></div><div><font color="#A600C4">//      case AAAA(2,y) =&gt; {</font></div><div><font color="#A600C4">//        println(&quot;111&quot;,y)</font></div><div><font color="#A600C4">//      }</font></div><div><font color="#A600C4">  </font>  </div><div><font color="#A600C4">      case BBBB(name) =&gt; {</font></div><div><font color="#A600C4">        println(name)</font></div><div><font color="#A600C4">      }</font></div><div><br/></div><div><font color="#A600C4">      case CCCC(ss) =&gt; {</font></div><div><font color="#A600C4">        println(ss)</font></div><div><font color="#A600C4">      }</font></div><div>    }</div><div>  }</div><div>}</div></div><div><br/></div><div><br/></div><hr/><div>偏函数(PartialFunction)</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>object PartialFunctionTest {</div><div>  def main(args: Array[String]): Unit = {</div><div>    println(abc(&quot;c&quot;))</div><div>    println(abc1(&quot;c&quot;))</div><div>  }</div><div><br/></div><div><font color="#A600C4">  // 在定义一个偏函数的时候，要指定两个泛型</font></div><div><font color="#A600C4">  // 第一个是输入的泛型, 给case指定其后面跟的值的类型</font></div><div><font color="#A600C4">  // 第二个是输出的泛型, 指定返回值的类型</font></div><div><font color="#A600C4">  // 偏函数的方法体里，就只有一堆没有写match,只写了case 分支的代码体, 也就是说偏函数其实</font></div><div><font color="#A600C4">  //就是定义了一个方法并将模式匹配放在方法里的一种简写形式, 用模式匹配的结果作为方法的返回值。</font></div><div>  def abc:PartialFunction[<font color="#FF0000">String</font>,Int] = {</div><div>    case <font color="#FF0000">&quot;a&quot;</font> =&gt; {</div><div>      // 1000 行代码</div><div>      1</div><div>    }</div><div>    case <font color="#FF0000">&quot;b&quot;</font> =&gt; 2</div><div>    case <font color="#FF0000">_</font> =&gt; 3</div><div>  }</div><div><font color="#FF0000"><br/></font></div><div><font color="#FF0000">  //下面定义的这个abc1方法等价于上面的abc方法:  </font></div><div>  def abc1(value:String):Int = {</div><div> //&quot; val result = &quot;和方法的返回值result其实可以去掉,因为value match的&quot;{}&quot;本来就是有返回值的。</div><div>    val result = value match {</div><div>      case &quot;a&quot; =&gt; {</div><div>        // 1000 行代码</div><div>        1</div><div>      }</div><div>      case &quot;b&quot; =&gt; 2</div><div>      case _ =&gt; 3</div><div>    }</div><div>    result</div><div>  }</div><div>}</div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><a href="day2-面向对象_files/scala-part2-面向对象.pdf"><img src="day2-面向对象_files/d2757fa4e7f4b0799e0ba53a325c77c0.png" alt="scala-part2-面向对象.pdf"></a></div><div><br/></div><hr/><div><br/></div><hr/><div><br/></div><div><br/></div></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 