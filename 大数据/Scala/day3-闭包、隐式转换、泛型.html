<html>
<head>
  <title>day3-闭包、隐式转换、泛型</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="8875"/>
<h1>day3-闭包、隐式转换、泛型</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/6/28 0:35</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/7/27 21:40</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div><div>闭包:</div><div><img src="day3-闭包、隐式转换、泛型_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="day3-闭包、隐式转换、泛型_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>在函数定义的时候绑定了一个函数体外面的变量(有点像面向过程的全局变量, 或者面向对象里的属性), 在调用的时候才知道该变量的值。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>object BibaoTest {</div><div>  def main(args: Array[String]): Unit = {</div><div><font color="#A600C4">    // 如何在函数f1外部访问到result这个值？</font></div><div><font color="#EB0073">    val f1 = () =&gt; {</font></div><div><font color="#EB0073">      var result = 10</font></div><div><font color="#A8A8A8">      //用result直接作为函数返回值是一种做法, 但这种做法别的语言也能实现  </font></div><div><font color="#A8A8A8">//      result</font></div><div><font color="#A600C4">      // 在f1函数体内再定义一个函数f2,访问和操作了result这个变量，f2引</font></div><div><font color="#A600C4">      //用了result，如果f2没有死掉，那么result就一直存在</font></div><div><font color="#EB0073">      val f2 = (x:Int) =&gt; {</font></div><div><font color="#EB0073">        result += x</font> <font color="#A600C4">//在f2内部修改result的值</font></div><div><font color="#EB0073">        result</font>  //result不一定要作为f2的返回值, 这里这样做只是为了方便观察result的值的变化</div><div>      }</div><div>      <font color="#EB0073">f2</font>   <font color="#A600C4">//用f2函数来作为f1的返回值</font></div><div>    }</div><div><br/></div><div><font color="#A600C4">    // resultFunction就是 f1体中的f2。我们通过在函数f1体内再定义了一个函</font></div><div><font color="#A600C4">    //数f2, 达到了在函数f1外部, 操作f1函数里面的一个局部变量的目的。</font></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    val resultFunction = f1()</div><div><br/></div><div><font color="#A600C4">    /** resultFunction就能直接访问和修改 f1 这个函数中的一个局部变量了。</font></div><div><font color="#A600C4">        下面就是对result的修改。因为result和f2都是f1的成员, 所以只要f1函数还没释放,</font></div><div><font color="#A600C4">        result和f2就一直存在不会释放。所以result的值的每次变化都会被保存。</font><font color="#FF0000">这样也有一个</font></div><div><font color="#FF0000">        坏处, 就是只要f1被调用了一次, 只要用户不主动释放, 程序运行时result就会永远存在,</font></div><div><font color="#FF0000">        消耗内存空间。这就是闭包的弊端, 所以闭包要谨慎使用。</font></div><div><font color="#A600C4">      */</font></div><div><font color="#EB0073">    val lastResult1 = resultFunction(4) //4就是f2函数的参数x</font></div><div><font color="#EB0073">    println(lastResult1) //14</font></div><div><font color="#A600C4"><br/></font></div><div><font color="#EB0073">    val lastResult2 = resultFunction(4)</font></div><div><font color="#EB0073">    println(lastResult2) //18</font></div><div><font color="#A600C4"><br/></font></div><div><font color="#EB0073">    val lastResult3 = resultFunction(4)</font></div><div><font color="#EB0073">    println(lastResult3) //22</font></div><div>  }</div><div>}</div></div><div>闭包就是根据高阶函数来实现的。也就是在函数体f1的内部，编写一个新的函数f2， f2 用来操作 result这个变量, <span style="font-size: unset; color: unset; font-family: unset;">f2这个函数，必须作为f1这个函数的返回值。闭包也是有函数式编程的语言的特性。</span> <span style="color: rgb(255, 0, 0);">闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</span></div><div><br/></div><hr/><div>隐式转换:</div><div>在scala中有一个奇怪的现象:</div><div>        1 to 10  ==  1.to(10)</div><div>        Int类型中，压根就没有to方法，但是 1.to(10) 这句代码居然能成功！！！</div><div>        那必然存在着一种很有意思的语法。来帮我们解决了这个异常</div><div>实际上:</div><div style="margin-left: 40px;">当调用了：1 to 10</div><div style="margin-left: 40px;">其实是调用了：1.to(10)</div><div style="margin-left: 40px;">但是：Int 中没有 to 方法</div><div style="margin-left: 40px;">所以：去寻找引入的隐式转换中有没有能把 Int 类型转换成能执行 to 方法的类型</div><div style="margin-left: 40px;">果然：在系统引入的转换中发现：implicit def intWrapper(x: Int): runtime.<span style="color: rgb(255, 0, 0);">RichInt</span></div><div style="margin-left: 40px;">    (intWrapper是Int的包装类)</div><div style="margin-left: 40px;">所以：<span style="color: rgb(166, 0, 196);">最终 Int 类型的 1 就被转换成了 RichInt 类型的变量 1</span></div><div style="margin-left: 40px;">验证：RichInt 中也确实存在 to 方法</div><div style="margin-left: 40px;">最后：顺理成章的调用 RichInt(1).to(10)生成返回结果</div><div style="margin-left: 40px;">结论：神奇但又合理</div><div>RichInt里面的until和to方法如下:</div><div><img src="day3-闭包、隐式转换、泛型_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>scala中系统自带的隐式转换共69个, 如下(可以发现隐式转换大部分都是一种方法, 还要少量是隐式转换类?):</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>scala&gt; <font color="#A600C4">:implicits -v</font></div><div>/* 69 implicit members imported from scala.Predef */</div><div>  /* 7 inherited from scala */</div><div>  final implicit class ArrayCharSequence extends CharSequence</div><div>  final implicit class ArrowAssoc[A] extends AnyVal</div><div>  final implicit class Ensuring[A] extends AnyVal</div><div>  final implicit class RichException extends AnyVal</div><div>  final implicit class SeqCharSequence extends CharSequence</div><div>  final implicit class StringFormat[A] extends AnyVal</div><div>  final implicit class any2stringadd[A] extends AnyVal</div><div><br/></div><div><br/></div><div>  /* 40 inherited from scala.Predef */</div><div>  implicit def ArrowAssoc[A](self: A): ArrowAssoc[A]</div><div>  implicit def Ensuring[A](self: A): Ensuring[A]</div><div>  implicit def StringFormat[A](self: A): StringFormat[A]</div><div>  implicit def any2stringadd[A](self: A): any2stringadd[A]</div><div><br/></div><div><br/></div><div>  implicit def booleanArrayOps(xs: Array[Boolean]): mutable.ArrayOps[Boolean]</div><div>  implicit def byteArrayOps(xs: Array[Byte]): mutable.ArrayOps[Byte]</div><div>  implicit def charArrayOps(xs: Array[Char]): mutable.ArrayOps[Char]</div><div>  implicit def doubleArrayOps(xs: Array[Double]): mutable.ArrayOps[Double]</div><div>  implicit def floatArrayOps(xs: Array[Float]): mutable.ArrayOps[Float]</div><div>  implicit def genericArrayOps[T](xs: Array[T]): mutable.ArrayOps[T]</div><div>  implicit def intArrayOps(xs: Array[Int]): mutable.ArrayOps[Int]</div><div>  implicit def longArrayOps(xs: Array[Long]): mutable.ArrayOps[Long]</div><div>  implicit def refArrayOps[T &lt;: AnyRef](xs: Array[T]): mutable.ArrayOps[T]</div><div>  implicit def shortArrayOps(xs: Array[Short]): mutable.ArrayOps[Short]</div><div>  implicit def unitArrayOps(xs: Array[Unit]): mutable.ArrayOps[Unit]</div><div><br/></div><div><br/></div><div>  implicit def $conforms[A]: &lt;:&lt;[A,A]</div><div>  implicit def ArrayCharSequence(__arrayOfChars: Array[Char]): ArrayCharSequence</div><div>  implicit def Boolean2boolean(x: Boolean): Boolean</div><div>  implicit def Byte2byte(x: Byte): Byte</div><div>  implicit def Character2char(x: Character): Char</div><div>  implicit def Double2double(x: Double): Double</div><div>  implicit def Float2float(x: Float): Float</div><div>  implicit def Integer2int(x: Integer): Int</div><div>  implicit def Long2long(x: Long): Long</div><div>  implicit def RichException(self: Throwable): RichException</div><div>  implicit def SeqCharSequence(__sequenceOfChars: IndexedSeq[Char]): SeqCharSequence</div><div>  implicit def Short2short(x: Short): Short</div><div>  implicit val StringCanBuildFrom: generic.CanBuildFrom[String,Char,String]</div><div>  implicit def augmentString(x: String): immutable.StringOps</div><div>  implicit def boolean2Boolean(x: Boolean): Boolean</div><div>  implicit def byte2Byte(x: Byte): Byte</div><div>  implicit def char2Character(x: Char): Character</div><div>  implicit def double2Double(x: Double): Double</div><div>  implicit def float2Float(x: Float): Float</div><div>  implicit def int2Integer(x: Int): Integer</div><div>  implicit def long2Long(x: Long): Long</div><div>  implicit def short2Short(x: Short): Short</div><div>  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2)): runtime.Tuple2Zipped.Ops[T1,T2]</div><div>  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3)): runtime.Tuple3Zipped.Ops[T1,T2,T3]</div><div>  implicit def unaugmentString(x: immutable.StringOps): String</div><div><br/></div><div><br/></div><div>  /* 22 inherited from scala.LowPriorityImplicits */</div><div>  implicit def genericWrapArray[T](xs: Array[T]): mutable.WrappedArray[T]</div><div>  implicit def wrapBooleanArray(xs: Array[Boolean]): mutable.WrappedArray[Boolean]</div><div>  implicit def wrapByteArray(xs: Array[Byte]): mutable.WrappedArray[Byte]</div><div>  implicit def wrapCharArray(xs: Array[Char]): mutable.WrappedArray[Char]</div><div>  implicit def wrapDoubleArray(xs: Array[Double]): mutable.WrappedArray[Double]</div><div>  implicit def wrapFloatArray(xs: Array[Float]): mutable.WrappedArray[Float]</div><div>  implicit def wrapIntArray(xs: Array[Int]): mutable.WrappedArray[Int]</div><div>  implicit def wrapLongArray(xs: Array[Long]): mutable.WrappedArray[Long]</div><div>  implicit def wrapRefArray[T &lt;: AnyRef](xs: Array[T]): mutable.WrappedArray[T]</div><div>  implicit def wrapShortArray(xs: Array[Short]): mutable.WrappedArray[Short]</div><div>  implicit def wrapUnitArray(xs: Array[Unit]): mutable.WrappedArray[Unit]</div><div><br/></div><div><br/></div><div>  implicit def booleanWrapper(x: Boolean): runtime.RichBoolean</div><div>  implicit def byteWrapper(x: Byte): runtime.RichByte</div><div>  implicit def charWrapper(c: Char): runtime.RichChar</div><div>  implicit def doubleWrapper(x: Double): runtime.RichDouble</div><div>  implicit def fallbackStringCanBuildFrom[T]: generic.CanBuildFrom[String,T,immutable.IndexedSeq[T]]</div><div>  implicit def floatWrapper(x: Float): runtime.RichFloat</div><div><font color="#FF0000">  implicit def intWrapper(x: Int): runtime.RichInt</font></div><div>  implicit def longWrapper(x: Long): runtime.RichLong</div><div>  implicit def shortWrapper(x: Short): runtime.RichShort</div><div>  implicit def unwrapString(ws: immutable.WrappedString): String</div><div>  implicit def wrapString(s: String): immutable.WrappedString</div><div><br/></div></div><div><br/></div><div>另一个隐式转换的例子: (即使参数个数和定义的隐式方法不一样, 也能成功)  </div><div><img src="day3-闭包、隐式转换、泛型_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>隐式转换在什么时候发生?在系统即将产生异常的时候, 隐式转换的各类表达式会尝试触发隐式转换修复该异常, 让该异常消失。也可以说隐式转换发生在类型不匹配的时候。</div><div><br/></div><div>到底有哪些情况可以触发隐式转换?</div><div>总的来说就是：当类型不匹配的情况下会尝试触发隐式转换。分为下面三种情况:</div><div>    1、当调用某个对象不存在的方法的时候</div><div><span style="font-size: 10pt;">        &quot;1.to(10)&quot;或者&quot;1 to 10&quot;就是典型的调用了Int对象不存在的方法。</span><span style="font-size: 10pt; color: unset; font-family: unset;">1隐式转换为了 RichInt(1)</span></div><div>    2、当参数类型不匹配的时候。比如上图的<span style="font-size: unset; color: unset; font-family: unset;">f1(2,3.0)</span></div><div>    3、泛型中存在视图边界的时候</div><div><br/></div><div>第一种情况举例如下: (下面这个例子展现了如何使用隐式转换来调用某个对象不存在的方法)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>import java.io.File</div><div>import scala.io.Source</div><div><br/></div><div><br/></div><div>object ReadFileAllContentTest {</div><div>  def main(args: Array[String]): Unit = {</div><div><font color="#A600C4">    // 首先构建一个文件类</font></div><div>    val file: File = new File(&quot;D:\\testdata\\wc\\input\\wc.txt&quot;)</div><div><br/></div><div><font color="#797979">    // 下面这句代码是为了让隐式转换生效, 在定义了隐式转换方法后再使用它。</font></div><div><font color="#797979">    //当然,如果file2RichFile方法定义在本类里, 则可以不用下面这句代码了</font></div><div><font color="#797979">    import RichFileImplicit.file2RichFile</font></div><div><br/></div><div>   <font color="#A600C4"> /**</font></div><div><font color="#A600C4">      * 在没有隐式转换前, 这句代码在正常情况下是会报错的。原因是：</font></div><div><font color="#A600C4">      *   调用了file对象不存在的方法：readAllContent(一次性读取完整这个文件中的所有内容，成为一个字符串的结果)</font></div><div><font color="#A600C4">      *</font></div><div><font color="#A600C4">      * 请利用隐式转换 帮我解决这个问题:</font></div><div><font color="#A600C4">      *   首先 : 1.to(10)中, Int 没有 to 方法, 而RichInt 有 to 方法, 通过隐式转换来调用</font></div><div><font color="#A600C4">      *   同样的, File没有readAllContent方法,要实现隐式转换,使得这里不报错, 可以定义一个类RichFile5555来实现readAllContent方法。步骤如下: </font></div><div><font color="#A600C4">            第一步：定义一个类RichFile5555，具备readAllContent方法</font></div><div><font color="#A600C4">            第二步: 定义一个隐式转换, 让File类在方法不匹配的时候尝试隐式转换为RichFile5555</font></div><div><font color="#A600C4">      */</font></div><div>     <b><font color="#FF0000">val allContent:String = file.readAllContent()</font></b></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">         println(</span>allContent)</div><div>  }</div><div>}</div><div><br/></div><div><br/></div><div>object RichFileImplicit{</div><div><font color="#A600C4">  // 定义一个隐式转换</font><font color="#FF0000">方法</font><font color="#A600C4">，让File类的对象，有机会转换成RichFile5555的对象</font></div><div>  <b><font style="color: rgb(255, 0, 0);">implicit def file2RichFile(file:File):RichFile5555 = new RichFile5555(file)</font></b></div><div>}</div><div><br/></div><div>/**</div><div>  * <font color="#A600C4">这个类有一个readAllContent方法，具备了一个能力：一次性读取整个文件的所有内容</font></div><div>  */</div><div>class <font color="#FF0000">RichFile5555</font>(var file:File){</div><div>  def <font color="#FF0000">readAllContent()</font>:String = {</div><div>    val result: String = Source.fromFile(file).mkString</div><div>    result</div><div>  }</div><div>}</div></div><div style="font-size: 9.8pt;"><br/></div><div>第二种情况举例如下(<span style="color: rgb(166, 0, 196);">可以发现定义隐式转换方法的形式和第一种情况一样,都是用隐式转换方法进行对象的转换, 只是用法不同</span>):</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>class People(var id:Int, var name:String)</div><div>class Dog(var id:Int, var name:String)</div><div><br/></div><div>object ImiplicitTest2 {</div><div>  def main(args: Array[String]): Unit = {</div><div><br/></div><div>    val p1 = new <font color="#FF0000">People</font>(1, &quot;huangbo&quot;)</div><div>    val p2 = new <font color="#FF0000">People</font>(2, &quot;xuzheng&quot;)</div><div>    makeFriend(p1, p2)  //这里必然是可以正常使用的</div><div><br/></div><div><br/></div><div>    val tangbohu = new <font color="#FF0000">People</font>(9527, &quot;唐伯虎&quot;)</div><div>    val wangcai = new <font color="#FF0000">Dog</font>(1111, &quot;旺财&quot;)</div><div>    <font color="#A600C4">// 这个隐式转换的作用就是,当Dog类型的对象不匹配时, 当做People来处理</font></div><div>    <b><font color="#FF0000">implicit def dog2People(dog:Dog):People = new People(dog.id, dog.name)</font></b></div><div>    /**</div><div>      * <font color="#A600C4">有了隐式转换后, makeFriend里面的参数也能是Dog类型的了。</font></div><div>      */</div><div>    <font color="#FF0000"><b>makeFriend(tangbohu, wangcai)</b></font></div><div>  }</div><div><br/></div><div>  // 交朋友的方法</div><div>  def <font color="#FF0000">makeFriend</font>(p1:<font color="#FF0000">People</font>, p2:<font color="#FF0000">People</font>): Unit ={</div><div>      println(p1.name , &quot;make friend with &quot;, p2.name)</div><div>  }</div><div>}</div></div><div><br/></div><hr/><div><span style="font-size: unset; color: unset; font-family: unset;">    java代码当中的import代码段, </span><span style="font-size: unset; color: unset; font-family: unset;">我们不需要import java.lang.* 却能使用到String等类, 就是因为java已经默认引用了这个包：</span></div><div>    scala当中也一样, 默认 import scala.Predef._   这里是下划线的另一个作用, scala中的&quot;._&quot;等价于java中的&quot;.*&quot;。</div><div> </div><div><br/></div><hr/><div><span style="font-weight: bold;">泛型:</span></div><div>scala中的泛型定义和使用的常用形式如下(java中的类型参数是用&quot;&lt;&gt;&quot;包裹的, 而scala中的类型参数则是用&quot;[]&quot;包裹):</div><div>因为小括号里面是构造器,构造器的参数当然可以使用类型参数,  更何况scala构造器的参数同时还是属性</div><div><img src="day3-闭包、隐式转换、泛型_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><img src="day3-闭包、隐式转换、泛型_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>泛型类和泛型方法: </div><div><img src="day3-闭包、隐式转换、泛型_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(166, 0, 196);">scala中的泛型指定上下界(类型界定)的形式和Java不同。在类型界定中, scala中的&quot;&lt;:&quot;等价于java中的extends, &quot;&gt;:&quot;等价于java中的super。而scala中还有&quot;&lt;%&quot;和&quot;&gt;%&quot;符号, 表示视图界定。</span></div><div>上图中, 因为只有实现(在scala中也可能是继承)了Comparable接口, 才会有compareTo方法, 所以这里的类型界定是这样的。其中, String是Comparable的实现类, Int不是, Int是值类型, 是AnyVal的子类。泛型类和泛型方法的使用如下:</div><div><img src="day3-闭包、隐式转换、泛型_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><img src="day3-闭包、隐式转换、泛型_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">视图界定</span><span style="color: rgb(166, 0, 196);">的</span> <span style="color: rgb(166, 0, 196);">原理是通过隐</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">式转换</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">来实现的, </span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">意思就是, </span><span style="color: rgb(166, 0, 196);"> 如果某类型不满足泛型的类型界定的约束范围, 但是该类型能通过隐式转换变成其他类型, 此时隐式转换后的类在该类型界定的范围内, 则依然是允许的, 依然被认为满足视图界定。</span>比如: 利用&lt;%符号对泛型T进行限定，它的意思是T可以是 Comparable 类继承层次结构中实现了<span style="font-size: unset; font-family: unset;">Comparable 接口的类，也可以是能够经过隐式转换得到的实现了 Comparable 接口的类。</span></div><div><img src="day3-闭包、隐式转换、泛型_files/Image [9].png" type="image/png" data-filename="Image.png" width="601"/></div><div><br/></div><div>下图中的Int就不是Comparable的子类, 所以直接按照原先的MrRight1的定义执行的话, 会报错。</div><div><img src="day3-闭包、隐式转换、泛型_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div>而如果将MrRight1的定义改为如下, 则能正常执行了。 <span style="color: rgb(166, 0, 196);">因为 Int 类型此时会隐式转换为 RichInt 类，而</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">RichInt 类属于 Comparable 继承层次结构。 Int 类会隐式转换成 RichInt 类， RichInt 并不是直</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">接实现 Comparable 口，而是通ScalaNumberProxy 类将 Comparable 中的方法继承过来。</span></div><div><img src="day3-闭包、隐式转换、泛型_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>学了隐式转换和泛型再回过头来看一些方法的定义。比如下面这个flatMap的定义, 首先, String是根据array里的元素来的, GenTraversableOnce是集合类的最顶级父类Traversable的一个子类, B就是该集合要使用的返回值类型, 也就是说处理完array变成一个集合后, 要不要吧集合里的元素转换为其他类型, 还是保留数组原先的类型。而That就是后面一个<span style="color: rgb(166, 0, 196);">隐式参数</span>的泛型。</div><div><img src="day3-闭包、隐式转换、泛型_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><hr/><div><span style="font-weight: bold;">协变和逆变</span></div><div><span style="color: rgb(166, 0, 196);">协变</span>的定义形式是 class A[+T]{} 或者 trait A[+T]{}, 其实也就是在泛型类的类型参数前面加了一个&quot;+&quot;</div><div><span style="color: rgb(166, 0, 196);">逆变</span>的定义形式是 class A[-T]{} 或者 trait A[-T]{}, 其实也就是在泛型类的类型参数前面加了一个&quot;-&quot;</div><div>同时也要注意, 原先的普通泛型的定义形式, 即class A[T]{} 或者 trait A[T]{}, 这种没有&quot;+&quot;和&quot;-&quot;的, 叫做<span style="color: rgb(166, 0, 196);">不变。</span></div><div>也就是说有一个<span style="color: rgb(166, 0, 196);">泛型类</span>如果定义成 trait CC[+T], 并且有两个类A和B, A是B的父类, 那么就<span style="color: rgb(166, 0, 196);">会有CC[A]是CC[B]</span>的父类,这就是协变。</div><div>同理, 如果有一个<span style="color: rgb(166, 0, 196);">泛型类</span>定义成 trait CC[-T], 并且有两个类A和B, A是B的父类, 那么就会有<span style="color: rgb(166, 0, 196);">CC[B]是CC[A]的父类</span>,这就是逆变。</div><div>协变和逆变其实就是一种规定, 方向相同就是协变, 方向不同就是逆变。</div><div>协变和逆变是出现在泛型类中的一组概念。就是为了明确参数化类型(如CC[Int]这样的就叫参数化类型)之间的父子关系。在java中, 参数化类型之间是没有任何关系的, 即使是实际类型参数之间有继承关系的参数化类型之间也没有任何关系。在Java中,<span style="color: rgb(166, 0, 196);">参数化类型</span><span style="font-size: unset; color: unset; font-family: unset;">不具备可继承性。比如如果有一个泛型类CC[T], 则CC</span><span style="font-size: unset; color: unset; font-family: unset;">&lt;String&gt;一定不是CC</span><span style="font-size: unset; color: unset; font-family: unset;">&lt;Object&gt;的子类。</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">scala中的不变就和java的参数化类型一样, 参数化类型之间没有任何关系。 </span></span></div><div><span style="font-size: unset;"><br/></span></div><div>下面进行测试, 测试方法是, 将子类对象赋给父类引用, 如果他们之间有继承关系, 则这样赋值不会报错, 否则报错。</div><div>首先是在java中:</div><div><img src="day3-闭包、隐式转换、泛型_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>在scala中(协变): </div><div><img src="day3-闭包、隐式转换、泛型_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>同上图的例子, 在scala中(逆变): </div><div><img src="day3-闭包、隐式转换、泛型_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">同上图的例子,</span><span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span>在scala中(不变): </div><div><img src="day3-闭包、隐式转换、泛型_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>协变逆变深入理解: (具体看附件pdf)</div><div><img src="day3-闭包、隐式转换、泛型_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><hr/><div><br/></div><div><br/></div><div><br/></div><hr/><div><a href="day3-闭包、隐式转换、泛型_files/scala-part3-高级特性.pdf"><img src="day3-闭包、隐式转换、泛型_files/a21ad3b86132d69da1ead6981ae78474.png" alt="scala-part3-高级特性.pdf"></a></div><div><br/></div></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 