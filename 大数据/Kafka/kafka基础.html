<html>
<head>
  <title>kafka基础</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="9091"/>
<h1>kafka基础</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/8/21 15:00</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/8/31 16:18</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><div>消息的共享  有哪些方式？  </div><div><br/></div><div><span style="color: rgb(255, 0, 0);">1、内存共享</span>   (如在同一台主机上的消息共享)</div><div>    内存共享时, 要特别注意数据的一致性问题, 尤其是分布式场景下</div><div>    在分布式场景中，就是用zookeeper来解决数据的一致性问题的, zookeeper就是公告栏, <span style="font-size: unset; color: unset; font-family: unset;">hbase  hive  hdfs  就是一个实例</span></div><div><br/></div><div>    zookeeper  解决这个数据一致性的思路：  NW思路</div><div>    <span style="color: rgb(166, 0, 196);">写数据</span>时, 最少写成功多少份?节点数的一半以上！才算成功。(没写成功的先将他们剔除服务范围?等他们写成功了或者有响应了才继续服务?)</div><div>    <span style="color: rgb(166, 0, 196);">读数据</span>时, 如果是原先的方法, 要保证访问的数据为最新的数据, 那么需要访问至少半数节点！后来zookeeper有一<span style="font-size: unset; color: unset; font-family: unset;">改进：查询，读取数据, 只需要读取一个节点即可！！  如果某个节点同步数据不成功，那么leader就把它剔除服务范围。也就是说所有正在服务的节点的数据都是最新的。</span></div><div>    从这可以体现zookeeper的生命力非常的强  没有单点故障问题(可以存在多点故障)，宕机部分节点也可以运行：不超过半数即可！</div><div><br/></div><div>    基于消息传递的一个paxos算法！！！</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">2、消息传递</span>  如一台主机把一条消息发送给另一台主机</div><div><br/></div><div>    消息传递的方式有哪些？<span style="font-size: unset; color: unset; font-family: unset;">主动送还和自己来取</span></div><div><br/></div><div>    hadoop02  ------&gt;   hadoop05</div><div>        hadoop02主动发送数据给hadoop05       send (push)</div><div>        hadoop05自己到hadoop02上进行拉取     fetch (pull)</div><div><br/></div><div>    消息队列：</div><div>        BlockingQueue  </div><div>    两队方法：</div><div>        阻塞的方法：put  take    死等</div><div>        非阻塞方法：add  poll   等待的时候干别的事</div><hr/><div>kafka</div><div><br/></div><div><img src="kafka基础_files/Image.png" type="image/png" data-filename="Image.png" width="1061"/></div><div>kafka中的几种角色:</div><div><span style="color: rgb(255, 0, 0);">producer</span>: 生产者</div><div><span style="color: rgb(255, 0, 0);">consumer</span>: 消费者</div><div><span style="color: rgb(255, 0, 0);">broker</span>: 集群中的一个节点</div><div><span style="color: rgb(255, 0, 0);">topic</span> : 主题。一种类型的消息。 例如 page view 日志、 click 日志等不同的日志可以不同的 topic<span style="font-size: unset; color: unset; font-family: unset;">的形式存在。</span></div><div><span style="color: rgb(255, 0, 0);">Partition</span>: 分区。 一个主题可以有多个分区, 这些分区可以分布在不同的broker。一个partition是一个<span style="color: rgb(166, 0, 196);">文件夹</span>, 里面有多个log文件(log文件一般也不会放在一个文件里存储所有log)</div><div><span style="color: rgb(255, 0, 0);">consumer group</span> : 消费者组。给消费者分组, 一个组里有多个消费者。一个topic可以有不同的消费者组去消费, 但是相同组里的消费者不会消费同一个topic的消息。</div><div>        <img src="kafka基础_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(255, 0, 0);">segment</span>: 一个segment其实就是一个partition里的一个log文件。其实就是将一个partition分成一段一段的, 每一段就是一个segment, 类似于jdk 1.7中的 ConcurrentHashMap中的segment。</div><div><br/></div><div>zookeeper会管理每个broker(集群节点), 同时还会管理所有的consumer。</div><div>kafka在集群里运行的时候会在每个节点运行一个守护进程, 这个守护进程就叫做kafka。</div><div><br/></div><div><img src="kafka基础_files/Image [2].png" type="image/png" data-filename="Image.png" width="1061"/></div><div><br/></div><div><img src="kafka基础_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>如果想提高并发读写的能力, 可以提高分区数,  kafka的分区是随时可以调的, kafka的每个分区都有对应的冗余数， 默认是1， 每个分区如果有多个副本</div><div>那么这些副本中，其中会有一个是 active的状态。负责读写</div><div>其他的都是standby的状态</div><div><br/></div><div>HDFS的block 和kafka的partition 对于不同的文件或者topic来说，都可以有不同的副本数, 也就是说可以单独指定某文件要存储多少份副本, 不是都一定是相同的副本数</div><div>kafka的partition设置的副本数不能超过broker的数量, hdfs里的block也一样, 设置超过了集群节点的数量的话, 最多也只会每个节点保存一份, 不可能有某个节点保存两份。</div><div><br/></div><div><br/></div><div>怎么让所有的消费者都只消费某个topic当中的一部分数据？   </div><div><span>   将所有消费者</span>放置在同一个CG中, 并且订阅这个topic。！！ (<span style="color: rgb(0, 0, 0); font-family: 微软雅黑; font-size: medium; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;">组播)</span></div><div>怎么让所有的消费者都消费某个topic当中的所有数据？</div><div>     所有的C(consumer)都作为一个独立的CG, 并且订阅这个topic。  (广播)</div><div><br/></div><div>为什么要consumer要分组(consumer group 为啥要存在)?</div><div><span>    </span>如果一个consumer对于任何一个topic都只启动一个实例(线程)，就能完整消费。那么就没有必要出现组的概念, 正是因为在分布式的环境下, <span style="color: unset; font-family: unset; font-size: unset;">一个cosumer在消费的时候，可能力不能及，所以需要启动多个实例, 所以有了consumer group 和组里的多个consumer。如果启动了多个实例，那么每个实例必然都只是</span><span style="color: unset; font-family: unset; font-size: unset;">消费这个topic中的一部分数据, 所以topic分了区(partition)。</span></div><div>消费的任务： 原来就是一个consumer消费topic,但是现在是一个组，这个组中会有一堆consumer一起消费同一个topic。</div><div><br/></div><div><br/></div><div>熟习了部门的业务、熟悉了git等工具的使用</div><div>解决LeetCode编程题50多道</div><div>实习期间主要完成DT框架重构:</div><div style="margin-left: 40px;">1、库切换, 将32位依赖库切换为64位。具体的做法是由32位依赖库去cmc上找同名的64位依赖库进行替换。</div><div style="margin-left: 40px;">2、修改CMakeLists编译链接参数, 重新整理规划CMake编译的组织。</div><div style="margin-left: 40px;">3、解决用例+主机侧代码编译问题。</div><div style="margin-left: 40px;">    主要是通过编译是出现的变量未定义和重复定义等报错信息来解决。</div><div style="margin-left: 40px;">        未定义解决方案:比如将用例会使用到但没编译的主机侧或当前llt目录下的模块包含进来。</div><div style="margin-left: 40px;">        重复定义解决方案:判断冲突原因并删除不合理或无效定义。</div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;">4、调试用例。解决调试问题, 寻找与测试用例预期结果不一致的原因。比如:</div><div style="margin-left: 40px;">    (1)是测试的模块的驱动未加载、未初始化, 还是测试用例本身的问题导致运行了错误的代码分支(如多个测试文件都使用了同一些全局变量后未重置其值, 导致单个测试文件能跑通, 多个测试文件一起跑出现问题)。</div><div style="margin-left: 40px;">    (2)32位切64位的特有的地址填充问题解决。</div><div> </div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 