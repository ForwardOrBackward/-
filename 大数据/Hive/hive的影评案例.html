<html>
<head>
  <title>hive的影评案例</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="6305"/>
<h1>hive的影评案例</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/8/24 9:47</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2020/8/27 10:24</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>现有如此三份数据：</div><div>1、users.dat    数据格式为：  2::M::56::16::70072</div><div>对应字段为：UserID BigInt, Gender String, Age Int, Occupation String, Zipcode String</div><div>对应字段中文解释：用户id，性别，年龄，职业，邮政编码</div><div><br/></div><div>2、movies.dat          数据格式为： 2::Jumanji (1995)::Adventure|Children's|Fantasy</div><div>对应字段为：MovieID BigInt, Title String, Genres String</div><div>对应字段中文解释：电影ID，电影名字，电影类型</div><div><br/></div><div>3、ratings.dat          数据格式为：  1::1193::5::978300760</div><div>对应字段为：UserID BigInt, MovieID BigInt, Rating Double, Timestamped String</div><div>对应字段中文解释：用户ID，电影ID，评分，评分时间戳</div><div><br/></div><div>题目要求：</div><div><br/></div><div>数据要求：</div><div>（1）写shell脚本清洗数据。（hive不支持解析多字节的分隔符，也就是说hive只能解析':', 不支持解析'::'，所以用普通方式建表来使用是行不通的，要求对数据做一次简单清洗）</div><div>（2）使用Hive能解析的方式进行</div><div><br/></div><div>Hive要求：</div><div>（1）正确建表，导入数据（三张表，三份数据），并验证是否正确</div><div><br/></div><div>drop table if exists users;</div><div>create table users(UserID BigInt, sex String, Age Int, Occupation String, Zipcode String)</div><div>row format serde 'org.apache.hadoop.hive.serde2.RegexSerDe'</div><div>with serdeproperties('input.regex'='(.*)::(.*)::(.*)::(.*)::(.*)','output.format.string'='%1$s %2$s %3$s %4$s %5$s')</div><div>stored as textfile;</div><div>load data local inpath '/home/hadoop/moviedata/users.dat' INTO TABLE users;</div><div>select * from users limit 5;</div><div><br/></div><div>drop table if exists movies;</div><div>create table movies(MovieID BigInt, Title String, type String)</div><div>row format serde 'org.apache.hadoop.hive.serde2.RegexSerDe'</div><div>with serdeproperties('input.regex'='(.*)::(.*)::(.*)','output.format.string'='%1$s %2$s %3$s')</div><div>stored as textfile;</div><div>load data local inpath '/home/hadoop/moviedata/movies.dat' INTO TABLE movies;</div><div>select * from movies limit 5;</div><div><br/></div><div>drop table if exists ratings;</div><div>create table ratings(UserID BigInt, MovieID BigInt, rate Double, ts String)</div><div>row format serde 'org.apache.hadoop.hive.serde2.RegexSerDe'</div><div>with serdeproperties('input.regex'='(.*)::(.*)::(.*)::(.*)','output.format.string'='%1$s %2$s %3$s %4$s')</div><div>stored as textfile;</div><div>load data local inpath '/home/hadoop/moviedata/ratings.dat' INTO TABLE ratings;</div><div>select * from ratings limit 5;</div><div><br/></div><div><br/></div><div><br/></div><div>（2）求被评分次数最多的10部电影，并给出评分次数（电影名，评分次数）</div><div><br/></div><div>思路：</div><div><br/></div><div>1、统计出电影的评分次数，要去ratings表统计 </div><div>     ratings有四个字段：  userid, movieid, ts, rate</div><div>     按照movieid分组（但是title字段和movieid也是一对一的，所以也可以按照title分组）</div><div>     按照userid计数</div><div>2、要给出电影名</div><div>     所以要使用movies表，movies有三个字段 ：  movieid,  title, type</div><div>     我们要的就是title字段，所以肯定要用join</div><div>3、求出最多的10部电影</div><div>     order by totalNumber desc</div><div>     limit 10;</div><div><br/></div><div>最终SQL ：</div><div><br/></div><div>drop table step2;</div><div>create table step2 as select b.title as title,  count(distinct userid) as totalNumber</div><div>from ratings a join movies b on a.movieid = b.movieid group by b.title order by totalNumber desc</div><div>limit 10;</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>（3）分别求男性，女性当中评分最高的10部电影（性别，电影名，影评分）</div><div><br/></div><div>思路：</div><div><br/></div><div>1、首先要确定性别，即确定评分到底是男性评的还是女性评的：</div><div>     users ： userid,  sex,  age ,  occupation,  zipcode</div><div>     分别求男性和女性，即在每一个sql语句中，都添加判断性别的一个条件。  如where sex = 'F'</div><div>2、评分最高的10部电影</div><div>     先求出所有电影的  评分（即每部电影所有人评论的评分的平均分）</div><div>     再order by avgrate desc;</div><div>     limit 10;</div><div>3、怎么求每部电影的平均评分？</div><div>     按照movieid（或title）分组</div><div>     avg(rate)</div><div><br/></div><div><br/></div><div>最终的SQL的编写：</div><div>create table step3_f as select  c.title as title, b.sex as sex, avg(a.rate) as avgrate </div><div>from ratings a join users b on a.userid = b.userid join movies c on a.movieid = c.movieid</div><div>where sex = 'F'</div><div>group by b.sex, c.title</div><div>order by avgrate desc</div><div>limit 10;</div><div><br/></div><div>create table step3_m as select  c.title as title, b.sex as sex, avg(a.rate) as avgrate </div><div>from ratings a join users b on a.userid = b.userid join movies c on a.movieid = c.movieid</div><div>where sex = 'M'</div><div>group by b.sex, c.title</div><div>order by avgrate desc</div><div>limit 10;</div><div><br/></div><div><br/></div><div>如果要求用一个SQL语句求：  则需要使用 row_number()</div><div><br/></div><div><br/></div><div>（4）求movieid = 2116这部电影各年龄段（因为年龄就只有7个，就按这个7个分就好了）</div><div>的平均影评（年龄段，影评分）</div><div>解题思路：</div><div>1、各年龄段</div><div>     当前的users表中的 所有用户的 不同的年龄的个数，总共就只有7 个。所以<span style="font-size: unset; color: unset; font-family: unset;">干脆就按照这7个年龄进行划分，即只需</span><span style="font-size: unset; color: unset; font-family: unset;">group by age 即可</span></div><div>2、需要给出的结果字段：</div><div>     年龄段  </div><div><span style="font-size: unset; color: unset; font-family: unset;">     评分（平均评分，avg（rate））</span></div><div><br/></div><div>最终的SQL ：</div><div>create table step4 as select b.age as age, avg(a.rate) as avgRate </div><div>from ratings a join users b on a.userid =  b.userid</div><div>where a.movieid = 2116</div><div>group by b.age;</div><div><br/></div><div><br/></div><div><br/></div><div>（5）求最喜欢看电影（影评次数最多）的那位女性评最高分的10部电影的平均影评分（观影者，电影名，影评分）</div><div><br/></div><div>解题思路：</div><div>1、最喜欢看电影女性：  即评分次数最多的“女性”</div><div>     怎么统计？</div><div>     按照userid分组</div><div>     按照movieid计数并记录为 totalNumber</div><div>     where sex = 'F'</div><div>    而评分在ratings表，性别则在users表，所以需要join</div><div>2、那位女性</div><div>     totalNumber最大的值所对应的那个userid</div><div><br/></div><div>由上面两步即可得出第一个SQL :  只求userid</div><div><span style="font-size: unset; color: unset; font-family: unset;">select userid from </span></div><div>(select a.userid, count(a.movieid) as movieNumber </div><div>from ratings a join users b on a.userid = b.userid</div><div>where b.sex = 'F'</div><div>group by a.userid</div><div>order by movieNumber desc</div><div>limit 1) aa;</div><div><br/></div><div>而下面这种写法是错误的，因为聚合函数不能放在order by 后面</div><div>select a.userid  </div><div>from ratings a join users b on a.userid = b.userid</div><div>where b.sex = 'F'</div><div>group by a.userid</div><div><span style="color: rgb(166, 0, 196);">order by count(a.movieid) desc</span></div><div>limit 1;   </div><div><br/></div><div>3、那位女性评分最高的10部电影</div><div>     当前这个userid评分最高的10部电影</div><div><br/></div><div>则根据第三步第二个SQL语句则可以写成：</div><div>     //“？”处就是写第一个的sql语句</div><div>     select rate, movieid from ratings where userid = ？ order by rate desc limit 10;</div><div>     另一种写法是：（这种写法的目的是为了得到title，最后结果显示为电影名而不是电影id，后面的第三个sql也将采用此写法）</div><div>     select b.title as title,  a.movieid as movieid from ratings a join movies b on a.movieid = b.movieid  where userid = ？order by rate desc limit 10;</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">注意区别对待</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">group by 和 order by</span></div><div>     group by的执行 是 在 select 之前</div><div>     order by的执行 是 select 之后</div><div>     所以order by后面接的可以是select语句中定义的别名，而group by 则不可以</div><div>    还有，order by后面跟的字段还必须是select后面跟的字段中的一个或多个，也就是说order by后面的字段必须是查询出来的字段 ，只有要查询出来的字段才会进行排序（当然这是说在hive中，在mysql中就没有这种限制，毕竟hive是为大数据考虑的，查了的才排序，不查的不排序）</div><div><br/></div><div>4、当前这个10部电影的平均影评分</div><div><br/></div><div>由第四步得到第三个SQL语句：（“？？”处就是写第二个的select语句）</div><div>create table step5 as select c.title as title, avg(a.rate) as avgrate</div><div>from ratings a join <span style="font-size: unset; color: unset; font-family: unset;">(？？) c</span></div><div>on a.movieid = c.movieid</div><div>group by c.title;</div><div><br/></div><div><br/></div><div><br/></div><div>（6）求好片（评分&gt;=4.0）最多的那个年份的最好看的10部电影</div><div><br/></div><div>解题思路：</div><div>1、好片</div><div>     该电影的影评分 &gt;= 4.0</div><div>2、求出每部电影的上映年份</div><div>     title中有个字段title后面包含了上映年份 ：  Metropolitan (1990)</div><div><br/></div><div>由第1和第2步，得 第一个SQL语句： 求出每部电影在哪一年上映，以及它的评分</div><div>create table step6_1 as</div><div>select b.title as title, substring(b.title, -5, 4) as year,  avg(a.rate) as avgrate</div><div>from ratings a  join movies b on a.movieid = b.movieid</div><div>group by b.title, substring(b.title, -5, 4);</div><div><br/></div><div>3、 按照year分组</div><div>    按照好片计数，记为number</div><div>    按照number数排降序</div><div>    limit 1 取year，也就是取出好片最多的那一年</div><div><br/></div><div>由第3步，得 第二个SQL语句：</div><div>create table step6_2 as</div><div>select a.year as year, count(*) as totalNumber</div><div>from step6_1 a</div><div>where a.avgrate &gt;= 4.0</div><div>group by a.year</div><div>order by totalNumber desc</div><div>limit 1;</div><div><br/></div><div>4、按照year作为筛选条件 求出 该年中 最好看的 10 部电影</div><div><br/></div><div>由第4步，得 第三个SQL语句：</div><div>     select * from step6_1 where year = （select year from step6_2） order by avgRate desc limit 10;</div><div>有一个需要注意的地方：</div><div>          该 10 部电影有没有可能不全都是好片？有可能, 所以有电影低于4.0的也不要惊讶</div><div><br/></div><div><br/></div><div><br/></div><div>（7）求1997年上映的电影中，评分最高的10部Comedy类电影</div><div><br/></div><div>解题思路：</div><div>1、两个过滤条件：</div><div>     where year = 1997</div><div>     where type = &quot;comedy&quot;</div><div>2、求出每一部电影的评分</div><div>     先求出一个step7_1 表： year, movieid,  title,  avgrate</div><div>     然后和movies表做连接,得到这些字段 :  type  title  movieid</div><div><br/></div><div>由第2步,先得到step7_1表:</div><div>create table step7_1 as</div><div>select b.movieid as movieid, b.title as title,</div><div>substring(b.title, -5, 4) as year,  avg(a.rate) as avgrate</div><div>from ratings a  join movies b on a.movieid = b.movieid</div><div>group by b.movieid,  b.title, substring(b.title, -5, 4);</div><div><br/></div><div>再结合第1步,得最终的SQL语句：</div><div>select  a.year as year, a.title as title, a.avgrate as rate</div><div>from step7_1 a join movies b on a.movieid = b.movieid</div><div>where a.year = 1997 and <span style="color: rgb(166, 0, 196);">instr(lcase(b.type), &quot;comedy&quot;) &gt; 0</span></div><div>order by rate desc limit 10;</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">instr()的作用是看字符串str是否包含子串substr,若包含,返回该子串所在的str的起始位置, 否则返回0;</span></div><div><img src="hive的影评案例_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>lcase()的作用是将所有英文字母转为小写</div><div><img src="hive的影评案例_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>（8）该影评库中各种类型电影中评价最高的5部电影（类型，电影名，平均影评分）</div><div><br/></div><div>解题思路：</div><div>1、各种类型</div><div>     即按照类型分组</div><div>2、评价最高的5部电影</div><div>     按照评分排序（每一组中排序）</div><div>     每组中评分最高的5部,则要使用row_number编号序号才行</div><div>          row_number()  over (distribute by type sort by avgrate desc) as idx</div><div>3、真正取前五的电影(topN)</div><div>     where idx &lt;= 5;</div><div>最终需要查询的字段：<span style="font-size: unset; color: unset; font-family: unset;">类型，电影名， 评分</span></div><div>     先求表step8_1 ： movieid, title,  type</div><div>     因为step7_1中有 ： year, movieid,  title,  avgrate, 所以可以使用join来得到step8_11</div><div>     得到的是所有不同类型的电影的评分表step8_11 : year, movieid,  title,  avgrate,  type</div><div>     然后通过8_11再使用row_number得到表step8_2</div><div>     最终只需要查一下表step8_2并加上where idx &lt;= 5;即可</div><div>思路：</div><div>     先求 step8_1</div><div>     再求 step8_11</div><div>     再求 step8_2</div><div>     最后执行：select * from step8_2 where idx &lt;= 5;</div><div><br/></div><div>为了得出step8_1, 若写成: </div><div><span style="font-size: unset; color: unset; font-family: unset;">create table step8_1 as</span></div><div>select a.year,  a.movieid,  a.title,  a.avgrate, b.type</div><div>from step7_1 a join movies b on a.movieid = b.movieid;    XXXXXXX</div><div>那么上面这种思路是错误的</div><div>因为一个电影可能有多个type,所以同一个电影可能分到多个组里,所以不能直接按照type分组,</div><div>正确思路：  要把一个属于多种类型的电影拆分成多条记录，有多少个类型，就拆分成几条</div><div>也就是说,要把一条记录变成多条记录, <span style="font-size: unset; color: unset; font-family: unset;">把一条记录转换成多条记录， </span><span style="font-size: unset; color: unset; font-family: unset;">就要用到函数当中的 UDTF  函数  ：  表格生成函数   explode</span></div><div>下面这种<span style="font-size: unset; color: unset; font-family: unset;">explode函数的用法</span>是正确的:</div><div>select explode(array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));    √√√√√√√√</div><div>但是想要得到下面这种样式的结果</div><div>1     a</div><div>1     b</div><div>1     c</div><div>若通过下面这种方式是会报错的:</div><div>select &quot;1&quot;,  explode(array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;));     xxxxxxxx</div><div><span style="font-size: unset; color: unset; font-family: unset;">这个时候就需要采用别的办法了,这个方法就是:</span></div><div>改写SQL ：  lateral view  虚拟视图(有点类似于虚表)</div><div>最终的SQL ： </div><div><br/></div><div>create table step8_1 as</div><div>select movieid, title, mt.movietype</div><div>from movies <span style="color: rgb(166, 0, 196);">lateral</span> <span style="color: rgb(166, 0, 196);">view explode(split(type, &quot;\\|&quot;)) mt as movietype</span>;   √√√√√√√</div><div><span style="color: rgb(166, 0, 196);">其中,split(type, &quot;\\|&quot;)是将type按&quot;|&quot;分隔切割成一个数组,explode再把数组由一行变成多行,lateral view 是?</span></div><div><br/></div><div>create table step8_11 as</div><div>select a.year, a.movieid, a.title, a.avgrate, b.movietype as type    </div><div>from step7_1 a join step8_1 b on a.movieid = b.movieid ;           √√√√√√√</div><div><br/></div><div>create table step8_2 as</div><div>select year, movieid, title, avgrate, type,</div><div><span style="color: rgb(166, 0, 196);">row_number()</span>  over (distribute by type sort by avgrate desc) as idx</div><div>from step8_11;                   √√√√√√√</div><div><br/></div><div>select * from step8_2 where idx &lt;= 5;            √√√√√√√</div><div><br/></div><div><br/></div><div><br/></div><div>（9）各年评分最高的电影类型（年份，类型，影评分）</div><div><br/></div><div><br/></div><div>解题思路：</div><div><br/></div><div>1、分组并每组取前1</div><div>     按照 年 分组</div><div>     按照  电影的类型的评分 排序</div><div>2、电影的类型的分</div><div>     就是该类型下所有电影的平均分</div><div>3、基于第八题的step8_11 去做</div><div><br/></div><div>     step8_11 :   year, movieid,  title,  avgrate,  type</div><div><br/></div><div><br/></div><div>第一步： 求出所有类型的  评分</div><div><br/></div><div>思路：          按照 year, type 分组， 按照 avg(avgRate) 做聚合</div><div><br/></div><div>step9_1 :  year, type, rate</div><div><br/></div><div>create table step9_1 as</div><div>select year, type, avg(avgrate) as rate</div><div>from step8_11</div><div>group by year, type;</div><div><br/></div><div><br/></div><div>第二步：</div><div><br/></div><div>需求： 求得每年当中的评分最高的电影的类型</div><div><br/></div><div>解题思路：</div><div>    </div><div>     1、按照 年 分组</div><div><br/></div><div>     2、每一组当中的所有电影类型，都按照类型的评分排降序</div><div><br/></div><div>     3、利用row_number这个窗口函数就能得出每一组中的任何记录在该组中的排序的序号</div><div><br/></div><div>     4、根据一个过滤条件 where idx = 1 就能求出每年中的评分最高的电影的类型</div><div><br/></div><div>SQL ：</div><div><br/></div><div>step9_2 :  year, type, rate , idx</div><div><br/></div><div>create table step9_2 as</div><div>select year, type, rate,</div><div>row_number() over (distribute by year sort by rate desc) as idx</div><div>from step9_1;</div><div><br/></div><div><br/></div><div>select * from step9_2 where idx  &lt;= 3;</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>（10）每个地区最高评分的电影名，把结果存入HDFS（地区，电影名，影评分）</div><div>HDFS目录:  /zipcode/movie/</div><div><br/></div><div>解题思路：</div><div><br/></div><div>1、每个地区</div><div><br/></div><div>     每一个不同的邮编就是一个不同的地区</div><div><br/></div><div>     把电影的movieid, rate,  userid , zipcode</div><div><br/></div><div>     分组：</div><div>          按照 zipcode, movieid </div><div>          聚合： avg(rate)</div><div><br/></div><div>step10_1 :  zipcode,  movieid,    avgrate</div><div><br/></div><div>SQL :</div><div><br/></div><div>create table step10_1 as</div><div>select a.movieid, b.zipcode, avg(a.rate) as avgrate</div><div>from ratings a join users b on a.userid = b.userid</div><div>group by a.movieid, b.zipcode;</div><div>    </div><div><br/></div><div>2、先求出每个地区的每部电影在该地区的评分的排名</div><div><br/></div><div><br/></div><div>SQL :</div><div><br/></div><div>create table step10_2 as</div><div>select zipcode, movieid, avgrate,</div><div>row_number() over (distribute by zipcode sort by avgrate desc) as idx</div><div>from step10_1;</div><div><br/></div><div><br/></div><div><br/></div><div>3、根据排名作为过滤条件来进行删除</div><div><br/></div><div>     where idx = 1;</div><div><br/></div><div>insert overwrite directory &quot;/zipcode/movie/&quot;</div><div>select * from step10_2 where idx = 1;</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>真正的重点：</div><div><br/></div><div>1、编写SQL的思路</div><div><br/></div><div>2、explode</div><div><br/></div><div>3、over</div><div>    </div><div>     标准的语法结构：</div><div><br/></div><div>     统计分析函数 over (distribute by col  sort by col1, col2 desc)</div></span>
</div></body></html> 