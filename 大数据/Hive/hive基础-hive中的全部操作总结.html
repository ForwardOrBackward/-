<html>
<head>
  <title>hive基础-hive中的全部操作总结</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="5597"/>
<h1>hive基础-hive中的全部操作总结</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/6/26 15:43</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/3/16 17:30</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>1、建库</div><div><br/></div><div>     create database mydb;</div><div>     create database if not exists mydb;</div><div>     create database if not exists mydb location &quot;/aa/bb&quot;;</div><div><br/></div><div>2、查询数据库</div><div>    </div><div>     查询库列表：show databases;</div><div>     查询库详细信息：desc database [extended] mydb;</div><div>     查询建库的详细信息：show create database mydb;</div><div><br/></div><div>3、删除数据库</div><div><br/></div><div>     drop database mydb;</div><div>     drop database if exists mydb;     // 删除一个空库</div><div>     drop database if exists mydb [restrict|cascade]; // 删除带有表的库的时候，必须后面加cascade</div><div><br/></div><div>4、先进入我们要操作的数据库/切换库</div><div><br/></div><div>     use mydb;     // 切换库</div><div>     select current_database();  // 查询正在使用的库</div><div><br/></div><div>5、查看数据库里面的表</div><div><br/></div><div>     show tables;</div><div>     show tables in mydb;</div><div><br/></div><div>6、添加表</div><div><br/></div><div>     两种不同的分类方式：</div><div><br/></div><div>     第一大类：  数据存储目录来定</div><div><br/></div><div>          内部表和外部表</div><div><br/></div><div>     第二大类：  按照数据的管理方式</div><div><br/></div><div>          分区表和分桶表</div><div><br/></div><div>     内部表和外部表的区别</div><div>     内部表和外部表的选择</div><div><br/></div><div>     创建内部表（Managered_Table）</div><div>     create table mingxing_mng(id int, name string, sex string, age int, department string) row format delimited fields terminated by ',';</div><div><br/></div><div>     show create table mingxing_mng;</div><div><br/></div><div>     创建外部表（External_Table）</div><div>     create external table mingxing_ext(id int, name string, sex string, age int, department string) row format delimited fields terminated by ',' location '/home/hadoop/hivedata';</div><div>     注意：创建外部表的时候指定location的位置必须是目录，不能是单个文件</div><div><br/></div><div>     跟内部表对比：</div><div>     1、在创建表的时候指定关键字： external</div><div>     2、一般来说，创建外部表，都需要指定一个外部路径</div><div><br/></div><div>     不管是创建外部表还是内部表，都可以指定数据存储目录</div><div>     默认的目录：</div><div>     <a href="hdfs://hadoop02:9000/user/hive/warehouse/myhive.db/student/student.txt">hdfs://hadoop02:9000/user/hive/warehouse/myhive.db/student/student.txt</a></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>     创建分区表</div><div>     create table mingxing_ptn(id int, name string, sex string, age int, department string) partitioned by (city string) row format delimited fields terminated by ',';</div><div>     注意：partitioned里的字段不是能是表中声明的字段，必须是一个新字段</div><div>     表字段</div><div>     分区字段</div><div><br/></div><div>     创建分桶表</div><div>     create table mingxing_bck(id int, name string, sex string, age int, department string) clustered by(id) sorted by(age desc) into 4 buckets row format delimited fields terminated by ',';</div><div>     注意：clustered里的字段必须要是表字段中出现的字段</div><div>     分桶字段</div><div>     表字段</div><div>     分桶字段和排序字段可以不一样，分桶字段和排序字段都必须是表字段中的一部分</div><div>     分桶的原理和MapReduce的HashPartitioner的原理一致</div><div><br/></div><div><br/></div><div>     创建表  和  查询 语句当中的 分区 和 分桶 等等的关键字的 识记：</div><div>     创建表：  关键字后面都加了ed(相当于被动语态) 如clustered by 、partitioned by</div><div>     查询表：  都是动词原型 如distribute by、cluster by</div><div><br/></div><div>7、删除表</div><div><br/></div><div>     drop table mingxing;</div><div>     drop table if exists mingxing;</div><div><br/></div><div>8、对表进行重命名</div><div><br/></div><div>     alter table mingxing rename to student;</div><div><br/></div><div>9、对表的字段进行操作（增加add，删除drop，修改change，替换replace）</div><div><br/></div><div>     增加字段：</div><div>     alter table mingxing add columns (province string);</div><div>     alter table mingxing add columns (province string, salary bigint);</div><div>     // 添加的字段的都是这个表的最后几个字段</div><div><br/></div><div>     删除字段：</div><div>     drop（不支持） XXXXX</div><div><br/></div><div>     修改字段：</div><div>     alter table mingxing change age newName string;               // 修改字段的定义</div><div>     alter table mingxing change age newName string after id;          // 修改字段的定义 + 顺序</div><div>     alter table mingxing change age newName string first;          // 修改age字段为第一个字段</div><div>     如果这个字段是string类型， 不能改成int类型  (hive-2.3.2中)</div><div>     如果这个字段是int类型， 可以改成string类型</div><div><br/></div><div>     替换字段</div><div>     alter table mingxing replace columns(id int, name string, sex string);     // 替换所有字段</div><div><br/></div><div>10、对表中的分区进行操作</div><div><br/></div><div>     直接往一个分区表中的一个不存在的分区导入数据；</div><div>     load data local inpath &quot;/home/hadoop/hive.txt&quot; into table mingxing_ptn partition(city=&quot;AA&quot;);</div><div>    </div><div>     增加分区(没有同时往新添加的分区里导入数据)：</div><div>     alter table mingxing_ptn add partition(city='beijing');</div><div>     alter table mingxing_ptn add partition(city='chongqing') partition(city='tianjin');  //同时增加多个分区</div><div>     //分区由多分区字段组成时,增加分区</div><div>     alter table mingxing_ptn add partition(city='beijing', email=&quot;<a href="mailto:abc@163.com">abc@163.com</a>&quot;);</div><div>     alter table mingxing_ptn add partition(city='beijing', email=&quot;<a href="mailto:abc@163.com">abc@163.com</a>&quot;) partition(city='tianjin',email=&quot;<a href="mailto:cba@163.com">cba@163.com</a>&quot;);</div><div>     // 对应的HDFS上的数据存储目录的表现形式： 多级文件夹的嵌套的形式</div><div><br/></div><div>     删除分区：</div><div>     alter table mingxing_ptn drop partition(city='beijing');</div><div>     //删除多个分区时分区之间一定要用逗号分隔  (创建多个分区时则不用)       </div><div>     alter table mingxing_ptn drop partition(city='chongqing')<span style="color: rgb(166, 0, 196);">,</span> partition(city='tianjin');</div><div>    //删除多字段分区</div><div>     alter table mingxing_ptn add partition(city='beijing', email=&quot;<a href="mailto:abc@163.com">abc@163.com</a>&quot;);</div><div>     alter table mingxing_ptn add partition(city='beijing', email=&quot;<a href="mailto:abc@163.com">abc@163.com</a>&quot;), partition(city='tianjin', email=&quot;<a href="mailto:cba@163.com">cba@163.com</a>&quot;);</div><div><br/></div><div>     修改分区路径：</div><div>     alter table mingxing_ptn partition(city=&quot;beijing&quot;) set location &quot;/mingxing_beijing&quot;;</div><div><br/></div><div>11、查询显示命令</div><div><br/></div><div>     查看库：show databases;</div><div>     查看表：show tables;</div><div>     查看建表完整语法：show create table mingxing_mng;</div><div>     查看内置函数库：show functions;</div><div>     查看函数的详细手册：desc function extended concat;</div><div>     查看分区：show partitions mingxing_ptn;</div><div>     查看表的字段：desc mingxing_mng;</div><div>     查看表的详细信息：desc extended mingxing_mng;</div><div>     查看表的格式化了之后的详细信息：desc formatted mingxing_mng;</div><div><br/></div><div>12、load方式导入数据</div><div><br/></div><div>     导入本地相对路径的数据</div><div>     load data local inpath './student.txt' into table mingxing;</div><div>     load data local inpath './student.txt' into table mingxing_ptn partition(city=&quot;AA&quot;);</div><div>     load data local inpath './student.txt' overwrite into table mingxing;    (覆盖导入)</div><div><br/></div><div>     导入本地绝对路径数据：</div><div>     load data local inpath '/home/hadoop/hivedata/student.txt' into table mingxing;</div><div><br/></div><div>     导入HDFS上的简便路径数据：</div><div>     load data inpath '/hivedata/student.txt' into table mingxing;</div><div><br/></div><div>     导入HDFS上的全路径模式下的数据：</div><div>     load data inpath '<a href="hdfs://hadoop01:9000/home/hadoop/hivedata/student.txt">hdfs://hadoop01:9000/home/hadoop/hivedata/student.txt</a>' into table mingxing;</div><div><br/></div><div>     导入本地数据和导入HDFS上的数据的区别：</div><div>     1、导入HDFS上的数据到hive表，表示剪切然后移动</div><div>     2、导入本地数据，相当于复制粘贴或者说上传</div><div><br/></div><div>13、利用insert关键字往表中插入数据</div><div><br/></div><div>     5种：</div><div>     单条数据插入：</div><div>     insert into table mingxing values(001,'huangbo','male',50,'MA');</div><div>     insert into table mingxing values(001,'huangbo','male',50,'MA') (002,'huangbo','male',50,'MA');</div><div><br/></div><div>     单重插入模式： insert ... select ....</div><div>     // 执行原理： 就是把select查询的结果插入到insert语句中的表中， select查询的所有字段，必须都在insert后面跟的表中都有。</div><div>     insert into table student select id,name,sex,age,department from mingxing;</div><div>     注意：查询出的字段必须是student表中存在的字段</div><div><br/></div><div>     多重插入模式：</div><div>     from mingxing</div><div>     insert into table student1 select id,name,sex,age</div><div>     insert into table student2 select id,department;</div><div><br/></div><div>     from mingxing2</div><div>     insert into table student1 partition(department='MA') select id,name,sex ,age where department='MA'</div><div>     insert into table student1 partition(department='CS') select id,name,sex ,age where department='CS';</div><div>     优点：如果有多个同类型的SQL语句，那么完全可以合并成一个多重模式的SQL</div><div>           可以减少这个查询操作的扫描数据的次数，从而来提高这个SQL语句的执行效率</div><div>     多重模式， 能用则用。！！</div><div><br/></div><div><br/></div><div>     静态分区插入：</div><div>     需要手动的创建分区</div><div>     alter table student add partition (city=&quot;zhengzhou&quot;);</div><div>     load data local inpath '/root/hivedata/student.txt' into table student partition(city='zhengzhou');</div><div>     // 当然也可以直接使用后面这条语句而没有掐面那条语句。因为可以往一个不存在的分区导入数据</div><div><br/></div><div>     动态分区插入：</div><div>     概念：按照你所指定的分区字段的值来进行自动判断，每一个不同的值就会创建一个对应的分区</div><div>     打开动态分区的开关：set hive.exec.dynamic.partition = true;</div><div>     设置动态分区插入模式：set hive.exec.dynamic.partition.mode = nonstrict</div><div><br/></div><div>     create table student(name string, department string) partitioned by (id int) .....</div><div>     insert into table student partition(id) select name,department,id from mingxing2;</div><div>     student表字段：name,department， 分区字段是id</div><div>     查询字段是：name,department,id，分区字段</div><div>     注意：动态分区插入的分区字段必须是查询语句当中出现的字段中的最后一个</div><div><br/></div><div>     进行动态分区插入的时候的select语句中的查询字段 == 分区表的正常表字段 + 动态分区字段</div><div>     如果你所指定的动态分区字段不是select查询的最后一个或者多个字段，SQL语句不会报错，但是结果不对</div><div><br/></div><div>     CTAS(create table ... as select ...)(直接把查询出来的结果存储到新建的一张表里)</div><div>     create table student as select id,name,age,department from mingxing;</div><div>     注意：自动新建的表中的字段和查询语句出现的字段的名称，类型，注释一模一样</div><div><br/></div><div><br/></div><div>     CTAS 和 insert ... select ...</div><div>     前者会自动创建一张新表， 后者是已经创建好了的表往里面插数据</div><div>    </div><div>     CTAS创建的表的限制：</div><div>     1、不能创建外部表</div><div>     2、不能创建分区表</div><div>     3、不能创建分桶表</div><div><br/></div><div>     分桶插入：</div><div><br/></div><div>     创建分桶表：</div><div>     create table mingxing_bck(id int, name string, sex string, age int, department string) clustered by(id) sorted by(age desc) into 4 buckets row format delimited fields terminated by ',';</div><div><br/></div><div>     导入数据(这种方法是错误的,分桶表不能用这种方式插入数据)：</div><div>     load data local inpath &quot;/home/hadoop/student.txt&quot; into table mingxing_bck;  XXXXXXXXXXX</div><div><br/></div><div>     插入数据：</div><div>     insert into table mingxing_bck select id,name,sex,age,department from student distribute by id sort by age desc;</div><div>     注意：查询语句中的分桶信息必须和分桶表中的信息一致</div><div><br/></div><div><br/></div><div><br/></div><div>14、like关键字使用：复制表结构</div><div><br/></div><div>     create table student like mingxing;</div><div>     不会复制数据</div><div>     新创建的表到底是内部表还是外部表跟源表没关系</div><div><br/></div><div>15、利用insert导出数据到本地或者hdfs</div><div><br/></div><div>     单模式导出数据到本地：</div><div>     insert overwrite local directory '/root/outputdata' select id,name,sex,age,department from mingxing;</div><div><br/></div><div>     多模式导出数据到本地：</div><div>     from mingxing</div><div>     insert overwrite local directory '/root/outputdata1' select id, name</div><div>     insert overwrite local directory '/root/outputdata2' select id, name,age</div><div><br/></div><div>     简便路径模式导出到hdfs：</div><div>     insert overwrite directory '/root/outputdata' select id,name,sex,age,department from mingxing;</div><div><br/></div><div>     全路径模式查询数据到hdfs：</div><div>     insert overwrite directory '<a href="hdfs://hadoop01:9000/root/outputdata1">hdfs://hadoop01:9000/root/outputdata1</a>' select id,name,sex,age,department from mingxing;</div><div><br/></div><div>     local ：导出到本地目录</div><div>     overwrite ：表示覆盖</div><div><br/></div><div>16、清空数据库表中的数据</div><div><br/></div><div>     truncate table mingxing_mng;</div><div>     // 清空内部表，外部表，分桶表的时候，表示把数据存储目录下的所有数据文件统统删掉</div><div>     // 清空分区表的时候， 只会清空所有分区下的数据文件， 不会删掉分区目录</div><div><br/></div><div>17、select查询</div><div><br/></div><div>     order by : 全局排序</div><div>     如果一个HQL语句当中设置了order by，那么最终在HQL语句执行过程中设置的</div><div>     set mapreduce.job.reduces = 4 不起作用。！！</div><div><br/></div><div>     sort by ：局部排序</div><div>     一般来说，要搭配 分桶操作使用</div><div>     distribute by id sort by age desc;</div><div>    </div><div>     distribute by : 纯粹就是分桶</div><div>     在使用distribute by的时候：要设置reduceTask的个数</div><div><br/></div><div>     cluster by ： 既分桶，也排序</div><div>     cluster by age = distribute by age sort by age;</div><div>     distribute by age sort by age,id != cluster by age sort by id    XXX</div><div>    </div><div>     cluster by 和 sort by 不能同时使用</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">区别对待</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">group by 和 order by</span></div><div>     group by的执行 是 在 select 之前</div><div>     order by的执行 是 select 之后</div><div>     所以order by后面接的可以是select语句中定义的别名，而group by 则不可以</div><div>    还有，order by后面跟的字段还必须是select后面跟的字段中的一个或多个，也就是说order by后面的字段必须是查询出来的字段 ，只有要查询出来的字段才会进行排序（当然这是说在hive中，在mysql中就没有这种限制，毕竟hive是为大数据考虑的，查了的才排序，不查的不排序）</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">总结一个规律（指的是在hive中）：</span></div><div><span style="color: rgb(166, 0, 196);">如果一个sql语句是一个group by的操作， 那么select 后面的查询字段只能出现以下两种情况：</span></div><div><span style="color: rgb(166, 0, 196);">    1、要么是group by后面的字段</span></div><div><span style="color: rgb(166, 0, 196);">    2、要是聚集函数（如sum count,max min  avg）</span></div><div><span style="color: rgb(166, 0, 196);">    只能</span><span style="color: rgb(166, 0, 196);">以上两种情况能作为字段跟在select后面，若跟了其他字段，则会报错</span></div><div><span style="color: rgb(166, 0, 196);">但在mysql中，有group by 子句时， 若是select字段后面跟了以上两种情况之外的字段，也不会报错，能运行出结果(但不一定</span><span style="color: rgb(166, 0, 196);">正确)</span><span style="color: rgb(166, 0, 196);">。一般来说（但也有许多情况不是这样）</span><span style="color: rgb(166, 0, 196);">以上两种情况作为字段跟在select后面group by 子句才有意义，如果不是上面两种情况下使用group by，那么很多情况下不用group by 也能得到结果；但是较为复杂的sql语句比如多表连接时，</span><span style="color: rgb(166, 0, 196);">不用group by，或者</span><span style="color: rgb(166, 0, 196);">select字段后面不跟</span><span style="color: rgb(166, 0, 196);">其他字段，</span><span style="color: rgb(166, 0, 196);">就</span><span style="color: rgb(166, 0, 196);">不一定能得到想要的结果，逼不得已要在使用了group by后，select后面要跟其他字段，那么在hive中就只能分成多条sql语句来写了，而mysql则没有这种苦恼。</span></div><div><br/></div><div>18、join查询</div><div><br/></div><div>     限制:</div><div>          支持 等值连接， 不支持 非等值连接</div><div>          支持 and 操作， 不支持 or</div><div>          支持超过2个表的连接</div><div><br/></div><div>     经验：</div><div>          当出现多个表进行连接时，最好把小表放置在前面！！ 把大表放置在最后</div><div><br/></div><div>    </div><div>     join分类；</div><div>         </div><div>          inner join</div><div>          left outer join</div><div>          right outer join</div><div>          full outer join</div><div>          left semi join</div><div>               它是in、exists的高效实现</div><div>         </div><div>          select a.* from a left semi join b on a.id = b.id</div><div>          等价于：</div><div>          select a.* from a where a.id in (select b.id from b);</div></span>
</div></body></html> 