<html>
<head>
  <title>java基础增强-设计模式</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="7302"/>
<h1>java基础增强-设计模式</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/1/31 15:13</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/1/31 16:46</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>课程回顾：</div><div>    list底层代码中最重要的方法就是add()方法, 尽量做到能手写<span style="font-size: unset; color: unset; font-family: unset;">:</span></div><div>        arrayList   add()     数组</div><div>        LinkedList   add()     双向链表 1.5之前是单链表, 后来改为双链表是为了提升查询性能  </div><div>    set：不可重复的 无序</div><div>        hashset:</div><div>            hashset去重最重要的办法: hashcode   + equals  </div><div>            在1.8中hashset的底层结构是:  桶表（数组   默认长度16）+链表+二叉树</div><div>        treeset：有序（大小  自然排序的）</div><div>            二叉树   实际上在1.8中是红黑树</div><div>    map：</div><div>        1.hashmap 线程非安全的, 效率高  hashtable 线程非安全的, 效率低</div><div>        2.concurrenthashmap  既是线程安全的, 也能保证效率。 通过加分段锁实现。</div><div>    递归：</div><div>        1）递归一定要单独的写一个方法</div><div>        2）递归要有出口</div><div>        3）规律</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>设计模式：</div><div>    设计模式出现的原因: </div><div>        通过大量的实践之后发现有一些固定的模式可以解决通用的场景问题, 是当前问题的<span style="color: rgb(166, 0, 196);">最佳</span>实现</div><div>    设计模式在最初出现的时候就是为了解决某一种场景问题, 也就是说一种设计模式不需要针对很多场景, 只需要解决一种场景问题即可</div><div>    java中常用的设计模式中有23种, 有7到8中可能在以后的开发中会用到</div><div>    总原则：开闭原则  (对扩展开放, 对修改关闭。也就是说支持你去扩展功能, 但不支持你修改原来的功能,因为设计模式本来就是为了解决某一种场景的问题,类似于一个热插拔的效果)</div><div>    设计模式中提倡面向接口编程很重要的原因是: 接口可以多实现, 而抽象类只能单继承。</div><div><br/></div><div>总体来说设计模式分为三大类：</div><div><b>创建型模式</b>，创建型模式是用来创建对象的, 共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 </div><div><b>结构型模式</b>，结构型模式是对原来的模式进行扩展或优化的, 共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合 模式、享元模式。 </div><div><b>行为型模式</b>，行为型模式是用来操作代码(类)之间的行为属性的,共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模 式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。<br/></div><div><br/></div><div>    单例设计：</div><div>        懒汉式：</div><div>            什么时候使用什么时候创建对象</div><div><span>    </span><span>    </span><span>    </span><img src="java基础增强-设计模式_files/Image.png" type="image/png" data-filename="Image.png" width="648"/><br/></div><div>        饿汉式：</div><div>            一开始就创建对象</div><div>        包含3部分：</div><div>            1.私有的构造</div><div>            2.私有的静态属性</div><div>            3.共有方法  返回对象的</div><div><br/></div><div>    装饰者模式</div><div>        io    </div><div>        被装饰对象的方法无法满足当前对象的需求的时候  当前对象可以对被装饰对象的方法进行增强</div><div>        list集合操作  add（）</div><div>        每次添加元素之前和之后分别打印一句话   我们需要对他进行装饰、包装</div><div>        添加元素的时候只添加spark开头的</div><div>        zengqiangadd(){</div><div>            list.size()</div><div>            add()</div><div>            list.size()</div><div>        }</div><div>        写法：</div><div>        1）将被装饰对象作为属性  </div><div>        2）对被装饰对象进行初始化</div><div>        3）完善增强方法</div><div>    代理模式</div><div>        演员------经纪人（代理）</div><div>        王宝强-----宋哲</div><div>        王宝强：拍戏     拍广告     接戏    接广告   谈合作</div><div>        自己只干核心的   不合心的东西让经纪人（代理）</div><div>        代码上：扩展性    灵活性    复用性</div><div>        层次分明  当一个代码中逻辑过多的时候    每一个代码只做自己的核心</div><div>        静态代理</div><div>            代理类的要求：</div><div>            1）必须和被代理对象实现相同的接口</div><div>            2）需要将被代理对象作为属性  并进行初始化</div><div>                核心功能需要调用被代理对象的</div><div>            3）和被代理对象事项相同的方法</div><div>                注意：核心方法调用被代理对象的  代理对象无权越界</div><div>            缺陷的：</div><div>                1.如果有很多个对象需要代理  写很多雷同的代码   代码臃肿</div><div>                2）如果被代理对象有很多方法需要实现  那么代理对象就需要实现很多的方法        代码量很大      搬砖</div><div><br/></div><div>            那么有没有一种代理方式可以同时代理多个对象，并且可以同时实现多个方法</div><div>            -----动态代理的方式</div><div>        动态代理：</div><div>            数据库的增删改查   伪代码的方式</div><div>            怎么代理多个对象，根据用户传入的生成代理------反射</div><div>        学生在呼吸的饿时候   呼吸之前和之后都需要敲代码</div><div>        1）修改原始代码</div><div>        2）代理模式  学生只需要做好自己的工作就可以   其他的工作交给代理</div><div><br/></div><div><br/></div><div><br/></div><div>    装饰者模式和代理模式的区别：</div><div>        1）代码结构上</div><div>            装饰者模式  被装饰对象传入的时候是外部方式传入的</div><div>            代理：代理和被代理对象必须实现相同的接口    必须实现吧相同的方法    </div><div>                    需要被代理对象作为属性   初始化一般采用内部传入</div><div>        2）从功能</div><div>            装饰者模式：对被装饰对象的方法的增强或补充   功能上的补全</div><div>                方法可以是已经存在的  也可以是从来没有存在的  readLine</div><div>            代理模式：帮助被代理对象做辅助的功能</div><div>                通常情况下包括：打印错误日志    监控   数据统计</div><div>                代码管理上</div><div>冒泡</div><div>插入</div><div>选择   手写  理解</div><div>线程：</div><div><br/></div><div><br/></div><div>线程锁</div><div><br/></div><div><br/></div><div>三种排序：</div><div>    冒泡</div><div>    插入</div><div>    选择</div><div><br/></div><div>    计数排序</div><div>    快速排序</div><div>    归并排序</div><div><br/></div><div><br/></div><div>面试过程中：</div><div>    排序算法</div><div>    设计模式  23   </div><div>    hadoop中wordcount</div><div>    spark   wordcount</div><div>    scala   wordcount</div><div><br/></div><div>hadoop准备：</div><div>    3台虚拟机   4台</div><div>    内存1G --1.5G   </div><div>    硬盘：50G</div><div>    网络</div><div>    主机名</div><div>    映射文件</div><div>    jdk</div><div>    创建一个普通用户  三台虚拟机普通用户名和密码一样</div><div><br/></div><div>可变参数：定义的时候：</div><div>参数类型 ... 参数名</div><div>String ... names</div><div><br/></div><div><br/></div><div><br/></div><div><a href="java基础增强-设计模式_files/Java-part1-基础增强--集合反射设计模式排序.pdf"><img src="java基础增强-设计模式_files/6c7a4b03fcfd821342ebcdf84ecca1ec.png" alt="Java-part1-基础增强--集合反射设计模式排序.pdf"></a></div><div><br/></div></span>
</div></body></html> 