<html>
<head>
  <title>day8-封装、重载、构造、初始化、this</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="3224"/>
<h1>day8-封装、重载、构造、初始化、this</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/2/16 23:07</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/5/19 12:36</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-size: unset; color: unset; font-family: unset;">封装：</span></div><div><br/></div><div>隐藏了对象的属性和实现细节，对外提供公共的访问方式。</div><div><br/></div><div><br/></div><div>private    属性</div><div>public   <span style="color: rgb(166, 0, 196);"> 访问器 getter ,setter (也就是set和get方法)  (访问器也就是访问方法)</span></div><div><span style="color: rgb(166, 0, 196);">将类中的成员变量设置为private</span>，禁止随便访问，然后<span style="color: rgb(166, 0, 196);">通过提供public的访问器对成员变量进行操作</span>。</div><div><br/></div><div>同时给一个变量定义get和set方法说明给用户提供的权限是既可以读又可以写,</div><div>    如果只提供set表示只可以写不可以读, 如果只提供get表示只可以读不可以写</div><div>好处：</div><div>  1.安全；</div><div>  2.只能通过我提供的方式来访问；</div><div>  3.访问器中可以使用流程控制语句。</div><div><br/></div><div>封装举例:</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image.png" type="image/png" data-filename="Image.png" width="753"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [1].png" type="image/png" data-filename="Image.png" width="653"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>this</div><div>  this就代表<span style="color: rgb(255, 0, 0);">当前</span><span style="color: rgb(255, 0, 0);">类</span>的当前这个对象,就是当前对象的一个引用(即this就表示一个对象,所以&quot;this.成员&quot;相当于&quot;该类的对象.成员&quot;)，用来<span style="color: rgb(166, 0, 196);">调用本类成员</span></div><div><span style="color: rgb(166, 0, 196);">   </span> <span style="color: rgb(255, 0, 0);">当前类</span><span style="color: rgb(166, 0, 196);">意味这,即使该类是内部类,</span><span style="color: rgb(166, 0, 196);">作为外部类的一个成员时,在该内部类中直接使用this(不是用类名.this)时,this也是代表该内部类的一个对象,而不是外部类的对象。这就是真正的</span><span style="color: rgb(255, 0, 0);">当前类</span><span style="color: rgb(166, 0, 196);">的含义。</span></div><div>this的作用:</div><div>  1.成员变量 和 局部变量同名时用this来区分；</div><div>  2.用 <span style="color: rgb(166, 0, 196);">this(参数);</span> 调用构造器来搭建其他构造器(注意,调用构造器只能放在其他构造器中,不能放在普通方法中)，并且位<span style="font-size: unset; color: unset; font-family: unset;">置一定要位于构造方法的第一行代码处。</span></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [2].png" type="image/png" data-filename="Image.png" width="746"/></div><div><br/></div><div>因为this就相当于&quot;当前对象&quot;,所以可以将this像如下使用:</div><div>        return this;就相当于返回当前对象,哪个对象调的setName()方法就返回谁。</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [4].png" type="image/png" data-filename="Image.png" width="750"/></div><div>将所有的set访问器都改成这种形式后:</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [5].png" type="image/png" data-filename="Image.png" width="773"/></div><div>就可以直接在new一个新对象时,不知道构造方法有哪些参数(参数比较多)的时候,直接通过下面这种方式创建对象并赋上想要的值</div><div>    因为每个set方法返回的都是对象,所以可以一直通过&quot;.&quot;的方式来一次调用这么多set方法</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [6].png" type="image/png" data-filename="Image.png" width="1098"/></div><div>记住,不能直接用this.xx来调构造函数,构造函数是不能当成方法在其他函数中随便调用的,因为构造函数只能编译器自己调用,并且只在初始化时使用<span style="color: rgb(166, 0, 196);">一次</span></div><div>下面两种用法都会报错</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [7].png" type="image/png" data-filename="Image.png" width="811"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [8].png" type="image/png" data-filename="Image.png" width="860"/></div><div>在main方法中,不能直接用this调用同一个类中的其他方法, 是因为main函数是<span style="color: rgb(166, 0, 196);">static</span>方法,而<span style="color: rgb(166, 0, 196);">this是不能用于static方法中的</span>, 而在同一个类的其他非static方法中可以用this调用其他方法,<span style="color: rgb(166, 0, 196);">并且this可以省略,因为不会重名</span>(在非static方法中,连其他的static方法也可以用this调用(this也可以省略),可以运行,只是会报警告)</div><div> <img src="day8-封装、重载、构造、初始化、this_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(166, 0, 196);">如果是static方法 ,则可以直接在main方法里直接调用</span>,不需要先初始化自身这个类,再用 .show1();来调用(当然先初始化再调用这样做也可以,不会报错,只是会警告而已)<span style="color: rgb(166, 0, 196);">（其实也就是static方法里只能直接调用static方法，静态方法要调用普通方法只能通过创建对象来调用）</span></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>方法重载：</div><div><br/></div><div>  定义：通常同一个类中，方法名相同，参数列表不同(个数不同，类型不同，顺序不同)的方法之间构成重载。</div><div>       （<span style="color: rgb(166, 0, 196);">与返回值无关,有无返回值不作为重载的依据）</span></div><div><br/></div><div>作用：方便记忆。</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">定义多个相同的方法名实现重载是没有任何关于声明重载的关键字的, 而是当方法名相同时, 编译器会根据参数列表来区分具体调用哪个方法,因为每个重载方法的参数列表必然是不同的</span></div><div><br/></div><div>举例:</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [11].png" type="image/png" data-filename="Image.png" width="646"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>有无返回值不作为重载的依据 举例:</div><div><br/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div>这样是会报错的,虽然一个有返回值一个无返回值,但是编译器不能对这两个方法进行区分,会认为是同一个方法,因为编译器可以不对返回值进行处理(也就是说 第一个方法的返回值就算代码中没有拿一个变量来接收它或者直接输出,编译也可以通过)。典型的返回值未处理如下,返回值并没有起到任何作用, 就这样消失了。</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>可变参数(变长参数)和数组不能出现在同一类重载方法里,因为可变参数底层是数组</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>下面这个</div><div>因为可变参数是jdk5.0才出现的东西, 所以肯定要兼容以前的, 所以当可变参数重载和固定参数列表的重载在一起时,</div><div>优先使用的是固定参数的重载,也就是说下面这段代码的输出结果是int 而不是int...</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>重载时也要注意传null作为参数不能引起歧义</div><div>下面代码中,t.f()直接传s也行,直接传r也行,但不能直接传null,因为null也是字面值,但null是没有默认类型的,</div><div>所以编译器也不知道该调用哪个函数,所以会报错</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div><br/></div><div>构造方法：</div><div><br/></div><div>  作用：初始化对象</div><div>  分类：</div><div>    1.默认</div><div>    2.无参</div><div>    3.带参</div><div><br/></div><div>其实new一个对象, new后面跟的也是一个方法(因为它带了一对括号,词语带一对括号的都是方法), 只不过这个方法和其他方法不同, 是这个类的构造方法, 所以new一个对象这个语法,其实就是调用构造方法<span style="color: rgb(166, 0, 196);">初始化</span>(即使自己没有定义构造方法系统也会有默认的一个无参构造方法),所以说new关键字就是用来初始化的(注意和<span style="color: rgb(166, 0, 196);">定</span><span style="color: rgb(166, 0, 196);">义</span>区分)。</div><div>区分构造方法的办法很简单,构造方法首字母一般大写(因为类就是首字母大写,而构造方法一般和类名相同),而其他方法一般都是小写</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>创建构造方法的语法：</div><div><br/></div><div>  访问修饰符 构造方法名(参数){</div><div><br/></div><div>        初始化的代码；</div><div><br/></div><div>  }</div><div><br/></div><div><br/></div><div>默认：</div><div>  当我们没有显式定义一个构造器，那么系统会自动创建一个默认构造，没有参数，访问权限与类相同。</div><div>只要我们显式的定义了一个构造器, <span style="color: rgb(255, 0, 0);">默认的构造方法</span>就不存在了</div><div><br/></div><div><br/></div><div>无参构造器、带参构造器：</div><div>  只要我们显式的定义了构造器，那么默认构造就不存在了。<span style="color: rgb(166, 0, 196);">所以为了便于使用,在构造方法重载时,一般都会默认定义一个无参构造, </span></div><div><span style="color: rgb(166, 0, 196);">    否则如果只是想创建一个对象, 构造方法不传参，这样的话会报错。</span></div><div><span style="color: rgb(166, 0, 196);">    像下图这样不写啥,留个空也行。   </span></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>构造方法重载。</div><div>  <img src="day8-封装、重载、构造、初始化、this_files/Image [20].png" type="image/png" data-filename="Image.png" width="860"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>也可以用this来实现重载,可以少写一点代码</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [22].png" type="image/png" data-filename="Image.png" width="1092"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [23].png" type="image/png" data-filename="Image.png" width="1068"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div>也可以用参数少的调用参数多的构造方法, 但是没有涉及到的参数只能直接给常数作为默认值,所以一般也不会这么做</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>也可以在声明(也就是我常说的定义)的同时初始化,但是这个值很可能被后来的赋的值覆盖掉</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [26].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">使用构造块来初始化成员变量。</span></div><div>构造块会在创建对象时执行, 创建对象时会先执行构造块,再执行构造函数,。</div><div>也就说不管构造块定义在类里的哪个位置,都是先调构造块,再调用构造函数。</div><div>所以说它就等同于上面那个声明处初始化,所以感觉也作用不大。</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [27].png" type="image/png" data-filename="Image.png" width="468"/></div><div><br/></div><div><br/></div><div><br/></div><div>成员变量初试化的全过程</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div>过程分析如下图</div><div>其实声明处初始化在构造块初始化前面先初始化也可以理解,毕竟从声明变量到初始化 一条语句就</div><div>完成了声明处初始化全过程, 当然是它最先初始化咯</div><div><span style="color: rgb(166, 0, 196);">写代码的时候需要了解到,最后决定初始化最终结果的是构造器</span></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [29].png" type="image/png" data-filename="Image.png" width="787"/></div><div>但是构造块初始化一定是在构造器初始化前面的,这不论代码的位置如何摆放, 就算如下图所示,初始化的顺序和结果还是一样的</div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [30].png" type="image/png" data-filename="Image.png" width="879"/></div><div><img src="day8-封装、重载、构造、初始化、this_files/Image [31].png" type="image/png" data-filename="Image.png" width="848"/></div><div>最后说一句,构造块是用来初始化的,最好别放其他代码</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">在实际运行时,编译器会把所有声明处初始化和构造块初始化的代码按顺序放在每个</span><span style="color: rgb(255, 0, 0);">构造方法里</span><span style="color: rgb(166, 0, 196);">的最前面代码处, 好让</span></div><div><span style="color: rgb(166, 0, 196);">这些代码先执行。所以说，</span><span style="color: rgb(166, 0, 196);">如果能直接用构造器初始化就用,优先使用构造器初始化,省得麻烦。 </span></div><div><span style="color: rgb(166, 0, 196);">但如果每个构造器里有冗余的代码 还是可以把冗余的代码单独拿出来放在一个构造块里面,避免代码冗余(</span><span style="color: rgb(255, 0, 0);">这才是构造块的真正用法</span><span style="color: rgb(166, 0, 196);">)</span></div><div><span style="color: rgb(166, 0, 196);">如下图</span></div><div><span style="color: rgb(166, 0, 196);"><img src="day8-封装、重载、构造、初始化、this_files/Image [32].png" type="image/png" data-filename="Image.png"/></span></div><div>------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>构造方法和普通方法的区别：</div><div><br/></div><div>1.构造方法的作用是初始化对象。</div><div>  普通方法则是为了完成特定功能的。</div><div><br/></div><div>2.构造方法只有创建对象时才能调用，也就是new的时候。</div><div>  普通方法创建对象后，随时调用。</div><div><br/></div><div>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>构造方法(构造器)和访问器(get、set)区别：</div><div><br/></div><div>1.构造器是在创建对象<span style="color: rgb(166, 0, 196);">时</span>赋值；</div><div>  访问器是在对象创建<span style="color: rgb(166, 0, 196);">后</span>，调用赋值；</div><div><br/></div><div>2.构造器在创建对象时可以一次性初始化；</div><div>  访问器是在对象创建后，逐个访问赋值；</div><div><br/></div><div>3.对象创建<span style="color: rgb(166, 0, 196);">后</span>修改属性的值，用set访问器。</div><div>    对象创建后访问属性的值，用get访问器。</div><div>    这时候构造器就没用了</div><div><br/></div><div>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>构造块：</div><div>  定义：</div><div><br/></div><div>  class 类{</div><div>    {</div><div>         //构造块：作用在构造方法重载的时候，解决多个构造器代码冗余的问题。</div><div>      </div><div>    }</div><div> }</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手写与上传资料分割线</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—————————————————————</span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><br/></div><div><a href="day8-封装、重载、构造、初始化、this_files/day6 - LIU_重载构造.pdf"><img src="day8-封装、重载、构造、初始化、this_files/8a50a9cb8e054f4c3f99a71c905c16eb.png" alt="day6 - LIU_重载构造.pdf"></a></div><div><br/></div></span>
</div></body></html> 