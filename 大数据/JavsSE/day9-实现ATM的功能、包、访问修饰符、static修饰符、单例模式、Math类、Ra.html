<html>
<head>
  <title>day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Random类</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="3805"/>
<h1>day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Random类</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/3/10 20:44</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/3/17 16:59</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-weight: bold;">1、实现一个ATM</span></div><div>具体代码见(我写的):</div><div><a href="file:///F:/Java/eclipse_workplace_ALL/JavaSE%E7%BD%91%E8%AF%BE%E4%BB%A3%E7%A0%81/JavaSE%E7%BD%91%E8%AF%BE%E4%BB%A3%E7%A0%81/src/day9/ATM">F:\Java\eclipse_workplace_ALL\JavaSE网课代码\JavaSE网课代码\src\day9\ATM</a></div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image.png" type="image/png" data-filename="Image.png" width="316"/></div><div>视频老师给的:</div><div><a href="file:///E:/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/19%E5%85%89%E7%8E%AF%E5%9B%BD%E9%99%85%E5%A4%A7%E6%95%B0%E6%8D%AE/1.javase/day09/day9%E4%B8%8B%E5%8D%88%E7%AC%94%E8%AE%B0%E5%92%8C%E4%BB%A3%E7%A0%81/%E4%BB%A3%E7%A0%81/day9/atm">E:\学习资料\19光环国际大数据\1.javase\day09\day9下午笔记和代码\代码\day9\atm</a></div><div><br/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>程序包：</div><div>  用来管理<span style="color: rgb(166, 0, 196);">类和接口</span>的工具。 </div><div>  创建包的方式:</div><div>      package 包名;</div><div>  包是具有层次结构的:(空的父包名在eclipse是会省略的)</div><div>      package 父包名[.子包名.……];</div><div>  命令规则:</div><div>      包名：  小写</div><div><br/></div><div>        通常命名方式是: 域名反转</div><div>            即:  顶级域名(.com或.cn等).部门名.项目名;</div><div>                    如          com.abc.bookmanage</div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>不同包之间的访问：</div><div>  方法1.需要导入程序包:  (在多次使用某个包时使用该方法)</div><div>        import 包名.类名;     (导入包中的某个具体的类)</div><div>        或者   import 包名.*; (导入该包下的所有类)</div><div>       如下面的在a包中的类A想用使用b包中的类B,则需要导包访问才能<img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [1].png" type="image/png" data-filename="Image.png" width="1098"/></div><div> 方法2 :使用完全限定名称(不用导包):   (在只使用一次其他包的某个类时,使用该方法较好)</div><div>       直接在使用该类时使用 包名.类型名 来访问</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [2].png" type="image/png" data-filename="Image.png" width="1098"/></div><div><br/></div><div>  2.只导入父包下的类型时，是不会包括子包下的类型的；</div><div>        只导父包时,如果该父包有子包,那么子包里的类还是不能用</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [3].png" type="image/png" data-filename="Image.png" width="438"/></div><div><br/></div><div>  3.两个包下有同名的类，只能用完全限定名称来访问。</div><div>    如以下两个包,用导包的方式来使用d包中的类A,会报错,只能用完全限定名来在包a中使用d包中的类A</div><div>  <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [4].png" type="image/png" data-filename="Image.png" width="442"/></div><div><br/></div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [5].png" type="image/png" data-filename="Image.png" width="433"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>程序包的优点：</div><div>  1.用来管理类；</div><div>  2.防止命名冲突；</div><div>        因为一个类在文件夹中的文件名一般是public修饰的类(当然这种是在一个文件中有多个并列类的情况下。当只有一个类</div><div>        时,不论是什么修饰的文件名都是该类),除了public修饰的类,可能还有其他类(如默认类和private类),这种情况下,如果这些</div><div>        类都在同一个包中,不知道一个类文件中有哪些类,则很容易命名冲突。</div><div>        如下中 Inner类定义在一个单独的.java文件中</div><div>        <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [6].png" type="image/png" data-filename="Image.png" width="295"/></div><div>        若在同一个包的另一个.java文件中定义两个并列类,其实不作为文件名的类(非public修饰的)则会报错说这个类已经被定</div><div>            义。如果这两个.java文件在不同的包下则不会这样了。</div><div>        <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [7].png" type="image/png" data-filename="Image.png" width="543"/></div><div><br/></div><div>  3.更好的保护类和类中的成员（体现封装）。</div><div style="margin-left: 40px;">前面所说的类A可以通过导包或完全限定名称来访问其他包中的类B, 是因为类B是public的, 如果类B在其他包中不是public的(是默认的或者private的等),那么类B对于类A来说是不可见的,类A通过导包和完全限定名称也访问不了该类。如:</div><div style="margin-left: 40px;"><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [8].png" type="image/png" data-filename="Image.png" width="472"/></div><div style="margin-left: 40px;">这是在a包中定义的一个类A,可以看到它无法访问d包中的默认类A</div><div style="margin-left: 40px;"><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [9].png" type="image/png" data-filename="Image.png" width="601"/></div><div style="margin-left: 40px;"><br/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>package 包名 :  这行代码一定要写在文件中的第一行，而且只能有一行。</div><div>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div><span style="color: rgb(166, 0, 196);">访问</span>修饰符：(访问的级别,表示它所修饰的成员的访问可见性)</div><div>            修饰符有很多, 但访问修饰符只要四个</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">下面是访问修饰符以及他们可以在哪些地方被访问:   </span><span style="color: rgb(166, 0, 196);">(默认即什么访问修饰符都不加)</span></div><div><span style="color: rgb(166, 0, 196);">                    本类    同包   子类   不同包</span></div><div><span style="color: rgb(166, 0, 196);">private         可以</span></div><div><span style="color: rgb(166, 0, 196);"><br/></span></div><div><span style="color: rgb(166, 0, 196);">默认              可以    可以                          (子类和父类同包时,子类可以直接</span><span style="color: rgb(255, 0, 0);">使用</span><span style="color: rgb(166, 0, 196);">父类的被默认访问修饰符修饰的成员,不同包则不能使用)</span></div><div><span style="color: rgb(166, 0, 196);"><br/></span></div><div><span style="color: rgb(166, 0, 196);">protected     可以    可以   可以                (也就是说,只要是其子类,同不同包都能直接使用。不同包的话,其他类(非子类)就不能访问了)</span></div><div><span style="color: rgb(166, 0, 196);"><br/></span></div><div><span style="color: rgb(166, 0, 196);">public           可以    可以   可以   可以</span></div><div><br/></div><div>private访问权限举例:</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [10].png" type="image/png" data-filename="Image.png" width="738"/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>static : 修饰符</div><div>可修饰：</div><div>            属性;</div><div>             方法( );</div><div>             代码块{ };</div><div>             类{ } </div><div><br/></div><div><span style="color: rgb(255, 0, 0);">(static修饰类时只能出现在内部类时,顶级类(或者说一个独立的类)不能直接被static修饰,会报错)</span></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>static修饰属性：   (注意访问修饰符在static修饰符的前面)</div><div style="margin-left: 40px;">class 类{    </div><div style="margin-left: 40px;">  访问修饰符 static 类型 变量名;     //称为静态变量，或者称为类变量。</div><div style="margin-left: 40px;">  访问修饰符 static 类型 方法名;     //称为静态方法，或者称为类方法。</div><div style="margin-left: 40px;">}</div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;">举例:</div><div style="margin-left: 40px;"><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div style="margin-left: 40px;">下面这张图的代码是错误的实现代码:     (他们new了两个新对象,然后是各自的成员变量做了相应的操作,所以不是整个类的count+2)</div><div style="margin-left: 40px;"><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [12].png" type="image/png" data-filename="Image.png" width="648"/></div><div style="margin-left: 40px;">这是上面这张图的代码执行完后的内存情况,可以看出成员变量是属于对象而不属于类的,所以无法实现问题的需求</div><div style="margin-left: 40px;"><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [13].png" type="image/png" data-filename="Image.png" width="785"/></div><div>        但只需要前面代码的基础上, 在count变量前面加一个static即可达到 问题的要求</div><div>        <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [14].png" type="image/png" data-filename="Image.png" width="726"/></div><div>        先看上面的代码在类加载时的内存图: (类加载的简化原理见后面文字)</div><div>        <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [15].png" type="image/png" data-filename="Image.png" width="732"/></div><div>        下面的是上面的代码的实际执行时的内存图: 可以看出,即使是guojing.count 、huangrong.count 调用的却是方法区(而非堆区)</div><div>                的类成员count,而不是属于对象的成员。但也要注意guojing.count 、huangrong.count 这种写法编译器是会出警告的。</div><div>        <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [16].png" type="image/png" data-filename="Image.png" width="747"/></div><div><br/></div><div>静态成员:</div><div style="margin-left: 40px;">属于类，不属于对象；</div><div style="margin-left: 40px;">被所有对象所共享；</div><div style="margin-left: 40px;">优先于对象而存在。</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">.java源文件是如何被编译运行的: (类加载的过程)</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">javac命令   将.java源文件编译,变成  .class(字节码文件)            (由源文件变成字节码文件)</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">java命令  调用  JVM（将.class文件加载到JVM的内存中） (具体是将.class文件里的内容加载到JVM内存中的方法区中)</span></div><div>        整个类加载完后,才能根据模板创建对象,故静态成员初始化完成是优先于对象的,即静态成员是优先于对象而存在的。</div><div><br/></div><div>静态变量的使用方式：</div><div>  1.对象名.静态变量名：</div><div>  2.类名.静态变量名；   //建议使用这种     (如果是在自己的类中使用自己的静态变量,还可以省略类名不写,直接通过静态变量名来使用)</div><div><br/></div><div>适用场合：</div><div>  需要同一个类的多个对象共享同一个空间的时候。</div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>静态变量(类变量)和实例变量(归对象所有)的区别：</div><div><br/></div><div>1.静态变量属于类；实例变量属于对象；</div><div><br/></div><div>2.静态变量在类加载时加载，存在方法区中；</div><div>  实例变量在创建对象时创建，存在堆中；</div><div><br/></div><div>3.静态变量在类卸载时释放（类卸载简单来说是在应用程序结束时）</div><div>  实例变量在对象销毁时即释放。(当然一般明显早于类卸载)</div><div><br/></div><div>所以静态成员的生命周期特别长, 在整个类的使用过程中一直占用内存空间,使用时要谨慎</div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>静态方法：</div><div>public static void show( ){   }</div><div>属于类</div><div><span style="color: rgb(255, 0, 0);">需要注意的是静态方法中不能再定义静态变量了,会报错。因为静态方法里的变量已经是可以直接不创建对象就被调用该静态方法时使用到了,再将静态方法里面的变量定义成静态变量也就没有了意义(就算定义静态常量也会报错)。实际上, static修饰变量仅仅可以修饰类的成员变量以及静态内部类里的成员变量, 就这两种。</span></div><div>使用方式:</div><div>  类名.静态方法名();      //推荐使用</div><div>  对象名.静态方法名();   //也可以调用,但不推荐,会有编译警告</div><div><br/></div><div>场合：</div><div>  需要同一个类的多个对象共享同一个空间的时候；</div><div>  使用方便,不用创建对象；</div><div>  不能创建对象时。</div><div><br/></div><div>静态方法和实例方法区别：</div><div>1.静态方法只能直接访问静态成员；</div><div>  实例方法可以直接访问静态的和非静态的成员;</div><div>      举例: </div><div>    <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [17].png" type="image/png" data-filename="Image.png" width="515"/></div><div>    静态方法需要先创建对象才能访问非静态成员,但能直接访问静态成员(main方法同样也是静态方法)</div><div>    <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [18].png" type="image/png" data-filename="Image.png" width="667"/></div><div>2.静态方法不能使用 this、super(用于调用父类成员)   </div><div>        因为this是指向当前对象的,连对象都没有,当然指不了。而super调用父类成员时也可能调用到非静态成员, 所以不能使用。</div><div>  实例方法可以使用this，super  </div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>静态块：(也就是用static来修饰代码块(代码块即构造块))</div><div><br/></div><div>1.构造块(在创建对象时执行)</div><div>class 类{</div><div>  {</div><div>    构造块：初始化对象，解决的构造方法中代码冗余。</div><div>  }</div><div>}</div><div><br/></div><div><br/></div><div>2.静态块 (即静态代码块, 在加载类的时候就会自动执行)</div><div>class 类{</div><div>  static {</div><div>      静态块：初始化类（初始化静态变量,当然静态块也只能访问静态成员） 为类中的静态成员进行初始化的</div><div>  }  </div><div>}</div><div><br/></div><div>    举例: 不需要先创建对象就可直接使用静态成员</div><div>    <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [19].png" type="image/png" data-filename="Image.png" width="661"/> </div><div>        主方法是程序的入口,但在运行主方法前,当然要先加载主方法所在的类(即主类,也叫启动类)</div><div>        所有的类加载到方法区在堆中都会生成一个该类对应的对象,<span style="color: rgb(166, 0, 196);">这个对象是Class类型</span>(注意和小写的class区分,小写的class是</div><div>            一个关键字,用来声明定义类的,而大写的Class是一种类型--类类型。不同的类类型的对象中定义了有不同方法,自己定义</div><div>            了一些功能(类名、属性、方法、构造器之类的)。类类型也是一种引用类型,是类向上抽取出来的类型。可以通过类类型的</div><div>            对象,调用类类型里的方法,来获得字节码文件中的所有信息,这就是反射的机制,因为所有字节码文件的对象都是Class类型,</div><div>            所以他们都有那些功能(类名、属性、方法、构造器之类的),只是功能的具体不同)</div><div>        然后才是利用该类对应对象创建出(实例化出)实际的对象</div><div>        上面的代码的内存图如图:</div><div>        <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [20].png" type="image/png" data-filename="Image.png" width="1005"/></div><div><br/></div><div>3.局部块 :  (即局部代码块,也就是在方法中使用的代码块 )</div><div>public void f(){</div><div>  int n = 2;  //局部变量,只能在当前方法中使用</div><div>  {</div><div>   局部代码块: 限制局部变量的使用范围和生命周期。(比如说在for循环里声明定义的变量,就被循环的括号包裹,只能在循环里使用)</div><div>  }</div><div>}</div><div>        局部变量的生命周期是在方法使用完后被释放掉, 而局部代码块里定义的变量则在局部块执行完时即被释放。</div><div>                (这里所说的释放都是执行一次即释放一次,多次执行当然每次执行就会重新声明定义一个新的变量了)</div><div>        举例: 在局部代码块里面定义的x变量在局部代码块外面就无法使用了,会报错</div><div>        <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [21].png" type="image/png" data-filename="Image.png" width="518"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>静态导入：</div><div>import static 包名.类名.静态成员名;</div><div>import static 包名.类名. * ;     //快捷方式。导入该类的所有静态成员</div><div> </div><div>举例: </div><div><br/></div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [23].png" type="image/png" data-filename="Image.png"/></div><div>当其他包想调用b包中的B类里的静态方法时, 就可以有两种不同的操作方式,注意下图中红笔和蓝笔框起来的区域的不同操作。</div><div>当然,红笔的操作方式是会出警告的,用的是 对象.静态成员 的方式,当然会警告。蓝笔所用的方式则可以直接用 类名.静态成员名 的</div><div>    方式来进行操作,并且这种导包方式下还可以在一个类里使用别的类的静态成员时,省略类名不写。    </div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [24].png" type="image/png" data-filename="Image.png" width="402"/></div><div>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>单例模式：(即保证,某个类始终在堆里面只创建一个对象(实例),单例模式是24中设计模式中最简单的一种)</div><div>    比如说一个音乐播放器就一个窗口,每次切换歌曲时还要保持在同一个窗口,而一个窗口显然就是一个对象了。</div><div>        而此时就可以把音乐设置为静态成员。</div><div>    <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div>    首先要明白为什么能创建多个对象。每次创建对象是通过new关键字加上构造方法创建出来的,所以要想阻止创建多个对象,</div><div>        就要阻止使用构造方法。</div><div>    举例:下面的<span style="color: rgb(166, 0, 196);">Window类</span>即是单例模式的饿汉式的设计方法:</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [26].png" type="image/png" data-filename="Image.png" width="739"/></div><div>上图的程序执行时,先是会主动加载main方法所在的类TestWindow, 而其他类(如Window类)则是执行时有使用到它才会将它</div><div>    预先加载到内存中,如果没有使用到,则不加载(当然,有没有使用到这在编译时编译器就已经判断出来了,所以加不加载其他类</div><div>    在编译后就已经确定了,如果加载则和主类一起一次性全部加载到内存中)。有没有使用Window类不是看Window类有没有</div><div>   出现在代码中,而是看它有没有被执行(如: 在TestWindow类的一个<span style="color: rgb(166, 0, 196);">非静态</span>私有成员里使用了Window类,但是TestWindow并没有</div><div>    去创建对象,这样Window类就不会在编译后的字节码文件里出现,显然也是没有使用到Window类的,Window类也就不会被加载到内存中)。</div><div>同时,类也只会加载一次,即使同一个类在代码中被调用了多次,也不会被重复加载, 这是类加载器的源码所决定的</div><div><br/></div><div>下面是懒汉式的代码:  和饿汉式区别不大。</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [27].png" type="image/png" data-filename="Image.png"/></div><div>区别：</div><div>  1. 饿汉式：类加载时对象就存在了。</div><div>     懒汉式：类加载时对象不存在，只有在使用到时才创建对象。</div><div>  2.多线程时:</div><div>    饿汉式： 线程安全的。</div><div>    懒汉式： 线程非安全的。</div><div>------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>常用API之Math类</div><div><br/></div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [28].png" type="image/png" data-filename="Image.png" width="672"/></div><div>举例:</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div>Math.random()方法在底层调用的是Random类的nextDouble()方法。而Random类还有很多产生各种随机数的方法。</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [30].png" type="image/png" data-filename="Image.png"/></div><div><span style="font-size: 14pt;">    随机种子在创建对象时指定</span></div><div>    随机种子是一个long类型的数字,该数字会参与随机算法来生成一个随机数。随机种子会使一次编译后,在同一次运行时,同</div><div>        一个Random对象产生的随机数的值是按某个规律依次变化的,不受时间的影响,<span style="color: rgb(166, 0, 196);">只受</span><span style="color: rgb(166, 0, 196);">访问该Random对象次数</span><span style="color: rgb(166, 0, 196);">的影响</span>(要是</div><div>        同一次运行时,下一次运行又会从第一个随机数开始,不管是什么时间),访问一次变一次。而且<span style="color: rgb(166, 0, 196);">再次重新运行后产生的结果会</span></div><div><span style="color: rgb(166, 0, 196);">        和上次运行时的结果一样,即使重新编译后也一样。</span></div><div>        有了随机种子后,在如果两个Random对象的随机种子是相同的,那么在相同访问次数时,它们产生的随机数一定是相同的。</div><div>        也就是说, 当种子一样的时候，虽然每次.nextXXX的方法会返回不同的结果，但是由于每次new Random(相同的seed时)创</div><div>        建的“随机数生成器”都相同，因此之后产生的<span style="color: rgb(166, 0, 196);">随机数序列</span>也就都是一样的,也就是说随机数序列是一定的、固定的。所以</div><div>        每次调用该函数生成随机数都会产生固定的结果。</div><div>    <img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [31].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>    问题举例:</div><div><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/Image [32].png" type="image/png" data-filename="Image.png" width="517"/></div><div> 方法1: int random = (int)(Math.random()*(10-1+1)+1);</div><div> 方法2: int random = new Random().nextInt(10)+1;  //因为nextInt(10)产生的是[0,10)的随机数,所以+1即为[1,11) ,对于整数来</div><div>                                                                                    //说正好是[1,10]。</div><div><br/></div><div><br/></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手写与上传资料分割线</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—————————————————————</span></div><div><br/></div><div><br/></div><div><a href="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/day7 - LIU_访问权限 - LIU .pdf"><img src="day9-实现ATM的功能、包、访问修饰符、static修饰符、单例模式、Math类、Ra_files/3a7639c2b75b2b1c06cce2fd313c9074.png" alt="day7 - LIU_访问权限 - LIU .pdf"></a></div><div><br/></div></span>
</div></body></html> 