<html>
<head>
  <title>day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instanceof</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="5844"/>
<h1>day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instanceof</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/7/17 12:35</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/8/20 12:06</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>复习:</div><div> </div><div>继承的特点：</div><div>  1.代码重用；</div><div>  2.便于维护：</div><div>       高耦合</div><div><br/></div><div>设计一个能被子类继承的类：</div><div>  1.继承层次最好控制在2-3层；(继承层次最好不要 过深)</div><div>  2.要有详细的文档说明；(说明继承时的注意事项, 重写时的规则)</div><div>  3.要封装；</div><div>         对所有用户开放 public</div><div>         只对子类开放   protected</div><div>         不允许子类重写 用final</div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------  </div><div>继承的缺点：</div><div>  1.破坏封装；</div><div>  2.高耦合。(父类的有些功能,部分子类是没有的,但也不得不继承,这就是一种高耦合的体现)</div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>组合(以及聚合)：</div><div>  体现整体和局部的关系。(继承体现的是父子之间的关系)</div><div>  语法上：局部类作为整体类的成员变量。</div><div><br/></div><div>遇到整体和局部的关系时,就可以考虑用组合来实现了,不一定什么都要用继承</div><div>举例</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>    用组合而不用继承实现:</div><div>    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>    调用方式也和继承有一点点区别:</div><div>    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>再举例用组合的情况:</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [3].png" type="image/png" data-filename="Image.png" width="384"/></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [4].png" type="image/png" data-filename="Image.png" width="763"/></div><div>---------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>抽象类：</div><div>  只约定了类具有的抽象功能，没有具体实现相应的功能。</div><div><br/></div><div>使用场合：</div><div>  1.该类没有必要创建对象；或者该类不适合创建对象；</div><div>  2.用来继承使用且只需要使用子类的对象；</div><div>  3.只需提供一个模板, 不用具体实现。</div><div>    (比如说该类的一部分方法子类继承后都必然重写,且该类没有必要创建对象,那父类就没必要具体去实现这些方<span style="font-size: unset; color: unset; font-family: unset;">法了,则定义成抽象方法即可)</span></div><div><br/></div><div>注意：</div><div>  1.<span style="color: rgb(166, 0, 196);">抽象类是不能创建对象的</span>；(一个原因是: 抽象类如果创建了对象后那肯定可以调用抽象方法,而抽象方法本来就是没有实现的,这样的话明显有问题)</div><div>  2.<span style="color: rgb(255, 0, 0);">抽象类中可以定义抽象方法也可以只定义普通方法</span>；</div><div>  3.子类：</div><div>      抽象类是可以有抽象子类的。定义<span style="color: rgb(255, 0, 0);">抽象子类</span>的方式也很简单, 只需在继承抽象父类的子类的class关键字前<span style="font-size: unset; color: unset; font-family: unset;">面加一个abstract ,  抽象子类具有和抽象父类一样的性质。</span></div><div>      <span style="color: rgb(166, 0, 196);">普通子类必须重写实现抽象父类中的所有抽象方法，但是抽象子类除外(因为抽象子类中允许抽象方法的存在)。</span>(因为普通<span style="font-size: unset; color: unset; font-family: unset;">子类如果不实现抽象方法,创建对象后调用父类的象方法的话肯定会出问题,因为抽象方法没有具体实现)</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">      </span><span style="color: rgb(255, 0, 0);">(注意, 子类只能&quot;extends 抽象类&quot;, 不能&quot;implements 抽象类&quot; , 因为抽象类只能被继承, 只有接口才能用&quot;implements&quot;关键字)</span></div><div>  4.构造器不能是抽象的；(因为构造器是创建对象,完成初始化各种值的。抽象类的普通子类创建对象时要一层层往上调用父类的构造方法, 如果父类的构造方法是抽象的,还怎么调用? 难道还要让子类连父类的构造方法也一起实现? 显然不可能,一个类不可能去帮忙实现其他类的构造方法。<span style="color: rgb(166, 0, 196);">抽象类定义构造器还有一个重要的作用就是方便直接使用匿名内部类创建子类对象(我猜的)</span>)</div><div>  5.<span style="color: rgb(166, 0, 196);">abstract 不能与 private或final或static 一起使用。</span></div><div style="margin-left: 40px;">(<span style="color: rgb(255, 0, 0);">如果是abstract的方法</span>:</div><div style="margin-left: 40px;">    如果<span style="color: rgb(255, 0, 0);">abstract的方法</span>同时被private修饰, 那么该方法对子类就不可见了,就无法重写抽象方法了; 而如果<span style="color: rgb(255, 0, 0);">abstract的方法</span>同时被final修饰,那么子类也不能重写了,定<span style="font-size: unset; color: unset; font-family: unset;">义成抽象方法就没有意义了; 而如果</span><span style="color: rgb(255, 0, 0);">abstract的方法</span><span style="font-size: unset; color: unset; font-family: unset;">能用static修饰, 那说明该抽象方法是属于类的, 能通过&quot;类名.方法名&quot;来</span><span style="font-size: unset; color: unset; font-family: unset;">直接调用,但是抽象方法并没有具体实现, 直接调用抽象方法是没有意义的。</span></div><div style="margin-left: 40px;"><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">如果是abstract的类</span></span><span style="font-size: unset; color: unset; font-family: unset;">:</span></div><div style="margin-left: 40px;"><span style="font-size: unset; color: unset; font-family: unset;">    如果</span>abstract类同时<span style="font-size: unset; color: unset; font-family: unset;">被</span>private修饰, 那么该类对于其他类来说是不可见的,因为private修饰的东西只对本类可见, 即使在同一个包里,该类也不可见; 如果abstract类同时被final修饰, 说明该类是一个最终类, 不能被继承, 显然是不合适的; 而如果abstract类同时被static修饰, <span style="color: rgb(166, 0, 196);">被static修饰的类一定是内部类</span><span style="color: rgb(121, 121, 121);">(这点我在day14里的&quot;</span><span style="color: rgb(121, 121, 121);">静态内部类</span><span style="color: rgb(121, 121, 121);">&quot;部分说明了原因)</span>, 而一个静态内部类是不能是抽象的, 否则外部类直接通过<span style="font-size: unset; color: unset; font-family: unset;">&quot;外部类名.内部类名.成员&quot;来</span><span style="font-size: unset; color: unset; font-family: unset;">直接调用内部类里的方法或属性肯定会出错,因为一个抽象类里难免会有抽象方法</span><span style="font-size: unset; color: unset; font-family: unset;">)</span></div><div><br/></div><div>抽象类使用方法:</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [5].png" type="image/png" data-filename="Image.png" width="585"/></div><div>抽象方法的正确写法(也就是不实现):</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [6].png" type="image/png" data-filename="Image.png" width="625"/></div><div>抽象方法的错误写法: (加了一对大括号的方法就是实现了, 虽然说大括号里没有内容,但这叫空实现, 和不实现不一样,空实现也是一种实现)</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [7].png" type="image/png" data-filename="Image.png" width="660"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>接口：</div><div>  一组功能的封装。</div><div>    接口的地位和类是一样的, 但它不是一个类</div><div><br/></div><div>接口的定义：</div><div><span style="color: rgb(166, 0, 196);">    (注意接口本身(不是指接口内)的访问修饰符只能有两种,一个是public,一个是默认的)</span></div><div><br/></div><div><span style="font-weight: bold;">  </span><span style="color: rgb(166, 0, 196); font-weight: bold;">访问修饰符</span> <span style="font-weight: bold;">interface 接口{ </span>       </div><div>      常量;        (这里的常量还必须是在定义时就进行初始化的（因为被static final修饰, 如果只是被final修饰, 则可以不在</div><div>                      定义时就初始化）,接口里的成员变量不管写不写修饰符,都是public static final修饰的 <span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">,不能用其他修饰符</span>)</div><div>                            举例：</div><div>                                    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [8].png" type="image/png" data-filename="Image.png" width="453"/></div><div>      抽象方法;        (不管写不写public, 都是public的。<span style="font-family: unset; font-size: unset;">接口里要定义抽象方法<font style="color: rgb(255, 0, 0);">可以不用</font>显式用abstract修饰</span>)</div><div>      <span style="color: rgb(255, 0, 0);">默认方法;  (</span>不管写不写public, 都是public的<span style="color: rgb(255, 0, 0);">。注意默认方法不是指被默认访问修饰符修饰的方法,而是该接口中</span></div><div><span style="color: rgb(255, 0, 0);">                        有默认实现的方法,</span>接口里要定义默认方法<span style="color: rgb(255, 0, 0);">必须</span>显式用default修饰<span style="color: rgb(255, 0, 0);">)</span></div><div>                    举例:</div><div>                  <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [9].png" type="image/png" data-filename="Image.png" width="449"/></div><div>      <span style="color: rgb(166, 0, 196);">静态</span>方法；    (不管写不写public, 都是public的。<span style="font-family: unset; font-size: unset;">接口里要定义静态方法<font style="color: rgb(255, 0, 0);">必须</font>显式用static修饰</span><span style="color: unset; font-family: unset; font-size: unset;">)</span></div><div>      <span style="color: rgb(166, 0, 196);">静态</span>内部类型；（如静态内部类，静态内部接口，静态内部枚举, <font style="color: rgb(255, 0, 0);">接口里的内部类型只能是静态的, 并且不管写不写public static, 都是public static的</font>）</div><div><span style="font-weight: bold;">}</span></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">在jdk8.0版本之前,接口里的成员只有常量和抽象方法,没有其他成员。上面的接口里的成员是指的jdk8.0支持的所有成员,在</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">jdk9.0时另外还多加了支持私有方法(private修饰的方法),加入这个是为了代码的重用</span></div><div><br/></div><div><br/></div><div>注意：</div><div>  1.接口不能创建对象；(一个原因是因为接口里面有抽象方法)</div><div>  2.<span style="color: rgb(166, 0, 196);">所有的成员都是public的; (接口内不能使用其他访问修饰符, 接口里的任何成员不管会不会显式写public修饰符, 都是public的(自然也包括静态内部类型, 虽然接口本身可以有两种访问修饰符--public和默认, 但接口里的内部接口即使没显示写public它的修饰符也是public的而不是默认修饰符)</span></div><div>  3.所有常量必须是 public static final修饰的;</div><div>  4.接口的使用方式：&quot;实现类&quot;实现(implements)&quot;接口&quot;   </div><div>         <span style="color: rgb(255, 0, 0);">(接口的实现很像父类的继承, 因为接口的成员(</span><span style="color: rgb(255, 0, 0);">除了静态成员)都能在实现类中直接使用,就像子类使用父类的成员那样)</span></div><div>        接口是可以有抽象实现类的, 定义<span style="color: rgb(255, 0, 0);">抽象实现类</span>的方式也很简单, 只需在实现接口的实现类的class关键字前<span style="font-size: unset; color: unset; font-family: unset;">面加一个abstract 。</span></div><div>        普通的实现类要实现接口中的所有抽象方法，但<span style="color: rgb(166, 0, 196);">抽象实现类</span>除外(因为抽象类中允许抽象方法的存在)。</div><div>  5.实现类可以同时实现<span style="color: rgb(166, 0, 196);">多个</span>接口的功能；(即多实现。实现了多个接口的话要重写实现所有接口的抽象方法)   </div><div>                举例:</div><div>            <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [10].png" type="image/png" data-filename="Image.png" width="431"/></div><div>            <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [11].png" type="image/png" data-filename="Image.png" width="671"/></div><div><br/></div><div>  6.子接口可以<span style="color: rgb(166, 0, 196);">继承(extends)</span>父接口，并且可以<span style="color: rgb(166, 0, 196);">多继承</span>。  (接口的继承相当于对接口功能的扩展,继承后,子接口毕竟还是接口,所以<span style="font-size: unset; color: unset; font-family: unset;">父接口的抽象方法当然也不用在子接口里实现)</span></div><div style="margin-left: 40px;"><span style="color: rgb(255, 0, 0);">注意: </span> <span style="font-size: 15px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: &quot;PingFang SC&quot;, &quot;Microsoft YaHei&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Java中的类是单继承的，但接口可以多继承，</span></div><div style="margin-left: 40px;"><span style="color: rgb(255, 0, 0);">(1) java中的类是单继承的</span></div><div style="margin-left: 40px;"><span style="-en-paragraph:true;"><span style="color: rgb(255, 0, 0);">如果一个类继承了两个类，但是这两个类中有相同的方法，那么子类调用，无法确定应该调用哪个方法。</span></span></div><div style="margin-left: 40px;"><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">(2) 接口可以多继承</span></span></div><div style="margin-left: 40px;"><span style="-en-paragraph:true;"><span style="color: rgb(255, 0, 0);">因为接口只有抽象方法，具体方法只能由实现接口的类实现，在调用的时候始终只会调用实现类（也就是子类覆盖的方法）的方法（不存在歧义），因此即使继承的两个接口中的方法名是一样的，最终调用的时候也都是调用实现类中的那个方法，不会产生歧义；</span></span></div><div style="margin-left: 40px;"><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">而又因为接口只有静态的常量，但是由于静态变量是在编译期决定调用关系的，即使存在一定的冲突也会在编译时提示出错；而引用静态变量一般直接使用类名或接口名，从而避免产生歧义，因此从接口的变量是来看也是可以通过的。</span></span></div><div>            多继承时举例</div><div>            <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [12].png" type="image/png" data-filename="Image.png" width="619"/></div><div>           此时下面只需实现一个接口即可,但是里面包含的所有抽象方法都要实现(包括Socket接口继承而来的抽象方法<span style="font-size: unset; color: unset; font-family: unset;">)</span>,也就是说直接父类(接口)和间<span style="font-size: unset; color: unset; font-family: unset;">接父类(接口)的抽象方法都要实现</span></div><div>            <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [13].png" type="image/png" data-filename="Image.png" width="654"/></div><div><br/></div><div><br/></div><div>举例: (京东商城实现银行的网上支付功能)</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [14].png" type="image/png" data-filename="Image.png" width="589"/></div><div><br/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">注意,下面的两种写法,在接口里,是等价的。在接口里,方法前面不加任何修饰符就相当于修饰符是public abstract的。</span></div><div><span style="color: rgb(255, 0, 0);">同理, 在接口里, 默认方法和静态方法也可以省略public不写,但都是等价于加上public的写法。</span></div><div><span style="color: rgb(166, 0, 196);">同时也不允许在接口中出现其他访问修饰符。</span></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [15].png" type="image/png" data-filename="Image.png" width="580"/></div><div>下面这个例子也能说明上面这个问题, 如果接口中的方法不加任何访问修饰符表示的是默认访问修饰符,那么实现类中<span style="font-size: unset; color: unset; font-family: unset;">改成protected修饰应该不成问题,因为子类的访问权限一定不能比父类低(protected访问范围显然高于默认),但是</span><span style="font-size: unset; color: unset; font-family: unset;">这里却报错了,并且把protected去掉,变成默认修饰符依然报错,错误提示说要把访问修饰符改成public。所以说明</span><span style="font-size: unset; color: unset; font-family: unset;">接口中的该方法就是public修饰的</span></div><div>        (子类的访问权限一定不能比父类低,这个原理虽然因为接口里的所有成员都是public的这个前提条件而不适用于接<span style="font-size: unset; color: unset; font-family: unset;">口,但假设我们开始并不知道这个,那么实现类和接口的访问权限一样当然不成问题,所以两个都是默认访问修饰符</span><span style="font-size: unset; color: unset; font-family: unset;">修饰应该没啥问题, 但是却报错了,说明不是这么回事)。</span></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [16].png" type="image/png" data-filename="Image.png" width="677"/></div><div><br/></div><div><span style="color: rgb(255, 0, 0);">同理, 在接口里, 默认方法和静态方法也可以省略public不写,但都是等价于加上public的写法</span></div><div><span style="color: rgb(255, 0, 0);"><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [17].png" type="image/png" data-filename="Image.png"/></span></div><div><span style="color: rgb(255, 0, 0);">同理,常量在接口里也有等价写法。在接口里, 下面方框中的两种写法是等价的:</span></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [18].png" type="image/png" data-filename="Image.png" width="718"/></div><div><br/></div><div><br/></div><div>实现接口其实有些类似于继承父类, 像接口中定义的常量和默认方法,也是能被实现类直接使用的, 如下图中的红框,就像子类使用<span style="font-size: unset; color: unset; font-family: unset;">父类的成员一样。但是</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">接口中的静态方法是不能在子接口和它的实现类里直接使用的, 而是只能通过&quot;类名(或接口名).方法名&quot;</span><span style="font-size: unset; color: unset; font-family: unset;">这种方式来调用, 这就跟普通的类的静态成员在别的类中的调用方式一样了,这说明接口中的静态方法根本没有被包含到子接口和</span><span style="font-size: unset; color: unset; font-family: unset;">实现类中去。虽然</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">继承父类时</span><span style="font-size: unset; color: unset; font-family: unset;">静态方法也会受访问修饰符的限制,在private和默认修饰符时继承有一定限制, 但在访问修饰符允</span><span style="font-size: unset; color: unset; font-family: unset;">许的条件下还是可以直接在子类中使用的; 但</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset; font-weight: bold;">接口的静态方法</span></span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">根本就不会包含在子接口和它的实现类中</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">,所以接口的静态方法在子类</span></span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">和实现类中调用时只能用像调用普通类中的静态方法一样</span><span style="font-size: unset; color: unset; font-family: unset;">,如下面的绿框内容:</span></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [19].png" type="image/png" data-filename="Image.png" width="595"/></div><div><br/></div><div><br/></div><div>当一个类同时实现两个接口(或一个子接口同时继承两个接口)时,两个接口中有同名的常量时,可以直接通过&quot;接口名.常量名&quot;来</div><div>    区分,因为接口的常量都是static的</div><div>而显然,对于两个接口中同名的静态方法时,不用区分,不管有没有重名, 使用时就必须用&quot;接口名.方法名&quot;来调用。</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [20].png" type="image/png" data-filename="Image.png" width="598"/></div><div>当一个类同时实现两个接口(或一个子接口同时继承两个接口),两个接口中有同名的默认方法时,这时候就要求实现类(或子接口中)必</div><div>    须重写该同名默认方法, 重写时主要是指定调用该默认方法时,调用的是哪个父接口中的。如下图。</div><div>并且,可以发现, 其实super关键字的完整写法是&quot;类名(或接口名).super()&quot;或者&quot;类名(或接口名).super.方法名&quot;这样的,也就是</div><div>    说super前面是带有它对应的类名(或接口名)的,只是在单继承时,父类的类名当然可以省略,直接写super即可, 而只有在接口</div><div>    的多继承和接口的多实现的情况下,才必须区分是哪个父接口<span style="font-weight: bold;">.</span>super 。</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [21].png" type="image/png" data-filename="Image.png" width="540"/></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [22].png" type="image/png" data-filename="Image.png" width="352"/></div><div>当一个类同时实现两个接口(或一个子接口同时继承两个接口),如果是两个抽象方法同名, 那么区不区分无所谓, 因为抽象方法都是要重写的, 直接在实现类中正常重写就行。实现类中调用的该同名方法必然是自己重写过的,也就是说实现类的对象调用该同名方法时,调用的是自己的方法,而且因为接口不能创建对象,所以抽象方法同名时可以区分是哪个父接口的抽象方法,但没必要区分。</div><div>要区分的话,区分的方法如下: (用匿名内部类来区分)</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [23].png" type="image/png" data-filename="Image.png" width="574"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>抽象类 和 接口 的异同：</div><div><br/></div><div>相同点：</div><div>  1.都不能创建对象；</div><div>  2.都能定义抽象方法；(注意只有抽象类和接口中可以有抽象方法。抽象实现类也属于抽象类)</div><div>  3.用子类(或者实现类)继承(或实现)使用；</div><div>  4.普通子类(或普通实现类)要实现抽象父类(或接口)中的所有抽象方法, 抽象的子类(或抽象实现类)除外</div><div><br/></div><div>不同点：</div><div>  抽象类：</div><div>    提供了模板的作用。(模板已经提供了一部分的功能, 而子类还会在此基础之上再增加功能,既然是继承,肯定是要<span style="font-size: unset; color: unset; font-family: unset;">加点功能的,子类也当然要有区别于父类的独特的功能, 不然的话定义个子类继承父类还有什么意义,子类不</span><span style="font-size: unset; color: unset; font-family: unset;">加功能的话直接用父类不就好了)</span></div><div>    子类和父类的关系，是继承的关系,并且是单一继承。</div><div>  接口：</div><div>    一组规则。(最重要的是定义了一组规则,遵守这些规则, 你就能用这个接口, 并不要求实现类需要再添加功能)</div><div>    接口适用于不同的程序之间的调用, 同样也适用于同一程序,对于同一程序来说, 接口的作用是为了降低模块(类)之间的耦合连接。<span style="font-size: unset; color: unset; font-family: unset;">而继承是高耦合的,  父类的功能在所有子类中都是平等拥有的,所以每个子类在父类中继承到的东西都是一样的, 而接口就</span><span style="font-size: unset; color: unset; font-family: unset;">是降低这种耦合连接的, 可以提取出父类中的那些不是所有子类都需要的功能作为接口,需要这个功能的就去实现这个接</span><span style="font-size: unset; color: unset; font-family: unset;">口,不需要的就直接继承父类即可, 降低类之间的耦合程度。比如前面所说的例子: 鸵鸟是鸟类的子类,  但是鸵鸟不会飞, 所</span><span style="font-size: unset; color: unset; font-family: unset;">以可以把&quot;飞&quot;这个功能写到一个接口里, 会飞的子类就去继承这个接口即可。所以接口的使用更加灵活</span></div><div> </div><div> </div><div>一个类在继承的同时实现接口,写法一定是先写继承再写实现</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div>看一个关于继承和实现有趣的例子: </div><div>    某个类继承一个类的同时实现接口, 那么继承的优先级高于实现, 也就是说, 继承的父类中和实现的接口中如果有同名的成员时, 继承的成员会直接覆盖掉接口的成员而不报错,这也是为什么写代码时继承(extends)写在前面而实现(implements)写在后面的原因。</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [25].png" type="image/png" data-filename="Image.png" width="665"/></div><div><br/></div><div><br/></div><div>注意: 就像类有子类父类, 有直接子类和间接子类、直接父类和间接父类之分一样, 接口也有子接口父接口, 有直接子接口和间接子接口、直接父类和间接父类之分; <span style="color: rgb(255, 0, 0); font-weight: bold;">同时接口的实现类还有直接实现类和间接实现类!!!也即是说接口的实现类不止可以有一层, 可以有多层继承结构。</span><span style="color: rgb(166, 0, 196); font-weight: bold;">间接实现类</span><span style="color: rgb(255, 0, 0); font-weight: bold;">是指直接实现类</span><span style="color: rgb(166, 0, 196); font-weight: bold;">实现了(implement)</span><span style="color: rgb(255, 0, 0); font-weight: bold;">接口后,然后直接实现类被一直</span><span style="color: rgb(166, 0, 196); font-weight: bold;">继承(extend)</span><span style="color: rgb(255, 0, 0); font-weight: bold;">,这就是间接实现类, 接口里的方法会被一直继承下去。</span></div><div>我判断有间接实现类存在的依据如下图: 就是在泛型参数的上限设置为如下形式后, Demo3只继承了Demo2而没有实现接口的情况下, 既然还能当实际类型参数使用(如绿框),说明Demo3同时也属于Ia和Ib两个接口的实现类, 这里并不是直接实现的,而是间接实现的这两个接口, 所以可以称为间接实现类。</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [26].png" type="image/png" data-filename="Image.png" width="558"/></div><div>从下图则可以看出接口里的方法也会被间接实现类继承到, 会一直继承下来。</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [27].png" type="image/png" data-filename="Image.png" width="437"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>类之间的关系：</div><div><br/></div><div>UML建模语言</div><div>类图：</div><div>    类域: 就是指成员变量,也就是属性</div><div>    类图中的访问修饰符的表示方式：  </div><div style="margin-left: 40px;">     &quot;-&quot; 表示private</div><div style="margin-left: 40px;">       什么都不加表示默认访问修饰符</div><div style="margin-left: 40px;">     &quot;#&quot; protected</div><div style="margin-left: 40px;">     &quot;+&quot; public</div><div style="margin-left: 40px;">    如:</div><div style="margin-left: 40px;">     <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div style="margin-left: 40px;"><br/></div><div style="margin-left: 40px;"><br/></div><div><span style="color: rgb(166, 0, 196);">下面是类间的各种关系:</span></div><div><br/></div><div>泛化：继承.</div><div>      子类是父类</div><div>      语法：extends</div><div>                <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [29].png" type="image/png" data-filename="Image.png"/> </div><div>实现：</div><div>    类和接口</div><div>    语法：implements</div><div>                <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [30].png" type="image/png" data-filename="Image.png" width="187"/></div><div><br/></div><div>依赖：(A类动作行为的实现需要依赖B类来实现, 就可以说<span style="color: rgb(158, 0, 243);">A类依赖于B类</span>)</div><div>    依赖是一种&quot;使用&quot;的关系。</div><div>    语法上一般是：</div><div style="margin-left: 40px;">        class A类{</div><div style="margin-left: 40px;">            方法名（B类 B类对象）{}</div><div style="margin-left: 40px;">        }</div><div style="margin-left: 40px;"></div><div>    比如说动物和食物就是依赖的关系,因为动物&quot;吃&quot;这个动作(方法)就要依赖于食物 也就是把食物作为参数传入&quot;吃&quot;这个方法</div><div style="margin-left: 40px;">    class 动物{</div><div style="margin-left: 40px;">        void 吃(食物）{  } </div><div style="margin-left: 40px;">    }</div><div style="margin-left: 40px;">在类图中,是依赖者指向被依赖者(<span style="color: rgb(158, 0, 243);">A类指向B类</span>)</div><div>    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [31].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>关联：</div><div>    是一种&quot;拥有&quot;的关系。(比如说学生拥有课程)</div><div>    语法上：体现为成员变量, 一般是被拥有者作为拥有者类里的一个成员变量</div><div>    根据类与类之间对象的数目可有分为：</div><div style="margin-left: 80px;">一对一的关系：比如车和车牌</div><div style="margin-left: 80px;">一对多的关系：比如球队和球员</div><div style="margin-left: 80px;">多对多的关系：比如老师和学生</div><div>    比如学生拥有课程:(箭头由拥有者指向被拥有的一方)</div><div>    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [32].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>聚合（聚集）：是一种强关联关系。</div><div>    体现的是整体和局部的关系，并且局部离开了整体可以独立存在。(比如说人群和人, 人离开人群也能独立存在)</div><div>    语法上：局部类作为整体类里的一个成员变量而存在</div><div>    比如说车和车门,箭头由局部指向整体: </div><div>    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [33].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>组合：强聚集。(组合是一种更强的聚集关系)</div><div>    也是体现了整体和局部的关系，但是局部离开了整体不可以独立存在。(比如人和心脏,心脏不能作为一个个体独立存在)</div><div>    语法上：局部类作为整体类里的一个成员变量而存在</div><div>    比如说狼和心脏, 箭头有局部指向整体:</div><div>    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [34].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>举一个画类图的例子:</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [35].png" type="image/png" data-filename="Image.png" width="867"/></div><div>具体类图如下:</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [36].png" type="image/png" data-filename="Image.png"/></div><div>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>多态：</div><div>  即一种物质，多种形态。    </div><div>    程序中的多态是指同一个引用类型,使用不同的实例而执行不同操作</div><div><br/></div><div>多态的特点：</div><div>  1.一定是对方法进行了 重写；</div><div>  2.写法一定是: 父类引用 --&gt; 子类对象    (通常方式是: 父类 父类对象 = new 子类();  )</div><div>                        接口引用 --&gt; 实现类对象    (通常方式是: 接口 接口对象 = new 实现类();  )</div><div>    <span style="color: rgb(255, 0, 0);">多态也正好说明了: 引用的类型和对象的类型不一定就是一样的(比如说可以定义一个父类数组,里面的引用的类型都是父类</span></div><div><span style="color: rgb(255, 0, 0);">                                                的类型, 但是这些引用所指向的对象类型却可以是多种多样的,可以是父类本身的,也可以是该</span></div><div><span style="color: rgb(255, 0, 0);">                                                父类的所有子类的)</span></div><div><br/></div><div>多态的实现形式:  类多态、接口多态、参数多态(如 Object类的 equals(Object object)方法就是一种参数多态)</div><div>多态的结果：</div><div>    子类独特的功能被屏蔽，调用不了。(所以应用多态可以屏蔽掉子类之间的差异性,只调用所有子类共有的功能)</div><div><br/></div><div>举例: (下面这就是一个多态的使用方式, 可以看到父类引用指向了子类对象后,就不能调用子类独有的方法了,会报编译错误,</div><div>            不过这也是在笔记&quot;day10&quot;里提到的自动类型转换与强制类型转换, 子类转换为父类对象后,编译器就默认car引用的是</div><div>            一个父类对象,父类里面没有子类独有的方法,编译器当然不会允许car调用咯)</div><div>    当然, 父类引用指向子类对象的过程也可以分开写,写成下面形式也是一样的:</div><div>                Car1 car1 = new Car1();</div><div>                TrafficTool car = car1; </div><div><br/></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [37].png" type="image/png" data-filename="Image.png" width="694"/></div><div><br/></div><div><br/></div><div>参数多态 举例: 参数里直接写父类的引用也可以实现某个方法的多态</div><div>    首先是类图,各个类之间的关系如下,按照类图来设计类:</div><div>    <img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [38].png" type="image/png" data-filename="Image.png" width="648"/></div><div>    看treatment()方法也可以看出为什么参数多态是一种运行时多态, 因为对象是在运行期来决定对象的类型的,而treatment()</div><div>        方法的参数pet就只是个引用而已, 光看代码你不知道pet将会调用哪个类的方法, 只有等运行期才知道是什么类的对象传</div><div>        给pet, 所以叫做运行时多态。</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [39].png" type="image/png" data-filename="Image.png" width="929"/></div><div>    不用多态时PetHospital类是这样写的: (这样的话就是方法的重载了,这样的话如果Pet类有很多子类的话就会有很多重</div><div>            载, 造成代码的冗余,所以为什么要用参数多态的好处就体现了出来)</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [40].png" type="image/png" data-filename="Image.png" width="496"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>类型转换：</div><div>    引用类型转换和基本类型转换是不一样的, 引用类型转换只是名义上类型转换了(或者说只是对象的引用变量的类型变了),实际上堆里的对象是根本没有改变的,原来是什么类的对象,转换后还是什么类的对象</div><div>    </div><div>1.向上类型转换：</div><div>   子类  --&gt;  父类</div><div><br/></div><div>2.向下类型转换：</div><div>   父类  --&gt;  子类</div><div>  书写格式: （子类类型）父类对象</div><div>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>运算符 instanceof</div><div>用来判断某个对象是否是 某类 或 某接口类型。</div><div>    是 返回true，不是 返回false。</div><div><span style="color: rgb(166, 0, 196);">注意: 如果 类B 是 类A 的子类或 类B 是 接口A 的实现类(或者其他直接或间接的继承、实现关系), 那么, 用  &quot;B的对象 instanceof A &quot; , 结果会返回true。</span></div><div>  </div><div>   </div><div>如前面的参数多态的例子中, PetHospital类改成如下形式 , 则可以在多态中调用子类独有的方法:</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [41].png" type="image/png" data-filename="Image.png" width="769"/></div><div>如果有如下语句:</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [42].png" type="image/png" data-filename="Image.png"/></div><div>则Duck类的对象即是 Animal类型 也是 Terrestrial类型 , 实例化一个duck对象后:</div><div> Duck duck = new Duck();</div><div>则下面两条语句都会输出true; </div><div>System.out.println(duck instanceof Animal);</div><div>System.out.println(duck instanceofTerrestrial);</div><div>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>再来看一个多态的例子</div><div>首先是类图如下:</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [43].png" type="image/png" data-filename="Image.png" width="716"/></div><div>根据类图设计类: (重点注意红框里的设计)</div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [44].png" type="image/png" data-filename="Image.png" width="476"/></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [45].png" type="image/png" data-filename="Image.png" width="590"/></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [46].png" type="image/png" data-filename="Image.png" width="614"/></div><div><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/Image [47].png" type="image/png" data-filename="Image.png" width="548"/></div><div><br/></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手写与上传资料分割线</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—————————————————————</span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><br/></div><div><br/></div><div><a href="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/day9 - LIU_抽象类和接口.pdf"><img src="day11-组合聚合、抽象类与接口、类图以及类之间的各种关系、多态、类型转换、instan_files/82662a48a3c44874108db2ac1df716e5.png" alt="day9 - LIU_抽象类和接口.pdf"></a></div><div><br/></div></span>
</div></body></html> 