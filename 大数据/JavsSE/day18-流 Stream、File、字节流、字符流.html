<html>
<head>
  <title>day18-流: Stream、File、字节流、字符流</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="6651"/>
<h1>day18-流: Stream、File、字节流、字符流</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/9/10 14:48</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/3/28 11:21</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>Stream</div><div>流</div><div>Stream是jdk8.0提出的新的功能, 主要是对<span style="color: rgb(166, 0, 196);">集合</span>进行一些统计性的操作的(如最大值、最小值、平均值之类的)</div><div>(与IO流不同,IO流是对文件的读写操作,Stream流跟文件没有任何关系。)</div><div><br/></div><div>Steam流的特点是计算速度特别快,但用完一次很快就消耗掉了,不能再使用了,所以一般是一次性的操作。如果是频繁的、重复性的操作,不建议使用Stream</div><div><br/></div><div><br/></div><div>Stream的父接口是BaseStream。</div><div>BaseStream的所有子接口有:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>也就是说这个流主要支持的类型是:Double、Int、Long和引用类型。前三个是对三种数据类型进行操作, 而最后一个是对引用类型进行操作。</div><div><br/></div><div><br/></div><div><br/></div><div>Stream也是一个接口, 对于一个接口来说, 当然不能new创建对象, Stream提供了一个生产者(建造者)builder()方法。通过builder()方法后就可以链式的调用add方法向Stream流里面添加数据。添加完数据再调用build()方法, 流才算创建好了</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>1.末端方法(流调用该方法对数据操作完了之后,会被消耗掉, 会被立刻释放掉, 该流就不能再被二次使用了,比如调用了max()方法求得了最大值, 如果再用这个流调用min()方法想求最小值,则会抛出异常)</div><div>    常见的末端方法如下:</div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [2].png" type="image/png" data-filename="Image.png" width="363"/></div><div>max()、min()、sum()、average()、count()、allMatch()、anyMatch()都是末端方法</div><div>注意max()、min()、average()方法返回的不是流数据原来的数据类型(如int、double这些),而是OptionalXXX类型(如OptionalInt、OptionalDouble这些,传的流的是什么类型的数据,返回的就是Optional什么类型)。所以如果需要转换为原来的数据类型,需要再调用getAsXXX()方法(如getAsInt()、getAsDouble()等)。</div><div><br/></div><div>allMatch(某条件): 是否所有的元素都符合某条件, 符合返回true, 否则返回false。</div><div>anyMatch(某条件): 是否至少有一个元素符合某条件,是返回true, 否则返回false。</div><div>其中参数&quot;某条件&quot;传入的是Predicate函数式接口的实现类对象, 如果流是IntStream, 则接口也相应变成IntPredicate。Predicate是一个泛型接口,是一个函数式接口(和day16的Predicate一样),该接口是一个过滤器。该接口的抽象方法是boolean test(T t); t就是当前集合的元素, 对这个元素进行判断,判断该元素是否符合某条件。</div><div>allMatch(某条件)方法应用举例:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>anyMatch(某条件)方法应用举例:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>以上所有末端方法的应用举例:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2.中间方法(流调用该方法对数据操作完了之后,会返回一个新的流,这个新的流又可以调用别的方法进行相应的操作了(新的流和原来的流的元素可以不一样))</div><div>    常见的中间方法如下:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>filter(某条件): 按照某条件过滤数据, 返回符合某条件的数据形成的新的流。其中参数&quot;某条件&quot;传入的是Predicate函数式接口的实现类对象</div><div>map(某条件)/mapToInt(某条件)/mapToLong(某条件)/mapToDouble(某条件): 按照某条件映射流中的元素, 返回的是映射后的数据形成的新的流。mapToXXX表示的是将流中的元素映射为XXX类型。其中参数&quot;某条件&quot;传入的是Function&lt;T, R&gt;函数式接口的实现类对象, 其抽象方法是: R apply(T t),  表示用R类型的返回值来映射流中的某个元素t, 也就是说传入apply()方法的元素是t, 返回的是其他类型的值, 用返回值来替换掉元素t, 这就是映射。(其中T是流中元素的类型, T和R可以是不同的类型, 也可以是相同的类型)</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>如果要映射为Int类型, 则调用mapToInt()方法如下图, 函数式接口变为ToIntFunction&lt;T&gt; , 抽象方法变为 int applyAsInt(T  value), value表示流中的元素。</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [8].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>distinct(): 去除流中重复的元素, 返回去重后的元素组成的流</div><div>sorted(): 排序, 前提是排序的元素的类已经实现了Comparable接口, 因为这里的sorted()方法不能传参, 所以只能使用默认的Comparable排序,而不能使用Comparator。</div><div>peek(某条件): peek(某条件)的作用和forEach(某条件)是一样的。需要的参数也和forEach()是一样的, 都是函数式接口Consumer的实现类。只不过peek()是中间方法, forEach()是末端方法。</div><div>limit(int 几个): 返回原来的流中的前几个元素形成的新流</div><div>skip(int 几个): 跳过原来的流中的前几个元素, 返回剩下的元素形成的新流 </div><div><br/></div><div>和上面直接使用流来调用方法不同, 接下来的例子使用流的方法对集合进行操作(也就是用&quot;集合.stream()&quot;先返回一个流, 再用该流来调用流的方法。也可以用同样的方法对数组进行操作)。所以需要注意的是, 并不是说直接使用流就不能调用中间方法,使用这些流一样可以调用这些中间方法:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>注意: DoubleStream、LongStream、IntStream、Stream中,选用哪种流主要看流中的元素是什么类型, 如果是元素是int型的, 那自然是用IntStream, 然后流后面调用方法时使用的自然也是对应的int的方法, 比如map()方法自然就是使用mapToInt(某条件)了, 还有allMatch(某条件)方法,其中参数&quot;某条件&quot;传入的参数自然也就变成了IntPredicate函数式接口的实现类对象。</div><div><br/></div><div><br/></div><div><br/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------</div><div>File:</div><div>  对文件和 目录的一个封装。需要注意的是File对象可以是文件, 也可以只是一个目录。也就是说File对象也可以表示为目录</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div> 也就是说File类不涉及到对文件里的具体内容的操作。</div><div>File类的构造方法有很多:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div>最简单的构造方法就是: File(String), 其中String类型的参数就是&quot;文件所在的目录+文件名&quot;(同时需要注意参数也可以只是目录)。以下两种写法都是正确的:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [12].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(255, 0, 0);">&quot;文件的目录+文件名&quot;合起来就叫做&quot;文件路径&quot;, 也就是说文件路径=文件目录+文件名。</span></div><div>也可以写成如下形式。这样写的话就是用的相对路径的形式, 上图就是绝对路径的形式。默认在eclipse中的相对路径形式是相对于当前项目(project)所在的本地路径。并且相对路径的文件创建成功后会在项目中显示出来。</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>其他构造方法的写法:</div><div>构造器File(String, String): 第一个参数是文件目录, 第二个参数是文件名</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>构造器File(File, String):  先生成一个只有&quot;文件目录&quot;的File对象(因为前面说了,File对象也可以是一个文件目录,不是说File对象就一定是表示文件)</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">File里的成员方法有的是对文件进行操作的, 有的是对目录进行操作的, 有的既可以对文件, 也可以对目录进行操作, 下面按照不同的操作对这些成员方法进行分类(当然实际使用时, 这些方法都是可以直接对File对象进行使用的, 不管该对象是目录对象还是文件对象)</span></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">即可以对文件进行操作又可以对目录进行操作的方法:</span></div><div>    exists(): 判断文件或目录是否在本地文件系统中存在。存在返回true, 否则返回false。</div><div>    delete():  删除文件或目录。仅当文件或目录删除成功时返回true, 其他情况返回false。</div><div>    .......</div><div><br/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">对文件进行操作的方法：</span></div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [16].png" type="image/png" data-filename="Image.png" width="450"/></div><div>    createNewFile(): 创建一个新文件。创建成功返回true, 该文件已经存在返回false(文件名和文件路径已经在创建File对象时给出,所以不用传参)        </div><div>    getName(): 返回文件名。</div><div>    getPath():返回文件路径。如果构造File对象时传入的参数是绝对路径, 则返回的就是绝对路径; 如果构造File对象时传入的参数是相对路径,返回的就是相对路径。</div><div>    getAbsolutePath():返回文件的绝对路径。不管构造File时传入的参数是绝对路径还是相对路径,返回的就是该文件的绝对路径。</div><div>    getParent(): 返回文件的父路径(父路径就是指除了文件名以外的文件路径,也就是前面说的“文件目录”)。如果构造File时传入的参数是相对路径, 则返回null。</div><div>    canRead(): 判断文件是否可读(访问)。是返回true, 否返回false。</div><div>    canWrite(): 判断文件是否可写(修改)。是返回true, 否返回false。</div><div>    isFile(): 判断是否是文件。是返回true, 否返回false。</div><div>    long lastModified(): 返回文件最后修改的时间。返回的是long类型的毫秒形式的时间。ps: 很多方法得到的时间都是显示这种形式, 原因是: 这种形式的时间方便用户自己格式化为自己喜欢的形式, 其次这种形式的时间能防止用户随意修改。</div><div>    long length(): 返回文件里的字节数。</div><div>   </div><div>    </div><div><span style="color: rgb(166, 0, 196);">对目录进行操作的方法：</span></div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [17].png" type="image/png" data-filename="Image.png" width="502"/></div><div>    isDirectory(): 判断是否是目录。是返回true, 否返回false。</div><div>    String [] list(): 返回该目录下的所有文件和子目录的名称组成的String数组。</div><div>    String [] list(过滤器): 按照过滤器的方法筛选出符合的<span style="color: rgb(166, 0, 196);">文件名和子目录名</span>。返回的是符合条件的文件名组成的String数组。</div><div>        其中过滤器是函数式接口FilenameFilter的实现类对象, FilenameFilter是一个文件名过滤器, 该过滤器会保留目录下的文件,也会保留子目录。 FilenameFilter的抽象方法是boolean accept(File dir, String name), dir是当前的文件目录, name是当前目录下的某个文件名, 返回true表示符合条件, false表示不符合条件。使用方法如下<span style="font-size: unset; color: unset; font-family: unset;">:</span></div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [18].png" type="image/png" data-filename="Image.png" width="550"/></div><div>    File [] listFiles():  返回该目录下的所有文件和子目录组成的File数组(返回的数组类型是File主要是便于对文件或子目录做进一步操作)。</div><div>    File [] listFiles(过滤器): 该方法也有FilenameFilter的过滤器, 效果和String [] list(过滤器)一模一样,只不过返回的是File类型的数组。而 File [] listFiles(过滤器)方法还有一个过滤器, 叫FileFilter, 是一个文件过滤器, 也是一个函数式接口, 抽象方法是boolean accept(File pathname); pathname是文件目录。该过滤器同样也是文件和目录都可以被筛选到。返回true表示符合条件, false表示不符合条件。使用方法如下(打印的效果和上图打印的效果相同): </div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [19].png" type="image/png" data-filename="Image.png" width="572"/></div><div>    mkdir(): 创建一个本地文件夹(目录)。但如果父目录不存在, 会创建失败, 也就是说不会级联创建目录。创建成功返回true, 否则返回false。</div><div>    mkdirs(): 创建一个本地文件夹(目录)。但如果父目录不存在, 会级联的创建父目录。创建成功返回true, 否则返回false。</div><div><br/></div><div>--------------<span style="font-size: unset; color: unset; font-family: unset;">--------------------------</span>--------------<span style="font-size: unset; color: unset; font-family: unset;">--------------------------</span>--------------<span style="font-size: unset; color: unset; font-family: unset;">--------------------------</span></div><div>流 ： (接下来说的流是文件流(IO流),区别于前面的Stream流。说白了,流就是: 比如读取字符串时, 就是把一个字符串拆分成一个一个的字节(或字符)组成一个集合, 然后从内存存入磁盘或者从磁盘取出到内存)</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [20].png" type="image/png" data-filename="Image.png" width="497"/></div><div><br/></div><div>分类：</div><div><br/></div><div>按照流的运动方向, 把流分为：</div><div>    输入流 (读) ： 磁盘文件 -&gt;  内存 </div><div>    输出流 (写)：  内存  -&gt;  磁盘文件</div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [21].png" type="image/png" data-filename="Image.png" width="480"/></div><div>  按照流的数据类型, 把流分为：</div><div>      字节流：是以字节为单位, 进行读写(输入输出)操作</div><div>              字节流适用于任何文件,因为任何文件最终都是二进制的形式</div><div>      字符流：是以 字符为单位(1字符=2字节 ), 进行读写(输入输出)操作</div><div style="margin-left: 40px;">       字符流只适用于文本文件,其他类型的文件是处理不了的, 文本文件用字符流效率更高</div><div>  按照流的功能, 把流分为：</div><div>      节点流：直接操作数据源(直接接触到磁盘,进行读或写)。</div><div>      处理流(或叫 包装流/过滤流)：不直接接触数据源。包装流就是对节点流进行包装, 也就是说包装流要用节点流的对象来传入包装流的构造方法来创建包装流对象。(包装是因为节点流的功能有限, 相当于再把节点流封装一下, 提供更多的功能或者提高效率)。<span style="color: rgb(255, 0, 0); font-weight: bold;">记住: </span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); color: rgb(255, 0, 0); font-family: &quot;Courier New&quot;; font-weight: bold;">包装后,只是功能更多了而已, 真正进行读或写(如写磁盘)的还是底层的被包装的流(比如说真正进行写磁盘操作的还是底层</span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); color: rgb(255, 0, 0); font-family: &quot;Courier New&quot;; font-weight: bold;">被包装</span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); color: rgb(255, 0, 0); font-family: &quot;Courier New&quot;; font-weight: bold;">流的write方法, 而不是包装流的write方法</span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); color: rgb(255, 0, 0); font-family: &quot;Courier New&quot;; font-weight: bold;">)</span></div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [22].png" type="image/png" data-filename="Image.png" width="504"/></div><div>    </div><div> </div><div><br/></div><div><br/></div><div>--------------<span style="font-size: unset; color: unset; font-family: unset;">--------------------------</span>--------------<span style="font-size: unset; color: unset; font-family: unset;">--------------------------</span>--------------<span style="font-size: unset; color: unset; font-family: unset;">--------------------------</span></div><div>字节流：</div><div>  以字节为单位进行读写。</div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [23].png" type="image/png" data-filename="Image.png" width="587"/></div><div>    字节流的类结构如下:</div><div>  <img src="day18-流 Stream、File、字节流、字符流_files/Image [24].png" type="image/png" data-filename="Image.png" width="533"/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">流的类的命名方式是: 前中缀加起来是该流的功能; 中缀(Input和Output是指输入和输出; 后缀(如Stream、Reader等)是指流的种类(Stream是指字节流, Reader和Writer是指字符流) </span></div><div>    字节流有两个抽象父类: InputStream和OutputStream, 分别是输入流和输出流。</div><div>    需要注意的是FileInputStream和FileOutputStream这两个类是字节流的节点流, 其他类都是包装流(处理流), 都是对这两个类进行了不同程度的包装。</div><div>    FilterInputStream和FilterOutputStream是一对过滤流, 这对过滤流没有提供太多的功能, 一般用的还是它们的子类: </div><div style="margin-left: 40px;"><span style="font-size: unset; color: unset; font-family: unset;">(1)DataInputStream和DataOutputStream是以不同数据类型的形式对数据进行读写。</span></div><div style="margin-left: 40px;"><span style="font-size: unset; color: unset; font-family: unset;">(2)BufferedInputStream和BufferedOutputStream是缓冲流,缓冲流会提供一个缓冲区(缓冲区说白了就是一个数组), 也就是将文件内容缓冲到内存缓冲区里(也就是缓冲到数组里),这样的话比操作磁盘效率更高, 所以这对流的作用是为了提高读写速度和操作效率。</span></div><div style="margin-left: 40px;"><span style="font-size: unset; color: unset; font-family: unset;">(3)PrintStream是用来打印输出的, 只有Output, 没有Input。用来打印输出字节流(注意打印的是字节流,不是字符流)。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    ObjectInputStream和ObjectOutputStream是按照一个一个对象进行读写操作的流(通过序列化和反序列化)。</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    </span><img src="day18-流 Stream、File、字节流、字符流_files/Image [25].png" type="image/png" data-filename="Image.png" width="210"/></div><div><br/></div><div>----------------------------------------------------------------------------------------------------------</div><div><br/></div><div>1.文件字节流(文件流) :是字节流的节点流(其他字节流都是包装流),分为下面两个流:</div><div>    FileInputStream</div><div>    FileOutputStream</div><div>    FileInputStream的构造器如下: (一般使用较多的是构造器传参为File或String类型)</div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [26].png" type="image/png" data-filename="Image.png"/></div><div>    FileOutStream的构造器如下: <span style="color: rgb(166, 0, 196);">(有第二个参数boolean的重载中, boolean表示的是: 如果文件已经存在,以什么方式写入文件, false是覆盖原文件,  true是追加到文件尾, 默认是false)</span></div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [27].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>2.转换字符流：</div><div>  下面两个是转换字符流</div><div>  InputStreamReader : 把输入的字节流转换为输入字符流</div><div>  OutputStreamWriter :把输出的字节流转换为输出字符流</div><div><br/></div><div>3.缓冲字节流(缓冲流)：(  缓冲流是自带缓冲区的(默认的缓冲区大小是8192字节<span style="font-size: unset; color: unset; font-family: unset;">)，一次性读或写批量内容, </span><span style="font-size: unset; color: unset; font-family: unset;">提高效率,</span><span style="font-size: unset; color: unset; font-family: unset;"> 而不是一次性只读一个字节, </span><span style="font-size: unset; color: unset; font-family: unset;">)</span></div><div>  BufferedInputStream: 带有&quot;读缓冲区&quot;的字节流</div><div>  BufferedOutputStream: 带有&quot;写缓冲区&quot;的字节流</div><div>    <span style="color: rgb(166, 0, 196);">使用</span><span style="color: rgb(166, 0, 196);">BufferedOutputStream需要注意, 写文件完之后, 一定要使用其flush()方法刷新缓冲区, 否则可能会没有写文件成功。从&quot;写缓冲区&quot;写入到文件就必须用到flush()方法, BufferedOutputStream类的其他方法也能写入到文件是因为它们内部调用了flush()方法。</span></div><div><br/></div><div>4.数据字节流(数据流): (按照数据类型来进行读写, 写就是按照数据类型来进行写文件, 按照数据类型来占用字节数)</div><div>  DataInputStream</div><div>  DataOutputStream</div><div>       DataOutputStream就不止有write方法了, 还有各种数据类型的相应的write方法, 也就是说写并不是按照一个字符多少字节去写, 而是将每个数据按照规定的数据类型来写, 比如dfout.writeInt(111),虽然是三个字符, 但写出来这三个字符还是占四个字节(因为int类型占四个字节) 。不过这样写出来用文本编辑器查看可能乱码。</div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [28].png" type="image/png" data-filename="Image.png"/></div><div>    并且用DataOutputStream写的文件, 要再使用时, 也只能用DataInputStream来读回来才不会乱码。也就是说着一组字节流的一般使用方式是先写再读, 先用DataOutputStream将数据 用带数据类型的格式写入文件中, 再用DataInputStream来读该文件。</div><div><br/></div><div>5.对象字节流(对象流)(用对象来进行读写。 写就是直接以对象的形式写入文件, 保存对象)</div><div>  ObjectInputStream</div><div>  ObjectOutputStream</div><div><br/></div><div>6.打印输出字节流</div><div>  PrintStream</div><div>    PrintStream提供了非常多好用的方法, 如 print、<span style="font-size: unset; color: unset; font-family: unset;">println、</span><span style="font-size: unset; color: unset; font-family: unset;">printf 就是这个流提供的方法</span></div><div><span style="font-size: unset;"><br/></span></div><div>只有数据流和打印输出字节流相对用的较少一些, 其他都很常用</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">如上所示的各类字节流的使用示例见后文:</span></div><div>----------------------------------------------------------------------------------------------------------</div><div>处理流通常的使用方式就是包装一个节点流或者包装另一个包装流, 将其包装在自己的对象里面。如下:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [29].png" type="image/png" data-filename="Image.png"/></div><div>----------------------------------------------------------------------------------------------------------</div><div>流最重要的方法:</div><div>读操作: </div><div style="margin-left: 40px;">read() 读</div><div style="margin-left: 40px;">close()关闭</div><div style="margin-left: 40px;"><br/></div><div>写操作:</div><div style="margin-left: 40px;">write() 写</div><div style="margin-left: 40px;">close() 关闭</div><div><br/></div><div>(上面这些方法都是抽象父类中就已经定义的方法)</div><div>------------------------------------------------------------------------------------------</div><div><span style="font-weight: bold;">读操作常见步骤:   </span><span style="color: rgb(255, 0, 0); font-weight: bold;">(也是文件字节流的使用示例)</span></div><div style="margin-left: 40px;">1、创建流对象</div><div style="margin-left: 40px;">2、读</div><div style="margin-left: 40px;">3、关流</div><div style="margin-left: 40px;"><img src="day18-流 Stream、File、字节流、字符流_files/Image [30].png" type="image/png" data-filename="Image.png"/></div><div style="margin-left: 40px;">上图中的&quot;读&quot;的循环的写法: (注意 temp = fin.read() 是精髓, 因为每次.read()就会将指针指向下一个字符, 所以循环体内不能输出fin.read(),否则两个read()会导致循环次数少了一半,所以只能用一个临时变量将fin.read()的结果存起来)</div><div style="margin-left: 40px;"><img src="day18-流 Stream、File、字节流、字符流_files/Image [31].png" type="image/png" data-filename="Image.png"/> </div><div style="margin-left: 40px;"><br/></div><div>        </div><div><br/></div><div><span style="color: rgb(166, 0, 196);">    需要注意的是</span><span style="color: rgb(255, 0, 0);">在外码(编码方式为gbk)中, 一个汉字占两个字节, 一个英文字母占一个字节)</span><span style="color: rgb(166, 0, 196);">。所以如果用字节流读取文件内容时, 如果有汉字, 则读出来的内容中, 字母能正常显示, 而汉字就不能正常显示了, 因为字节流就是一个一个字节进行读取的, 读汉字的话一次只能读到汉字的存储的一半, 打印出来后, 一个汉字会被显示为两个问号。如文件内容为&quot;abc你好&quot;,用字节流读,打印出来的结果就是&quot;abc????&quot;。</span></div><div>    <span style="color: rgb(255, 0, 0);">(要注意外码和内码的区别,内码简单点说就是编程语言的字符所占的字节数, 外码就是字符在磁盘文件等的编码, 编码方式有gbk、utf-8等。</span><span style="color: rgb(255, 0, 0);">也就是说文件中的字符所占的字节数可能和在编程语言中所占的大小不一样。</span><span style="color: rgb(255, 0, 0);">)</span></div><div><br/></div><div><br/></div><div>        想要将汉字打印出来可以用<span style="color: rgb(166, 0, 196);">转换字符流</span>。不用直接新建流,用转换字符流直接对已经创建的字节流进行包装, 即可达到目的(<span style="color: rgb(166, 0, 196);">转化字符流实际上还是一种字节流, 不是字符流, 因为它是对字节流进行包装的, 不要搞混了</span>) :  <span style="color: rgb(255, 0, 0); font-weight: bold;">(也是转化字符流的使用示例)</span></div><div>        <img src="day18-流 Stream、File、字节流、字符流_files/Image [32].png" type="image/png" data-filename="Image.png" width="687"/></div><div>        另一种解决方法是不用转换字符流,继续使用字节流, 直接将字节流存到一个字节数组b里面去, 然后使用read()方法的重载方法read(byte[] b)来进行字节流的读操作, 然后利用String类的构造方法String(byte[],Charset charset)将一个字节数组转换为一个字符串(其中Charset是指定字符集的编码形式, 如gbk,utf-8,也可以不指定, 不指定就使用当前eclipse默认的配置)。这种方法的效率比上图方法的效率高</div><div>        <img src="day18-流 Stream、File、字节流、字符流_files/Image [33].png" type="image/png" data-filename="Image.png" width="630"/></div><div>    小知识: </div><div>        (1)流也有读取字节数的方法available(), 一样可以获得文件的字节数, 但需要注意的要保证还没有开始读, 才是文件的全部字节,因为它是从当前read指针所在位置开始算字节数的。</div><div>        (2)read方法还有一个重载是read(byte[] b, int off , int len), b是字节流存储的字节数组, <span style="color: rgb(166, 0, 196);">off是将字节流 从</span><span style="color: rgb(166, 0, 196);">字符数组的</span><span style="color: rgb(166, 0, 196);">哪个下标 开始</span><span style="color: rgb(166, 0, 196);">存储</span><span style="color: rgb(166, 0, 196);">(前面的元素留空),</span> len是选取的字节流的长度(从字节流起始位置开始算)。如上图的read方法替换为: fin.read(b,2,2), 则打印的结果为<span style="color: rgb(166, 0, 196);">&quot;  ab&quot;</span>(注意前面有两个空格)。</div><div><br/></div><div>        既然涉及到了流, 就必须考虑流的异常处理的问题, 以上面对异常的方式都是直接throws, 这在实际开发中是不负责任的表现, 应该使用try/catch来解决。</div><div>        <img src="day18-流 Stream、File、字节流、字符流_files/Image [34].png" type="image/png" data-filename="Image.png" width="616"/></div><div><br/></div><div>------------------------------------------------------------------------------------------</div><div><span style="font-weight: bold;">写操作常见步骤:</span></div><div>    1、创建流对象</div><div>    2、写</div><div>    3、关流</div><div>    写操作时, 因为文件的父路径可能不存在, 所以可能会引发异常, 需要对这个异常进行处理(文件本身是可以不存在的, 因为写会创建新文件, 就算原来有文件, 也会覆盖掉)。 </div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [35].png" type="image/png" data-filename="Image.png" width="687"/></div><div><br/></div><div>小知识: write方法也有一个重载是write(byte[] b, int off , int len), b是字节流存储的字节数组, <span style="color: rgb(166, 0, 196);">off是从字节数组的哪个下标开始 写入到文件中,</span> len是选取的字节流的长度(从字节流起始位置开始算)。如上图的read方法替换为: fout.write(b,2,2), 则d:/data/b.txt文件里的内容为<span style="color: rgb(166, 0, 196);">&quot;ll&quot;</span>。<span style="color: rgb(255, 0, 0);">(要注意write(byte[] b, int off , int len)和read(byte[] b, int off , int len)的区别)</span></div><div>------------------------------------------------------------------------------------------</div><div>字节流使用举例: </div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [36].png" type="image/png" data-filename="Image.png"/></div><div>   解决方法:<img src="day18-流 Stream、File、字节流、字符流_files/Image [37].png" type="image/png" data-filename="Image.png"/></div><div>    上图的处理方法是读一个字节写一个字节, 更好的方法是先全部读完,读到一个byte数组里,全部读完到byte数组后, 再开始写, 这样效率更高。</div><div>    另一种改进方法是用缓冲字节流对节点流进行包装, 将数据直接先全部读到&quot;读缓冲区&quot;里, 再将&quot;读缓冲区&quot;里的字节循环放到&quot;写缓冲区&quot;里, 最后通过flush()方法将&quot;写缓冲区&quot;里的内容一次性写到文件中去。<span style="color: rgb(166, 0, 196);">使用</span><span style="color: rgb(166, 0, 196);">BufferedOutputStream需要注意, 写文件完之后, 一定要使用其flush()方法刷新缓冲区, 否则可能会没有写文件成功。从&quot;写缓冲区&quot;写入到文件就必须用到flush()方法, BufferedOutputStream类的其他方法也能写入到文件是因为它们内部调用了flush()方法。<span style="color: rgb(166, 0, 196); font-weight: bold;"> </span></span><span style="color: rgb(255, 0, 0); font-weight: bold;">(缓冲字节流的使用示例)</span></div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [38].png" type="image/png" data-filename="Image.png" width="655"/></div><div>------------------------------------------------------------------------------------------</div><div>字节流使用例二:  <span style="color: rgb(255, 0, 0); font-weight: bold;">(也是缓冲字节流的使用示例)</span></div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [39].png" type="image/png" data-filename="Image.png"/></div><div>    解决方法如下:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [40].png" type="image/png" data-filename="Image.png" width="657"/></div><div>需要注意的是: </div><div>    input变量也是要关流的,因为input变量也是一个流,但关闭的不是Scanner流,而是InputStream流。因为<span style="font-size: unset; color: unset; font-family: unset;">在 Scanner input = new Scanner(System.in);中, </span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">Scanner类并不是一个流, 它只是一个类而已, 但是System.in是一个流,</span></span> <span style="font-size: unset; color: unset; font-family: unset;">System.in</span><span style="font-size: unset; color: unset; font-family: unset;">是InputStream类型的变量, 也就是说in是一个字节流, 但它并不是文件流FileInputStream, 因为它不是从文件中读取数据, 而是从键盘或其他输入设备中读取数据, 所以它直接用了字节流最顶级的类InputStream来定义: </span></div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [41].png" type="image/png" data-filename="Image.png"/></div><div>    虽然读取键盘输入时不一定是用Scanner类来实现, 但是读取键盘输入就必然是用<span style="color: rgb(255, 0, 0);">System.in</span>来读取。与其对应的, 输出(打印)到控制台用的就是System.out流了,注意,  <span style="color: rgb(255, 0, 0);">System.out</span>流不是写入到文件, 而是写入到控制台。定义如下:</div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [42].png" type="image/png" data-filename="Image.png" width="645"/></div><div>天天用的<img src="day18-流 Stream、File、字节流、字符流_files/Image [43].png" type="image/png" data-filename="Image.png"/>就是用的System.out, 用的就是PrintStream流(打印输出字节流)。</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">记住一点: 可以这样理解, 键盘的路径就用System.in来表示, 控制台的路径就用System.out来表示。可以把键盘或控制台理解为一个文件, System.in或System.out就是他们的&quot;绝对路径+文件名&quot;,就像&quot;d:/data/a.txt&quot;一样。</span></div><div>------------------------------------------------------------------------------------------</div><div>Scanner类</div><div>    Scanner类的构造器如下: </div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [44].png" type="image/png" data-filename="Image.png"/></div><div>        </div><div>            <img src="day18-流 Stream、File、字节流、字符流_files/Image [45].png" type="image/png" data-filename="Image.png" width="540"/></div><div>        所以Scanner也支持构造器的参数是一个字节流, 也就说Scanner也支持读取文件内容作为输入数据, 不仅仅支持读取键盘输入: (注意next()方法读取文件时是以空格作为分隔符依次读取,不会读取空格作为字符, 而如果是nextLine()方法则是一次读取一行)<img src="day18-流 Stream、File、字节流、字符流_files/Image [46].png" type="image/png" data-filename="Image.png"/></div><div>        用String作为构造器参数: </div><div>    <img src="day18-流 Stream、File、字节流、字符流_files/Image [47].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>-----------------------------------------------------------------------------------------------</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">数据字节流的使用举例:</span></div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [48].png" type="image/png" data-filename="Image.png" width="665"/></div><div>  -----------------------------------------------------------------------------------------------</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">对象字节流的使用举例:</span></div><div>把对象以二进制流的形式永久的保存到文件里面去, 这就是序列化。</div><div>普通的类是不支持序列化的, 必要要实现Serializable接口的类,  才能实现序列化( 不需要重写任何方法, 定义后哪个成员变量序列化为什么变量之类的)。Serializable接口里面没有方法, 但实现该接口就是作为这个类可以序列化的标志。</div><div><br/></div><div>把文件的二进制流还原为对象的过程, 就叫反序列化。反序列化成功之后就能正常调用对象的变量和方法了。</div><div><br/></div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [49].png" type="image/png" data-filename="Image.png" width="687"/></div><div><br/></div><div>如果在序列化到文件之后,再对序列化的对象对应的该类进行修改, 那么对原先的文件进行反序列化时就会报错, 提示类的版本号不一致。 如果没有自己指定类的版本号, 在序列化的时候, 系统会自动为该类分配一个版本号, 对类进行修改后, 在反序列化时, 系统又会自动给该类生成一个最新的版本号,类的版本号发生变化,反序列化时首先就会比较其对象对应<span style="font-size: unset; color: unset; font-family: unset;">的类的版本号和当前类的版本号是否一致, 不一致则抛出异常,不进行反序列化。</span></div><div><span style="font-size: unset;"><br/></span></div><div>但如果你给该类添加了一个版本号,并且你修改了类的内容后, 不对版本号进行更改, 那么就能反序列化成功。只需在上图的Person类中添加下面这行代码即可: (这行代码在你实现Serializable接口时, 编辑器就会提示你添加一个serialVersionID)</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [50].png" type="image/png" data-filename="Image.png"/></div><div>这样是为了你修改了类的内容,但并不会对该类以前的对象产生影响时, 可以像上图这么做, 添加一个serialVersionID, 并且在修改完类的内容后不修改该版本号。</div><div>------------------------------------------------------------------------------------------</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">打印输出字节流的使用举例:</span></div><div>    要注意的是它只有写的类, 没有相应的读的类</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [51].png" type="image/png" data-filename="Image.png" width="687"/></div><div><br/></div><div>---------------------------------------------------------------------------------------</div><div>------------------------------------------------------------------------------------------</div><div>字符流的分类: </div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [52].png" type="image/png" data-filename="Image.png"/></div><div>Reader和Writer是字符流的两个抽象父类, 分别是读和写</div><div>FileReader和FileWriter是文件字符流的读和写,他们是字符流的节点流。相当于FileInputStream和FileOutputStream, 他们的父类是在字节流里讲到的转换字符流InputStreamReader和OutputStreamWriter, 这两个转换字符流并不属于字节流(没有继承关系), 而属于字符流这一脉的。要注意的是字符流的节点流是继承自包装流的,而字节流的节点流则是包装流的父类(为啥会这样???)。</div><div>BufferReader和BufferWriter是缓存字符流, 功能和缓存字节流类似</div><div>PrintWriter是打印输出字符流, 对文本文件进行操作的话, PrintWriter要比PrintOutputStream简单,因为是以一个一个字符来进行处理的。</div><div><br/></div><div>字符流：</div><div>Reader和<span style="font-size: unset; color: unset; font-family: unset;">Writer 以</span><span style="font-size: unset; color: unset; font-family: unset;">字符为单位。</span></div><div><br/></div><div>1.文件字符流</div><div>  节点流</div><div>  FileReader</div><div>  FileWriter</div><div>2.缓冲流</div><div>  BufferedReader</div><div>  BufferedWriter</div><div>3.打印输出字符流</div><div>  PrintWriter</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">流的类的命名方式是: 前中缀加起来是该流的功能; 中缀(Input和Output是指输入和输出; 后缀(如Stream、Reader等)是指流的种类(Stream是指字节流, Reader和Writer是指字符流) </span></div><div><br/></div><div>------------------------------------------------------------------------------------------</div><div>字符流的基本使用</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [53].png" type="image/png" data-filename="Image.png" width="752"/></div><div><br/></div><div>------------------------------------------------------------------------------------------</div><div>文件流(字符流的节点流):</div><div> FileReader和FileWriter</div><div><br/></div><div>字符流的读写操作和字节流类似, 最主要的区别<span style="font-size: unset; color: unset; font-family: unset;">就是一次性读写的是一个字节(byte)还是一个字符(char)。</span></div><div>读操作: ()</div><div><br/></div><div>字符流的read()方法的所有重载如下,可以发现和字节流最大的区别就是参数的byte数组换成了char数组,而不带参的read()方法返回值变成了int , 实际上是一次读取一个字符, 因为char会自动转化为int。</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [54].png" type="image/png" data-filename="Image.png" width="490"/></div><div><br/></div><div>读操作基本流程:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [55].png" type="image/png" data-filename="Image.png" width="668"/></div><div>需要注意的是, read()方法的返回值时int型, char类型会自动转换为int型<span style="font-size: unset; color: unset; font-family: unset;">所以字符全部都是显示的是数字形式, 上图中的a.txt文件里的内容是&quot;abc你好&quot;, 要显示为字符的话, 需要强转为char类型。读到文件尾后read()的返回值和字节流一样, 也是-1。</span></div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [56].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>用循环对上面写法的改进:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [57].png" type="image/png" data-filename="Image.png" width="671"/></div><div> 再改进就是一次性读完,读到一个char数组里。<span style="color: rgb(166, 0, 196);">需要注意的是,在字节流中, 字节数可以通过节点流的length()方法或者字节数, 但是在字符流中, 要得到准确的字符数却是不现实的, 因为英文字符和中文字符所占的字节数不相等, 所以char数组的大小只能通过人工估计来设置。</span></div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [58].png" type="image/png" data-filename="Image.png" width="704"/></div><div><br/></div><div><br/></div><div>写操作:</div><div>字符流的write()方法所有重载如下, 和字节流的区别也就是byte数组变成了char数组, 然后因为字符流支持char数组, 那么也就自然支持String了。</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [59].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196); font-weight: bold;">字符流的写操作一定要注意要close()流, 因为close()自带flush()功能,而每个流不管是不是缓冲流都有个小的缓冲区, 如果不关流的话很可能会出现没有写成功的情况。</span></div><div><br/></div><div>写操作基本流程:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [60].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div>一个例题:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [61].png" type="image/png" data-filename="Image.png"/></div><div>解决方法一, 用StringBuilder来做,将流里的一个字符一个字符添加到StringBuilder里:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [62].png" type="image/png" data-filename="Image.png" width="729"/></div><div><br/></div><div>另一种解决方法是将字符流存到一个char数组里:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [63].png" type="image/png" data-filename="Image.png" width="670"/></div><div><br/></div><div><br/></div><div>--------------------------------------------------------------------------------------------------------------------</div><div>缓存流:</div><div>BufferReader和BufferWriter</div><div>BufferReader构造方法如下:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [64].png" type="image/png" data-filename="Image.png"/></div><div>读操作: (写操作类似, 不再赘述)</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [65].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>缓冲字符流使用举例: </div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [66].png" type="image/png" data-filename="Image.png"/></div><div>解决方法: </div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [67].png" type="image/png" data-filename="Image.png" width="856"/></div><div>------------------------------------------------------------------------------------------------</div><div>打印输出字符流PrintWriter</div><div>打印输出字符的话会比PrintStream更简便</div><div><br/></div><div>PrintWriter的构造方法如下。从构造方法可以看出, 可以打印输出到文件、字节流(包括打印输出到控制台,即System.out)、字符流</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [68].png" type="image/png" data-filename="Image.png" style="color: unset; font-family: unset; font-size: unset;"/></div><div><br/></div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [69].png" type="image/png" data-filename="Image.png"/></div><div> 保存在文件中的结果如下:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [70].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>使用举例:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [71].png" type="image/png" data-filename="Image.png" width="439"/></div><div>解决方法:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [72].png" type="image/png" data-filename="Image.png"/></div><div> 改进的解决方法(使用try-catch进行异常处理而不是用throws抛出异常): </div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [73].png" type="image/png" data-filename="Image.png" width="672"/></div><div><br/></div><div>---------------------------------------------------------------------------------------------------------</div><div>自动资源释放：</div><div><br/></div><div>try (声明需要释放的资源) {</div><div><br/></div><div>          可能产生异常的语句</div><div><br/></div><div>  } catch (异常) {</div><div>  }</div><div><br/></div><div>只要使用的流间接实现了AutoCloseable接口, 就可以进行自动资源释放了(AutoCloseable是可以自动资源释放的), 也即是自动关闭流, 这时候只需要把需要释放的流放在try关键字后面紧跟的一个括号里(注意, 需要把声明和创建流对象的语句都放在括号里), 就可以实现自动资源释放, 这样流就不需要用close()方法写关流的语句。</div><div>比如上图中的实现语句就可以改成如下形式:</div><div><img src="day18-流 Stream、File、字节流、字符流_files/Image [74].png" type="image/png" data-filename="Image.png"/></div><div>---------------------------------------</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><a href="day18-流 Stream、File、字节流、字符流_files/day16- LIU_流.pdf"><img src="day18-流 Stream、File、字节流、字符流_files/fb46b8490cc02844330e4306eb4e7161.png" alt="day16- LIU_流.pdf"></a></div><div><br/></div></span>
</div></body></html> 