<html>
<head>
  <title>day4-数组、堆和栈、循环、排序算法</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="2900"/>
<h1>day4-数组、堆和栈、循环、排序算法</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2019/12/18 23:13</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2022/9/4 23:45</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-size: unset; color: unset; font-family: unset;">数组：</span></div><div><br/></div><div>一个容器，存储相同数据类型的一组数。</div><div>数组的长度是固定的（数组创建完成之后长度不变）</div><div><br/></div><div>栈：</div><div>1.存：基本数据类型 和 引用；</div><div>2.后进先出的数据结构；</div><div>3.栈分配的空间小；</div><div>4.频繁创建 和 销毁的数据结构。</div><div><br/></div><div>堆：</div><div>1.存：对象。</div><div>2.堆分配的空间大；</div><div>3.不会频繁创建和销毁。</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">基本数据类型不会用到堆来存储数据,都是直接将变量的具体数值存在栈里面。</span></div><div><span style="color: rgb(166, 0, 196);">引用数据类型(</span>这里拿数组来举例<span style="color: rgb(166, 0, 196);">)都是分两部分来存:名字(即数组名,也就是地址，即具体数据在堆中的地址)存在栈里面; 对象(数组实例化的对象,因为数组是通过实例化一个数组类的对象来存储数据的)存在堆里面。</span></div><div><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">所以数组也可以先单独定义(只在栈中存储数组名,不分配实际堆的具体数值的存储空间),再赋值(用单独的</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">语句给整体赋值时再分配堆的空间储存具体的数值)</span></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">基本数据类型和引用数据类型还有个重要的区别是: 因为基本数据类型的变量存的都是值,而引用数据类型的变量存的都是对象的地址, 所以引用数据类型说到底就是个类, 而基本数据类型则不是, 所以引用数据类型的变量可以通过&quot;引用变量.成员&quot;的方式调用类的成员(当然也可以通过&quot;对象.成员&quot;的方式调用),而基本数据类型的变量则没啥可调的</span></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>一维数组内存图</div><div><br/></div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">注意, &quot;只有在堆里开辟空间时, 才会出现在赋值语句执行之前，给各种数据类型的变量先赋上默认初始值, 之后才是赋值语句赋值&quot;, 也就是说,只有数组或引用类型在new的时候, 数组的元素或引用类型的成员变量, 才会有赋默认值的现象。像局部变量</span><span style="color: rgb(255, 0, 0); font-weight: bold;">(在方法体里定义的变量)</span><span style="color: rgb(255, 0, 0); font-weight: bold;">这种不在堆里开辟新空间的, 是不会出现在赋值语句执行之前, 给他们赋一个默认值的。 另外还要注意, 如果数组没有new并且作为类的成员变量的话, 默认的初始化值是null。</span></div><div>    举例如下:</div><div>        下面的四个编译错误都是如下图红框一样的错误提示</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [1].png" type="image/png" data-filename="Image.png" width="599"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">各种数据类型的默认初始值: (包括基本数据类型和引用数据类型)</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">1、整数类型（byte、short、int、long）的基本类型变量的默认值为0。</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">2、单精度浮点型（float）的基本类型变量的默认值为0.0f。</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">3、双精度浮点型（double）的基本类型变量的默认值为0.0d。(单精度和双精度的默认值打印出来都是0.0)</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">4、字符型（char）的基本类型变量的默认为 “/u0000”。</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">5、布尔性的基本类型变量的默认值为 false。</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">6、引用类型的变量是默认值为null。 (包括了数组。数组本身还是一个引用类型的, 如果没有new时, 作为类的成员变量, 给他赋的默认值就是null, 但是数组new了之后, 就是给其各个元素赋默认值了)</span></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>数组定义 </div><div><br/></div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>1、数组的初始化</div><div>(1)动态初始化</div><div>   <span style="color: rgb(166, 0, 196);"> 动态初始化只能一个一个元素进行赋值,不能一条语句给整体赋值</span></div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div>也可以分成两条语句来写,这也勉强算是&quot;先定义后初始化&quot;吧,毕竟也是new了一下, 只是初始化的都是默认值0而已</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>(2)静态初始化</div><div>用这种new一个的方式(类、对象的方式),既可以定义的同时初始化,也可以先定义后初始化</div><div>    1)定义的同时初始化</div><div>          a. 首先是用new的</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div>         b. 其次是不用new的定义方式(类似于C语言定义数组的方式)<span style="color: rgb(166, 0, 196);">(不过这里的定义出来的数组依然是类与对象的形式,也就是说</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">依然是数组类的一个对象)</span></div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>    这种赋值方式就和C语言一样了,也是不能分成两行(即不能先一条语句定义,再单独用另一条语句给整个数组初始化),分成两行会报错。</div><div>   </div><div>    2)先定义后初始化</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [7].png" type="image/png" data-filename="Image.png" width="1018"/></div><div>      </div><div>2、给数组赋值(指单个单个赋值,不是一次性整体赋值)</div><div>(1)直接代码赋值</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [8].png" type="image/png" data-filename="Image.png" width="861"/></div><div>(2)控制台输入 赋值</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [9].png" type="image/png" data-filename="Image.png" width="847"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>做一个题,模拟两个数组值的变换过程。下面的图中方框里的代码语句就对应右边的该语句执行时的内存变化图。</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [10].png" type="image/png" data-filename="Image.png" width="904"/></div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [11].png" type="image/png" data-filename="Image.png" width="855"/></div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [12].png" type="image/png" data-filename="Image.png" width="867"/></div><div>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>循环赋值</div><div><br/></div><div>循环输出：</div><div>  基本for循环: 可用于任何循环(所有语言都有的,通用的循环)</div><div>  增强for循环: 只用于集合 和 数组的循环；(java特有的循环,不同于C语言)</div><div>                 for(数据类型  变量名:数组名){</div><div>                </div><div>                 }</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>普通for和增强for的区别：</div><div><br/></div><div>1.增强for只能遍历数组中的<span style="color: rgb(166, 0, 196);">所有</span>元素;</div><div>  指定范围遍历要用普通for;</div><div><br/></div><div>2.增强for只能顺序遍历;</div><div>  逆序遍历等方式要用普通for;</div><div><br/></div><div>3.增强for不能改变元素的值，（如果元素是引用类型, 可以改变其成员变量的值）。</div><div>  普通for可以改变元素值。</div><div><br/></div><div>    对于第三点的验证如下图:</div><div>    增强for循环不能改变元素的值</div><div>    <img src="day4-数组、堆和栈、循环、排序算法_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div>    <img src="day4-数组、堆和栈、循环、排序算法_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div>    结果不变:如下图</div><div>    <img src="day4-数组、堆和栈、循环、排序算法_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>    普通for循环是会变的:如下图</div><div>    <img src="day4-数组、堆和栈、循环、排序算法_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>    结果如下图:</div><div>    <img src="day4-数组、堆和栈、循环、排序算法_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div>--------------------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>算法：</div><div>  1、最大值：</div><div><br/></div><div>  2、排序</div><div><br/></div><div>    1)冒泡</div><div>      相邻的两个数字进行比较。</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [19].png" type="image/png" data-filename="Image.png" width="870"/></div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div>    2）选择</div><div>       某一个位置和后边的所有元素比较。</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div>    3）插入排序</div><div>       某一个位置和前边的所有元素比较，这个位置的元素值比前边的元素值小，那么就把这个位置的元素值插入到前边那个元素的位置。（下面老师这种写法质量太差，明明就只要两层循环就能搞定）</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>  3、二分查找</div><div>     先从小到大排序，再分成两段查找数值。</div><div>以下是eclipse中的二分查找原码</div><div><img src="day4-数组、堆和栈、循环、排序算法_files/Image [23].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手写与上传资料分割线</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span></div><div><br/></div><div><br/></div><div><br/></div><div><a href="day4-数组、堆和栈、循环、排序算法_files/day4 - LIU_数组.pdf"><img src="day4-数组、堆和栈、循环、排序算法_files/d6209bc06fdcedc2d28d5e7d27e2d2c3.png" alt="day4 - LIU_数组.pdf"></a></div><div><br/></div></span>
</div></body></html> 