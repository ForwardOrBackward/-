<html>
<head>
  <title>网络编程(马中华版)</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="8037"/>
<h1>网络编程(马中华版)</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2021/4/6 20:53</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/10/9 13:22</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-size: unset; color: unset; font-family: unset;">    IO的概念：</span></div><div>        输入  Input</div><div>        输出  Output</div><div><br/></div><div>    IO 的分类：</div><div>        File IO / 磁盘 IO    File</div><div>        网络 IO</div><div><br/></div><div>    网络编程模型</div><div>    1、总共有几种？</div><div>        同步阻塞 (BIO)</div><div>        同步非阻塞</div><div>        异步阻塞</div><div>        异步非阻塞</div><div><br/></div><div>        提出了两对非常重要的概念：</div><div>        1、同步 和 异步</div><div>        2、阻塞 和 非阻塞</div><div><br/></div><div>关于同步异步阻塞非阻塞这些 概念可见马中华笔记: </div><div>    <a href="https://blog.csdn.net/zhongqi2513/article/details/80994527?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161777935316780255211101%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161777935316780255211101&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-5-80994527.pc_v2_rank_blog_default&amp;utm_term=%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5">https://blog.csdn.net/zhongqi2513/article/details/80994527?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161777935316780255211101%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161777935316780255211101&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-5-80994527.pc_v2_rank_blog_default&amp;utm_term=%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5</a></div><div><br/></div><div>    2、ServerSocket Socket 属于哪一种？</div><div>        属于同步阻塞</div><div><br/></div><div> </div><div><br/></div><div>学JavaSE的时候以前写过ServerSocket Socket  也就是 C/S软件架构模式的网络编程, 也就是server/client。这是第一种网络编程模型,最原始的网络编程模型(BIO)。</div><div>    Server/Client :   server： 服务器程序  <span style="font-size: unset; color: unset; font-family: unset;">client： 给用户使用</span></div><div>        1、首先启动服务</div><div>        2、启动客户端</div><div>        3、客户端发送请求给服务端</div><div>        4、服务端进行处理之后响应结果数据给客户端</div><div>    以前写的ServerSocket Socket的代码，都是直接在main方法中启动的。</div><div>    client和server要启动在不同的节点中(不同的)。其中client就是一个JVM进程   server也是一个JVM进程</div><div><br/></div><div> B/S 架构     C/S架构</div><div>   B/S 架构就是 server   browser</div><div>   B/S  其实 就是  C/S 中的一种特例。<span style="font-size: unset; color: unset; font-family: unset;">B都是浏览器：   封装HTTP请求发送给HTTP服务器解析，得到结果之后。由浏览器进行渲染</span></div><div><br/></div><div><br/></div><div>    </div><div>-----------------------------------------------------------------------------------------------------------------</div><div>举个具体的例子：</div><div>    现在有一个服务： DateTimeUitl.getNowDate()  ,<span style="font-size: unset; color: unset; font-family: unset;">部署在hadoop02机器上。</span></div><div>    那么现在有一个客户，这个客户端想调用<span style="font-size: unset; color: unset; font-family: unset;">hadoop02的</span>这个服务得到服务器的当前时间</div><div>    但是，这个客户的客户端不在hadoop02上。比如说在hadoop03上。<span style="font-size: unset; color: unset; font-family: unset;">如果做到调用？</span></div><div><span style="font-size: unset; color: unset; font-family: unset;">    图示意如下:</span></div><div>    </div><div><br/></div><div>首先考虑用BIO, 也就是我们在&quot;day20-网络编程&quot;里使用的那种编程模型, 来解决上述问题。BIO的执行流程如下: </div><div><img src="网络编程(马中华版)_files/Image.png" type="image/png" data-filename="Image.png" width="670"/></div><div><br/></div><div>具体实现如下: (详情见 <a href="file:///D:/Software/Java/eclipse-workspace_all/JavaSE%E7%BD%91%E8%AF%BE%E4%BB%A3%E7%A0%81/JavaSE%E7%BD%91%E8%AF%BE%E4%BB%A3%E7%A0%81/src/io1803/bio">JavaSE网课代码\src\io1803\bio</a>)</div><div><br/></div><div>Server端代码如下:</div><div><img src="网络编程(马中华版)_files/Image [1].png" type="image/png" data-filename="Image.png" width="782"/></div><div><br/></div><div><br/></div><div>客户端代码如下: </div><div><img src="网络编程(马中华版)_files/Image [2].png" type="image/png" data-filename="Image.png" width="782"/></div><div><br/></div><div>还有一个负责关闭各种流的工具类CloseUtil:</div><div><img src="网络编程(马中华版)_files/Image [3].png" type="image/png" data-filename="Image.png" width="629"/></div><div><br/></div><div><br/></div><div>来说说BIO这种编程模型的缺点: </div><div style="margin-left: 40px;">TaskThread每次接收到客户端的一个请求的时候，就初始<span style="font-size: unset; color: unset; font-family: unset;">化一个新的线程来执行这个请求</span></div><div style="margin-left: 40px;"> 这样做会有两个问题:</div><div style="margin-left: 40px;">     1、如果客户单的请求数据，过了很长时间都没有发送过来，那么这个线程就会一直运行着，但是又不做任何事<span style="font-size: unset; color: unset; font-family: unset;">只是等待客户端发送数据过来。</span></div><div style="margin-left: 40px;">     2、既然每一个请求都初始化一个线程进行服务，那么并发量如果很大呢？也就是说客户端如果很多呢?这样也<span style="font-size: unset; color: unset; font-family: unset;">是会出现问题的,毕竟服务器的资源是有限的，不能无限制的去接收客户端的请求</span></div><div>BIO 编程模型中有三个致命问题：</div><div>    1、ServerSocket.accept()方法是阻塞的,在等待的过程中不能做任何事。</div><div>    2、BufferedReader.readLine()方法(底层是read()方法)也是阻塞的,在等待的过程中不能做任何事。其实不止于read()方法, <span style="font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">一个线程调用read()或write()方法时，该线程都会被阻塞，直到有一些数据被读取或写入。  </span></div><div>    3、一对一的服务模式(即一个线程只服务于一个客户端)</div><div>总结这三条的致命的问题的根本就是：</div><div>    1、IO的阻塞问题</div><div>    2、线程的高并发过载问题</div><div>    </div><div><span style="font-size: unset; color: unset; font-family: unset;"> BIO这种网络编程模型的程序 到底有没有用处？</span></div><div>     有。使用BIO这种网络编程模型的场景如下:</div><div>      1、最原始的软件的网络编程模型都是这种。</div><div>      2、如果这种服务端程序能接收到的并发量在可控范围内，那就没问题。</div><div>------------------------------------------------------------------------------------------------------</div><div>早期的BIO编程模型不适用与高并发场景。<span style="font-size: unset; color: unset; font-family: unset;">所以 </span><span style="font-size: unset; color: unset; font-family: unset;">提出了新的编程模型</span></div><div>所以就有了 阻塞 非阻塞  同步 异步的概念区分</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">多线程的同步： 针对临界数据进行同步访问(当然读在java中不同步,主要是写要求同步)。</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">让这一份数据，同时只能被一个线程修改。而IO中的同步与这个概念有些差别,就不再是指访问某个资源了。</span></div><div><span style="font-size: unset;"><br/></span></div><div>java 1.0 : BIO :  同步阻塞</div><div>java 1.4 : NIO ： 异步非阻塞(并不是完全意义的异步非阻塞,但NIO也能实现异步非阻塞)</div><div>java 1.7 : AIO ： 异步非阻塞(完全意义上的异步非阻塞)</div><div><br/></div><div><br/></div><div>假如在食堂窗口点了一份盖浇饭: </div><div>（一）同步+阻塞 ：   自己去取饭，并且在等待的过程中, 什么都不做,干等。</div><div>（二）同步+非阻塞  ：  自己去取饭，  等的过程中，可以做其他的,比如玩游戏。</div><div>（三）异步+阻塞  ：   别人送来做好的饭,不做什么，干等 。(<span style="color: rgb(166, 0, 196);">可以发现异步阻塞对于底层设计来说是没有任何意义的, 完全在浪费资源</span>)</div><div>（四）异步+非阻塞 ：  别人送来做好的饭，等的过程中，还可以做其他的,比如玩游戏<span style="color: rgb(166, 0, 196);">(效率最高)</span>。</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">同步就是自己去取, 异步就是别人送过来(</span><span style="color: rgb(166, 0, 196);">被动等待通知</span><span style="color: rgb(166, 0, 196);">)。</span></div><div><span style="color: rgb(166, 0, 196);">阻塞就是等待的过程中什么也不做, 非阻塞就是等待的过程中干别的事。</span></div><div><br/></div><div>同步、异步是指结果以什么样的方式返回</div><div>    同步：<span style="font-size: unset; color: unset; font-family: unset;">主动去拉取数据。</span>每次去拉取结果数据的时候，不一定结果数据都已经准备好了。所以, 同步里面一般都有一种<span style="font-size: unset; color: unset; font-family: unset;">轮询机制, 即每隔一段时间去询问一次, 直到结果数据全都准备好了才能拿到数据。</span></div><div>    异步：被动等待通知</div><div><br/></div><div>阻塞、非阻塞就是执行这个任务的线程是否该任务暂停时还可以执行其他的任务。</div><div>    阻塞: 不可以</div><div>    非阻塞: 可以</div><div><br/></div><div><img src="网络编程(马中华版)_files/不同的IO模型对比.png" type="image/png" data-filename="不同的IO模型对比.png"/></div><div><br/></div><div>同步阻塞(BIO)的服务模式中, 线程是一对一的服务模式, 而伪异步I/O<span style="font-size: unset; color: unset; font-family: unset;">则由一对一的服务模式就变成了m对n的服务模式(</span>m 是客户端个数,  n 是线程数, m 可以大于 n<span style="font-size: unset; color: unset; font-family: unset;">)。</span></div><div><span style="color: rgb(166, 0, 196);">伪异步I/O</span>其实就是在服务端使用一个线程池, 在线程池里始终保持几个线程, 不用每次有客户端来访问时再临时创建线程, 在高并发时再将线程数量加大。</div><div>好处是保证了服务器的资源不会被全部消耗, 也就是不会在高并发的时候使服务器崩溃。并且m对n的服务模式一定会比一对一的服务模式的效率要高。并且有多个线程在待命, 当有新客户端连接时, 不用重复的初始化。</div><div>坏处是并发量依然很大的话, 服务器依然会处理不过来。并且在线程处理客户端请求时,  依然是同步阻塞的,所以一个线程还是不能同时处理多个客户端的请求,只能等一个客户端处理完了,关闭流了, 再处理另一个客户端。</div><div>----------------------------------------------------------------------------------------------------</div><div>下面是根据上面的BIO的代码生成的<span style="color: rgb(166, 0, 196);">伪异步I/O</span>的代码:</div><div>首先是新建一个线程池类: </div><div><img src="网络编程(马中华版)_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>接下来修改BIOServer的代码, 其实就修改了下面红框中几行代码而已</div><div><img src="网络编程(马中华版)_files/Image [5].png" type="image/png" data-filename="Image.png" width="782"/></div><div>----------------------------------------------------------------------------------------------------------</div><div><span style="font-weight: bold;">NIO</span></div><div>可见马中华博客:</div><div>    <a href="https://blog.csdn.net/zhongqi2513/article/details/80994587?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161780247816780269869054%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161780247816780269869054&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-80994587.pc_v2_rank_blog_default&amp;utm_term=NIO">https://blog.csdn.net/zhongqi2513/article/details/80994587?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161780247816780269869054%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=161780247816780269869054&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-80994587.pc_v2_rank_blog_default&amp;utm_term=NIO</a></div><div><br/></div><div>BIO   叫做BlockingIO。<span style="font-size: unset; color: unset; font-family: unset;">NIO叫做 New IO(官网叫法)  或者 Non-Block IO</span></div><div>NIO ： 既叫做异步非阻塞IO, 也叫多路复用的编程模型。<span style="font-size: unset; color: unset; font-family: unset;"> NIO对于数据传输的抽象变了</span></div><div><br/></div><div>NIO的概念概念： <span style="color: rgb(166, 0, 196);"> 基于通道，面向缓冲区</span></div><div><br/></div><div>NIO的三大核心概念：</div><div><span style="font-weight: bold;">1、Channel (通道)  </span></div><div>Channel 是传输数据的一种新的抽象。NIO不再使用 InputStream和outputStream, 而是使用Channel代替, Channel完完全全实现了 InputStream + OutputStream两者的功能。<span style="font-size: unset; color: unset; font-family: unset;">Channel既有输入的功能, 也有输出的功能。所以Channel就相当于双向流通的管道, 数据的输入输出都是通过它。既有客户端使用的SocketChannel, 也有服务端使用的ServerSocketChannel。</span></div><div><span style="font-weight: bold;">2、Buffer(缓冲区)。 </span>Channel相当于管子, Buffer相当于池子。Channel始终是对接Buffer来使用的, 要么是数据通过Channel流入Buffer, 要么是将Buffer里的数据通过Channel流出去。Buffer就是为了给Channel读写数据提供便利。因为一个Channel会和一个Buffer绑定。</div><div><span style="font-weight: bold;">3、Selector (选择器或多路复用器)。</span><span style="color: rgb(166, 0, 196);">在NIO里, 服务器的线程就相当于老板, selector就相当于秘书(管家), 客户端就相当于客户, 老板现在应该见哪个客户全都要问秘书, 听秘书安排。</span>Selector实际上就是一个线程, 只不过这个线程里包含了一个容器,这个容器里面放的都是客户端或者服务端的连接请求。selector会检查这些连接请求的输入数据是否准备好了<span style="color: rgb(166, 0, 196);">(不论是客户端的channel准备好了数据发送给服务端, 还是服务端的channel准备好了数据发送给客户端)</span>, 准备好了就交给线程们去处理, 没准备好就先不交给线程处理。NIO里面只有一个常驻线程, 就是这个管家。</div><div><br/></div><div><br/></div><div>IO 和 NIO 的比较：</div><div>        1、IO是面向流的，NIO是(基于通道)面向缓冲区的：IO将数据直接写出到流中或从流中直接读取数据，NIO中所有的数据必须通过缓冲区来处理。   </div><div>        2、IO以流(逐字节)的方式处理数据，NIO以<span style="color: rgb(166, 0, 196);">块</span>的方式处理数据。    </div><div>        3、IO是阻塞的，NIO是非阻塞的。</div><div><br/></div><div>伪异步I/O的线程池 ： m : n 。<span style="font-size: unset; color: unset; font-family: unset;"> m 是客户端个数,  n 是线程数</span></div><div>NIO的线程池 : m :  n +1。m是客户端个数,  n 是线程数。线程数是 1个常驻线程 + 1个线程池里的所有线程 </div><div><br/></div><div><span style="color: rgb(166, 0, 196);">NIO的效率比伪异步I/O(或者BIO)的效率要高得多, 最重要的原因是:  阻塞 变成了 非阻塞</span></div><div>-------------------------------------------------------------------------------------------------------------</div><div><span style="font-weight: bold;">NIO的核心 ------缓冲区：java.nio.Buffer  </span></div><div>        1、缓冲区从两个方面来提高I/O的效率：    </div><div>                1、减少实际的物理读写次数    </div><div>                2、缓冲区所占的内存空间一直在被复用，减少了动态分配内存及GC的次数。  </div><div>        2、缓冲区是一个数组，java.nio.ByteBuffer是最常见的缓冲区。    </div><div>            ByteBuffer提供了两个创建字节缓冲区的方法：  </div><div>            <span>    </span>allocate(int capacity)：将缓冲区建立在JVM的内存中。  </div><div>            <span>    </span>allocateDirect(int capacity)：将缓冲区建立在<span style="color: rgb(166, 0, 196);">物理内存</span>中(不在jvm中)，创建的缓冲区称为直接缓冲区，可以进一步提高I/O的速度。 </div><div><br/></div><div><br/></div><div><span style="font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 18px; color: rgb(166, 0, 196); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">Buffer，顾名思义，缓冲区，实际上是一个容器，是一个连续数组</span></span><span style="font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">。</span></div><div>ByteBuffer aa= ByteBuffer.allocate(1024);</div><div>那么aa的底层就是一个byte数组</div><div>IntBuffer bb = IntBuffer.allocate(1024);</div><div>那么bb的底层也是一个数组，是一个长度为1024的int数组</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">Buffer:</span></div><div><span style="font-weight: bold;">1、Buffer中的四大属性</span></div><div style="margin-left: 40px;">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity</div><div style="margin-left: 40px;">private int mark = -1;  (默认值-1,表示没有标记)</div><div style="margin-left: 40px;">private int position = 0;</div><div style="margin-left: 40px;">private int limit;</div><div style="margin-left: 40px;">private int capacity;</div><div>    <img src="网络编程(马中华版)_files/Image [6].png" type="image/png" data-filename="Image.png" width="644"/></div><div><span style="font-weight: bold;">2、8个方法</span></div><div style="margin-left: 40px;">remaining() : 返回 limit - position</div><div style="margin-left: 40px;">capacity(): 返回capacity</div><div style="margin-left: 40px;">clear(): 清空Buffer, 准备进入写模式(position置为0, limit置为capacity)</div><div style="margin-left: 40px;">mark():  标记一个位置, 令标记mark = position。(一般用在读模式切换到写模式时)</div><div style="margin-left: 40px;">reset(): 令position = mark(一般用在写模式刚切换回读模式时)</div><div style="margin-left: 40px;">flip()  写模式转换为读模式。 (<span style="font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">limit = position;  position = 0;  mark = -1;</span>)。flip() 方法默认没读完的数据就不要了。</div><div style="margin-left: 40px;">rewind():  <span style="font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">将position重置为0，一般用于重复读。(position = 0;   mark = -1;)</span></div><div style="margin-left: 40px;">compact(): 紧凑。在写模式下, 把未读数据全部挪到ByteBuffer数组的最前端,腾出后面连续的区域来写数据, <span style="font-size: 18px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">新写入的数据将放到缓冲区未读数据的后面。(compact()在Buffer里没有, 是ByteBuffer的抽象方法, 有效的实现在HeapByteBuffer里才有)</span></div><div><br/></div><div><span style="font-weight: bold;">3、详解如下:</span></div><div>Buffer有两种模式:读模式、写模式。默认情况下是写模式。</div><div><br/></div><div><span style="color: rgb(255, 0, 0);">capacity</span>: 不会改变。就代表当前这个buffer的容量。</div><div>position和limit之间的区域代表的是可读可写的区域。在写模式下是可写区域, 在读模式下是可读区域。</div><div><span style="color: rgb(255, 0, 0);">position</span>: 在写模式下是可写区域的起始位置(也就是开始写的起始位置)。在读模式下是可读区域的起始位置(也就是开始读的起始位置)。position始终代表可以开始读(或开始写)的位置。</div><div><span style="color: rgb(255, 0, 0);">limit</span>: 在写模式下是可以写的区域的结束位置。在读模式下是可读区域的结束位置。</div><div><span style="color: rgb(255, 0, 0);">mark</span>: mark就是个标记, 用来在切换模式前(一般都是读模式切换到写模式)记录position读到了哪个位置(即令mark = position), 以便于由写模式恢复到读模式时, 就可以令position = mark, 就可以恢复到上次读到的位置。</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">(1)在写模式下, 写了一部分数据, 没有写到limit, 这时如果中止写, 切换到读模式, 则会令 limit = position , position =</span> <span style="color: rgb(255, 0, 0);">mark(并不是每次都是0)</span><span style="color: rgb(166, 0, 196);">。</span></div><div><span style="color: rgb(166, 0, 196);">(2)在读模式下, 读到一定位置, 数据没有全部读完: 如果没读完的数据还要, 则会令 mark = position, position = limit, limit = capacity; 如果没读完的数据不要了, 则令position = 0, limit = capacity。</span></div><div><span style="color: rgb(166, 0, 196);">然后一直重复以上(1)和(2)步骤。</span></div><div><img src="网络编程(马中华版)_files/Image [7].png" type="image/png" data-filename="Image.png" width="782"/></div><div><br/></div><div><img src="网络编程(马中华版)_files/buffer_rw.jpg" type="image/jpeg" data-filename="buffer_rw.jpg" width="732"/></div><div><br/></div><div>--------------------------------------------------------------------------------------------------------------</div><div>2、通道：Channel    </div><div><br/></div><div>Channel是一个通道，可以通过它读取和写入数据，它就像自来水管一样，网络数据通过Channel读取和写入。通道与流的不同之处在于通道是双向的，流只是在一个方向上移动（一个流必须是InputStream或者OutputStream的子类），而且通道可以用于读、写或者同时读写。因为Channel是全双工的，所以它可以比流更好地映射底层操作系统的API。</div><div><br/></div><div>Channel 用于向 buffer 提供数据或者读取 buffer 数据，buffer 对象的唯一接口。</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">常用的Channel ： </span></div><div>    FileChannel ：实现从文件读，或者向文件写</div><div>    SocketChanel ：通过TCP协议向网络的两端读写数据。<span style="color: rgb(166, 0, 196);">(客户端常用)</span></div><div>    ServerSocketChannel ：监听客户端发起的TCP链接，如果有链接请求，则为每个TCP连接创建一个新的SocketChannel来进行数据读写。<span style="color: rgb(166, 0, 196);">(服务端常用)</span></div><div>    DatagramChannel ：通过UDP协议向网络的两端读写数据</div><div>-------------------------------------------------------------------------------------------------------</div><div>3、多路复用器Selector</div><div><br/></div><div>多路复用器Selector是Java NIO编程的基础，熟练地掌握Selector对于掌握NIO编程至关重要。多路复用器提供选择已经就绪的任务的能力。简单来讲，Selector会不断地轮询注册在其上的Channel，如果某个Channel上面有新的TCP连接接入、读和写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。</div><div><br/></div><div>一个多路复用器Selector可以同时轮询多个Channel，由于JDK使用了epoll()代替传统的select实现，所以它并没有最大连接句柄1024/2048的限制。这也就意味着只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端，这确实是个非常巨大的进步。</div><div><br/></div><div>Selector在代码中的核心逻辑: </div><div style="margin-left: 40px;">Selector s = Selector.open();  //用open()方法得到一个Selector选择器</div><div style="margin-left: 40px;">while(true){</div><div style="margin-left: 40px;">    //下面这句相当于serversocket.accept()。只不过select()是轮询的方法, 不阻</div><div style="margin-left: 40px;">    //塞。参数1000表示每隔1秒轮询一次。</div><div style="margin-left: 40px;">    s.select(1000); </div><div style="margin-left: 40px;">    //下面的keys就是所有&quot;准备好了输入数据的客户端&quot;的集合</div><div style="margin-left: 40px;">    SelectionKey keys = s.selectedKeys(); </div><div style="margin-left: 40px;">}</div><div><br/></div><div><br/></div><div><br/></div><div>基于反应堆是什么意思？<span style="color: rgb(166, 0, 196);">反应堆其实就是指选择器Selector,</span> 如下面这句代码: </div><div>channel.register(s, SelectionKey.OP_READ) ;   </div><div>    channel是客户端或者服务端, <span style="font-size: unset; color: unset; font-family: unset;">s 是选择器(或者叫秘书、管家)</span></div><div>    <span style="color: rgb(166, 0, 196);">如果channel已经准备好了数据(不论是客户端的channel准备好了数据发送给服务端, 还是服务端的channel准备好了数据发送给客户端),</span>就可以将当前channel注册到s这个反应堆中去, 并指出自己接下来的操作类型(即SelectionKey的种类,即要进行的事件), <span style="font-size: unset; color: unset; font-family: unset;">SelectionKey就是可选择的键(事件), 也就是对应的channel要操作的模式,有四种类型：</span></div><div style="margin-left: 40px;">OP_READ  (读)</div><div style="margin-left: 40px;">OP_WRITE  (写)</div><div style="margin-left: 40px;">OP_CONNECT (连接)</div><div style="margin-left: 40px;">OP_ACCEPT (接收)</div><div>而上面的语句: SelectionKey keys = s.selectedKeys(); 就是取出来一堆已经注册的channel的事件的集合, 当调用到某个channel的key时(即使用key.channel()方法), 就是该注册好的channel的事件真正被使用(执行)的时候。</div><div><br/></div><div>将上面的核心逻辑代码调整为如下, 即是使用了反应堆(<span style="color: rgb(255, 0, 0);">基于反应堆其实就是一种</span><span style="color: rgb(166, 0, 196);">托管模式</span><span style="color: rgb(255, 0, 0);">, 将操作托管给第三方作为一个中间人, 不用自己什么事都管, 都交给中间人来协调</span>): </div><div>       <span style="color: rgb(166, 0, 196);">channel.register(s, SelectionKey.OP_READ);</span>     </div><div style="margin-left: 40px;">Selector s = Selector.open();  //用open()方法得到一个Selector选择器</div><div style="margin-left: 40px;">while(true){</div><div style="margin-left: 40px;">    //下面这句相当于serversocket.accept()。只不过select()是轮询的方法, 不阻</div><div style="margin-left: 40px;">    //塞。参数1000表示每隔1秒轮询一次。</div><div style="margin-left: 40px;">    s.select(1000); </div><div style="margin-left: 40px;">    //下面的keys就是所有&quot;准备好了输入数据的客户端&quot;的集合</div><div style="margin-left: 40px;">    SelectionKey keys = s.selectedKeys(); </div><div style="margin-left: 40px;">    <span style="color: rgb(166, 0, 196);">key.channel();</span></div><div style="margin-left: 40px;">}</div><div style="margin-left: 40px;"><br/></div><div><br/></div><div><br/></div><div><a href="网络编程(马中华版)_files/Java-part3-基础增强--IO.pdf"><img src="网络编程(马中华版)_files/d0ac97682e66e78b616eabebe7391088.png" alt="Java-part3-基础增强--IO.pdf"></a></div><div><br/></div></span>
</div></body></html> 