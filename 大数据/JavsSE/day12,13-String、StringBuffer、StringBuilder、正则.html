<html>
<head>
  <title>day12,13-String、StringBuffer、StringBuilder、正则表达式、包装类、日期时间的各种类</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="6049"/>
<h1>day12,13-String、StringBuffer、StringBuilder、正则表达式、包装类、日期时间的各种类</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/8/1 8:53</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/4/5 13:56</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>String类:</div><div>    是一个不可变类(即字符串对象一旦创建,对象的字符序列就不能更改) </div><div><br/></div><div>    创建一个字符串的两种方式如下: </div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image.png" type="image/png" data-filename="Image.png"/></div><div style="margin-left: 40px;">上图其实很好理解,String是个引用数据类型,而引用类型本来就是一个类, 所以当然可以通过第二种方式来创建一个字符串, <span style="font-size: unset; color: unset; font-family: unset;">这就是创建了一个String对象。而第一种方式中,因为赋值运算符左边是定义了一个引用,而右边是在方法区里新建了一个对</span><span style="font-size: unset; color: unset; font-family: unset;">象, 所以&quot;hello&quot;其实也是创建了一个对象(和new String(&quot;hello&quot;)的效果类似但不完全一样),创建的是一个&quot;特殊的对象&quot;,这是</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">String类独有的创建对象的方式,</span><span style="font-size: unset; color: unset; font-family: unset;">(</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">因为String比较常用,所以</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">这也是为了和基本数据类型赋值的方式一样, 简单方便的使用; 而</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">其他的类都是通过new来创建的,无一例外</span><span style="font-size: unset; color: unset; font-family: unset;">), 和其他类创建对象的方式完全不同。这种创建String类对象的方式的判断依据是, 只要被双引号引起来的一串字符,编译器就会将它作为一个String对象, 既然是一个对象那么就可以通过&quot;对象.成员&quot;的方式调用类中的成员,如下图:</span></div><div>    <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>    但要注意的是: 上面两种创建字符串的存储方式是不同的,第二种方式是标准的创建对象,自然是存在堆里的,而第一种方式创建<span style="font-size: unset; color: unset; font-family: unset;">的字符串对象则是存在方法区里的常量池里,所以为什么说双引号引起来创建的String类对象是一个特殊的对象。</span></div><div>    <span style="color: rgb(255, 0, 0);">常量池</span>: 方法区里面有块区域,专门用来维护常量数据的。维护在编译期能够确定的并且能够存储在字节码中的数据(即必须是带final的 类、接口、方法以及变量,并且要在编译期能够确定的,有的带final的不一定能在编译器确定)。既然是常量池,也就是说里面的变量都是带final关键字的,这也是为什么说String类的对象的字符序列不可更改的原因(而且用<span style="color: rgb(166, 0, 196);">第</span><span style="color: rgb(166, 0, 196);">二</span><span style="color: rgb(166, 0, 196);">种方式</span>创建的String对象存储在的char[]数组也是带final关键字的,即不可更改的,但要注意,<span style="color: rgb(255, 0, 0);">字符串在常量池里的存储方式是以</span><span style="color: rgb(255, 0, 0); font-weight: bold;">对象</span><span style="color: rgb(255, 0, 0);">的方式存储的,而不是以char[]数组的形式存储的, 否则怎么可以用&quot;字符串.成员&quot;这种方式调用String类的方法</span>)。 所以常量池只有在池里不存在相应的字符串常量时才会新建该字符串常量,存在的话是不会创建的,直接引用已创建好的。这样的好处就是可以避免频繁的创建和销毁对象,减少系统的消耗。</div><div><br/></div><div>    <span style="color: rgb(166, 0, 196);">第一种创建字符串的方式是</span>: 先在栈里创建引用变量s1, 然后创建&quot;hello&quot;对象时首先会去常量池里面搜索一下有没有&quot;hello&quot;对象, 如果没有,则新建一个&quot;hello&quot;对象,并将s1指向新建的对象; 而如果&quot;hello&quot;对象已经存在的话就直接将s1指向已经存在的&quot;hello&quot;对象即可,不用新建。但要注意, 这样的话,相同的字符串常量的引用指向的就是同一个地址了, 如果进行某种修改, 则他们都会被修改(实际上也只有通过反射才能修改, 否则直接修改的话, 修改后会直接在常量池里创建一个新的的字符串常量,将进行修改操作的字符串引用指向新的字符串常量)。</div><div>    而其实<span style="color: rgb(166, 0, 196);">第二种创建字符串的方式就是</span>: 先在栈里创建引用变量s2, 然后在堆里创建String类的对象, 创建对象时也会在方法区的常量池里寻找有没有&quot;hello&quot;对象,有的话在String类的对象里会有一个引用指向&quot;hello&quot;, 常量池没有的话就新建一个&quot;hello&quot;对象并让String对象里的那个引用指向它。 注意:<span style="font-size: 12px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(239, 240, 242);"><span style="background-color: rgb(239, 240, 242); font-family: system, -apple-system, BlinkMacSystemFont, &quot;Helvetica Neue&quot;, Helvetica, &quot;PingFang SC&quot;, &quot;Segoe UI&quot;, &quot;Microsoft YaHei&quot;, &quot;wenquanyi micro hei&quot;, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, Roboto, Oxygen, Ubuntu, Cantarell, &quot;Fira Sans&quot;, &quot;Droid Sans&quot;, Arial, sans-serif; font-size: 12px; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; color: rgb(255, 0, 0);">在堆处创建的其实是String常量池中的String对象的一个引用,然后将这个引用直接指向常量池。验证方法是创建一个类，包含成员变量String value=&quot;字面量&quot;，和 String str = new String(&quot;字面量&quot;)。然后创建这个类的实例化对象，再通过反射去修改类中的value值，发现str的值也被修改了，充分说明它们最终指代的是同一个String，只是对于new操作，多了在堆中创建一个引用对象的中间步骤。value直接指代字符串常量池中的String对象，str指代堆中的引用对象，引用对象指代字符串常量池中的String对象</span></span></div><div>    所以第一种方式的优势是,直接将引用变量指向常量池里的字符串常量(对象),而不用像第二种方式一样,每次创建字符串(即使是同一个字符串,比如用第二种方式创建两个&quot;hello&quot;字符串)都要在堆里先新建一个对象(只要new一次就在堆里创建一个新的对象),然后再将该对象里的一个引用指向常量池里的字符串常量(对象),虽然因为常量池的机制可以重复利用字符串常量, 但是第二种方式每次新建对象使用的堆空间还是实打实的比第一种方式多出来的。也就是说第一种方式是直接指向常量池,第二种方式是先指向堆,再指向常量池。</div><div>    <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [2].png" type="image/png" data-filename="Image.png" style="color: unset; font-family: unset; font-size: unset;" width="903"/></div><div>    创建空串的两种方式如下s3和s4所示。注意创建了空串(s3、s4)和指向了空对象(s4)的区别, 指向了空对象是没有创建对象的, 而空串好歹<span style="font-size: unset; color: unset; font-family: unset;">创建了对象 </span></div><div>     <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>    看String类的定义就知道,字符串其实存储在一个char[]数组里(注意是带final的,所以为什么说String对象的字符序列不可更改), 当然这是针对jdk8.0来说的,后面的版本有所更改,会将字符串存储在了byte[]数组里, 这是为了节省空间, 因为一个char占两个字节而一byte只占一个字节</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>&quot;==&quot;对于基本数据类型来说判断的是值是否相等,因为基本数据类型里面存的就是值, 而对于引用类型来说,引用类型存的是地址,所以判断的是是否是同一地址, 或者说是否是同一个对象。而因为常量池的存在,下图中的s和s5就会是同一对象了,而s2和s7当然不是同一对象,而因为s2的引用是指向堆里的对象的原因(对象里才有个引用指向常量池),所以s和s2也必然不是同一个对象。(如果是equals的话则这几个比较的值全部会返回true)</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [5].png" type="image/png" data-filename="Image.png" width="573"/></div><div><br/></div><div><br/></div><div>因为常量池的存在,String对象的字符序列是不可更改的, 所以会出现如下图情况。在str1做了字符串拼接的操作后, str1输出的结果还是str1。而第三行代码的作用就是在常量池里创建了一个新的对象&quot;helloabc&quot;,但没有引用指向它</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>稍微改下代码,让str1指向新的对象&quot;helloabc&quot;, 则此时str1才会输出为helloabc</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [7].png" type="image/png" data-filename="Image.png" width="579"/></div><div>所以说String类型的字符序列进行频繁的更改的话,它只会不断的创建新的对象,而根本不会修改原字符序列,。所以String不适合字符序列做频繁更改的情况,这样系统消耗会特别大, 会大量创建和销毁新对象, 会影响系统性能</div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">java中所有的</span><span style="color: rgb(255, 0, 0); font-weight: bold;">方法,只要是</span><span style="color: rgb(255, 0, 0); font-weight: bold;">取某个范围内的,它所取的区间都是左闭右开(前闭后开)的,即取的值包括起始位置,但不取终止位置。如下面的substring()方法</span></div><div><br/></div><div>String类的方法:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [8].png" type="image/png" data-filename="Image.png" width="748"/></div><div><span style="color: rgb(166, 0, 196);">contentEquals()</span><span style="color: rgb(255, 0, 0);">方法可以比较当前String类型的字符串是否和StringBuffer、StringBuilder类型的字符串相等。参数就是StringBuffer或者StringBuilder。</span></div><div><br/></div><div>replace(old,new)中,为了方便记忆,就直接new和old就传字符串即可,毕竟在同时支持输入参数是char和String时, 单引号引起的一个char字符和双引号引起的只有一个字符的String字符串是一样的,都能达到效果,那么就只用String作为输入更加好记忆, 比如说输入参数是'c'和&quot;c&quot;是在方法中起到一样的效果。indexOf()和lastIndexOf()方法也是一样的道理, 可以只用字符串类型来传参。<span style="color: rgb(166, 0, 196);">同时, String类的所有的方法, 若需要传参的话,都支持传String类型的参数, 所以传参时能用String类型传就用String类型传,都优先考虑同一种数据类型, 也方便记忆。</span></div><div><br/></div><div>indexOf()举例(lastIndexOf()是类似的): (下面的例子中,每 条输出语句后面是其输出的值)</div><div>    当然如果传入的参数是字符<span style="color: rgb(166, 0, 196);">子串</span>的话,返回的结果就是字符<span style="color: rgb(166, 0, 196);">子串</span>中的第一个字符在当前字符串中的位置索引(如下图中的第二条输出语句)</div><div>    (int类型转char会丢失精度,不建议用int类型作为参数)</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [9].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>去除字符串中所有空格的方法:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [10].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>endsWith()和startsWtih()非常有用,尤其是endsWith(),可以用来判断是否是某个后缀名的文件,比如是不是以&quot;.txt&quot;结尾, 这些都可以判断,如下图:(下图中两个语句都返回true)</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [11].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>compareTo()比较大小时, 比较的规则是按照两对应位字符的ASCII码的大小进行比较, 字符对应的ASCII码大则认为该字符更大。比较的方式是两字符串的对应位一位一位比较的,当第一次出现不相等的对应位时,则不再比较。当前字符串的该对应位字符 大于 参数字符串的该对应位字符, 则返回正数, 反之则返回负数。如果比较到了最后一位字符都一直相等, 只有全部位都相等并且等长时,才认为两字符串相等,返回0。如果比较到了字符串a的最后一位都一直相等,但此时字符串b还有字符, 则认为字符串b更大。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [12].png" type="image/png" data-filename="Image.png" width="587"/> </div><div>下图是compareTo的源码:</div><div>    可以发现返回值实际上有两种情况:</div><div>        (1)当前字符串和参数字符串对应位字符出现不相等时,当前字符串的该字符-参数字符串的该字符, 得出的结果也就是两字符ASCII码的差值。ASCII码大则谁大。</div><div>        (2)比较到某字符串的最后都相等时, 用当前字符串的长度-参数字符串的长度, 也就是说哪个字符串长则谁大。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [13].png" type="image/png" data-filename="Image.png" width="586"/></div><div><br/></div><div>toCharArray()使用举例: </div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>split()举例:</div><div>    注意split()传参时只能是String类型而不能是char类型, 即使分隔符是一个字符也不能传char</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [15].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>contains()举例:</div><div>    contains()的参数也不能传char类型</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [16].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>StringBuffer:</div><div>    可变字符串类。意味着它创建对象后它的字符串序列是可以更改的, 如果字符串需要频繁更改,用StringBuffer的效率明显要高于String类</div><div><br/></div><div>看下面的StringBuffer的例子:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [17].png" type="image/png" data-filename="Image.png"/></div><div>  当append后的字符串的长度超过了<span style="color: rgb(255, 0, 0);">容量(即字符数组的长度)</span>时会进行扩容  扩容容量大小是（字符数组的长度 * 2） + 2   ,但扩容的<span style="font-size: unset; color: unset; font-family: unset;">上限是： Integer.MAX_VALUE 。超过这个则会抛OOM异常。并且扩容调用的是</span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); font-family: &quot;Courier New&quot;;">Arrays.</span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); font-family: &quot;Courier New&quot;; font-style: italic;">copyOf()</span>将原先的数组复制到新容量的数组并覆盖原先的字符数组value,如下:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [18].png" type="image/png" data-filename="Image.png"/></div><div>    这也是为什么append可以不用写成<span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); color: rgb(63, 127, 95); font-family: &quot;Courier New&quot;;">sf1 = sf1.append(&quot;hello&quot;);</span>的原因。</div><div><br/></div><div>频繁的扩容(扩容会使用<span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); font-family: &quot;Courier New&quot;;">Arrays.</span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); font-family: &quot;Courier New&quot;; font-style: italic;">copyOf()</span>进行数组复制)也是会影响性能的, 所以如果你知道字符串需要一直增长,则最好趁早定好字符串容量(字符数组的长度)的上限,则可以避免多次的扩容(数组复制)操作,可以优化性能。如下就是预先定义字符数组长度为100。等到超过100,才会出现扩容的情况。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [19].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>StringBuffer类中的方法:  </div><div style="margin-left: 40px;">toString(): 将StringBuffer类型的对象转换为String类型的对象。 </div><div style="margin-left: 40px;">capacity(): <span style="font-size: unset; color: unset; font-family: unset;">无参方法。查看当前字符串所使用的字符数组的length(即容量)</span></div><div style="margin-left: 40px;">trimToSize(): <span style="font-size: unset; color: unset; font-family: unset;">无参方法。将字符数组的length缩小为 当前字符串的字符的个数。如果引用该字符串的变量多可以这么做,但一般没必要。如:</span></div><div>        <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [20].png" type="image/png" data-filename="Image.png"/></div><div style="margin-left: 40px;">append(): </div><div style="margin-left: 40px;">在当前字符串的<span style="color: rgb(166, 0, 196);">末尾</span>追加字符串或者字符。除了上面常用的方法外, 还有很多重载方法。</div><div style="margin-left: 40px;">insert(): 在当前字符串的某个位置插入字符串或字符。多重载方法。</div><div style="margin-left: 40px;">setCharAt() :  修改当前字符串中的指定位置的字符。传参的第二个参数只能传字符不能传字符串</div><div style="margin-left: 40px;">deleteCharAt(): 删除当前字符串指定位置的字符。</div><div style="margin-left: 40px;">delete(): 删除指定范围内的字符序列</div><div style="margin-left: 40px;">reverse(): 无参方法。反转当前字符串。</div><div style="margin-left: 40px;">charAt()、indexOf()、lastIndexOf()用法和String类的方法一样。</div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">StringBuilder类和StringBuffer类中的方法数量几乎一模一样, 大部分</span><span style="color: rgb(255, 0, 0); font-weight: bold;">StringBuffer的方法</span><span style="color: rgb(255, 0, 0); font-weight: bold;">StringBuilder都有,而且</span><span style="color: rgb(255, 0, 0); font-weight: bold;">名字一样,方法用法也一样。(至少上面这些列举的方法</span><span style="color: rgb(255, 0, 0); font-weight: bold;">StringBuilder都有。</span><span style="color: rgb(255, 0, 0); font-weight: bold;">)</span></div><div><br/></div><div>StringBuffer的这些方法的使用举例:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [21].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div>--------------------------------------------------------------------------------------------------------------------------------------------</div><div>String:</div><div>  表示一个字符串类型</div><div>  不可变类，</div><div>  频繁 更改 字符串的字符序列 时，只会<span style="font-size: unset; color: unset; font-family: unset;">创建新的对象。</span></div><div><br/></div><div>StringBuffer 和 <span style="font-size: unset; color: unset; font-family: unset;">StringBuilder</span></div><div>  如果需要频繁更改 字符串的 字符序列，则使用这两个。</div><div><br/></div><div>StringBuffer和StringBuilder的区别:</div><div>  StringBuffer 线程同步，多线程，线程安全，但这样速度也会慢下来一些。</div><div>  StringBuilder 线程非安全，但速度快, 适用于单线程的情况下。</div><div><br/></div><div>-----------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>System类的两个方法:</div><div style="margin-left: 40px;">System.currentTimeMillis() : 当前时间的毫秒值。该毫秒值时从1970.01.01 00:00:00到现在时间 的毫秒的总值。</div><div style="margin-left: 40px;">    可以用下面的方法来计算某段代码所使用的毫秒值。即在该段代码开始前记录一下毫秒值, 在该段代码结束后再记录一下毫秒值,两次毫秒值的差值即为该段代码的执行毫秒数。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [22].png" type="image/png" data-filename="Image.png"/></div><div style="margin-left: 40px;">System.nanoTime() : 当前时间的纳秒值。比毫秒更加精确, 但是相比较于毫秒值, 纳秒值用的比毫秒值少,因为纳秒和毫秒都需要底层操作系统的支持,而好多操作系统都不支持纳秒。</div><div>-----------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>正则表达式：</div><div><br/></div><div>为什么要用正则表达式?</div><div>比如说如果要做登录验证, 虽然用各种判断条件可以达到验证的目的,但如果限制较多, 那么要写的代码就会很多 ,而且还可能漏掉某些情况, 而正则表达式则可以用简洁的代码做到严谨的验证机制。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [23].png" type="image/png" data-filename="Image.png" width="547"/></div><div><br/></div><div>正则表达式的规则: </div><div><br/></div><div><br/></div><div>[ ]  是表示枚举的方式。 <span style="font-size: unset; color: unset; font-family: unset;">如 [abc] 表示只能匹配 a,b,c中的任意的</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">一个</span><span style="font-size: unset; color: unset; font-family: unset;">字符</span></div><div>[-]  是表示范围。   如[a-z]表示只能匹配 a-z 范围内的任意的<span style="color: rgb(166, 0, 196);">一个</span>字符</div><div>[^]  是表示否     如[^a-z] 表示匹配的是: 不是a-z范围内的任意的<span style="color: rgb(166, 0, 196);">一个</span>字符</div><div><br/></div><div>{n}   它前一项的的匹配次数为n次    </div><div>    如邮政编码限制为6位数字,可写成: [0,9]{6}</div><div><br/></div><div>更多规则如下:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [24].png" type="image/png" data-filename="Image.png" width="607"/></div><div><br/></div><div>java中写一个正则表达式的方式:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [25].png" type="image/png" data-filename="Image.png"/></div><div>    例子:  (验证邮政编码)</div><div>        输入错误是:</div><div>        <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [26].png" type="image/png" data-filename="Image.png" width="583"/></div><div>        输入正确时:</div><div>        <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [27].png" type="image/png" data-filename="Image.png" width="583"/></div><div><br/></div><div><br/></div><div>    同一个例子改写: (注意 , \d{6}等价于 [0-9]{6} ,但Java中反斜杠需要转义, 需要注意)</div><div>    <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [28].png" type="image/png" data-filename="Image.png" width="543"/></div><div><br/></div><div>常见正则表达式验证举例:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [29].png" type="image/png" data-filename="Image.png" width="612"/></div><div>-------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>包装类：</div><div><br/></div><div>每一个基本数据类型都为它设计了一个包装类。基本数据类型只是一个关键字, 基本数据类型关键字只能用来表示一种数据类型或者说声明一种数据类型, 其他什么都做不了。而如果想对这些基本数据类型的变量有更多的操作或调用一些方法则需要用到包装类,因为只有类中才有属性和方法这样的东西,关键字是没有的。所以很多时候我们需要把基本数据类型的变量变成对象来使用,就需要&quot;包装&quot;成对象了。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [30].png" type="image/png" data-filename="Image.png"/></div><div>这8种基本数据类型的包装类和String类一样, 是不可变类(即被final修饰)。所以,也就意味着, 这些基本数据和String一样, 有两种创建&quot;对象&quot;的方法(当然基本数据类型并不是对象,而只是一种变量,因为双引号引起来的变量比如&quot;sdc&quot;直接在后面加个 . 就可以开始调用方法了,说明双引号引起来就表示它是一个对象。而这些基本数据类型,比如int型的123后面加个 . 就没有任何作用, 毕竟谁知道你数字后面加个 . 是不是表示这是一个小数。但就算是char型比如'c'后面加个 . 也没有任何属性和方法可调用,所以基本数据类型都不是对象, 而仅仅只是个变量<span style="font-size: unset; color: unset; font-family: unset;">)。</span></div><div>但基本数据这两种方法又和String类型的两种创建对象的方法不同,实际上有本质差别。基本数据类型的两种方法一种是定义并初始化一个变量, 而另一种则是创建一个对象。如下:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [31].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">装箱：把基本数据类型包装成对象。</span></div><div>下面是两种基本的装箱方式: </div><div>第一种是通过将基本数据类型通过传参给构造方法的方式创建对象, </div><div>第二种就是调用Integer类的静态方法valueOf()创建对象</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [32].png" type="image/png" data-filename="Image.png"/></div><div>还有一种自动装箱的方式, 这种方式会隐式的调用Integer.valueOf()方法, 下面两种写法是等价的:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [33].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">拆箱：把包装类对象中的数值取出来。</span></div><div>拆箱和装箱一样, 也分为拆箱和自动拆箱,只不过拆箱只有一种方式,不像装箱有两种。拆箱是调用intValue()方法。自动拆箱则和自动装箱一样,也是隐式调用某方法, 自动拆箱就是隐式调用了intValue()方法。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [34].png" type="image/png" data-filename="Image.png"/></div><div><span style="color: rgb(166, 0, 196);">实际使用时,都是自动拆箱和自动装箱用的多, 要能理解这种简单的赋值形式为什么可以使用。都是因为隐式调用了某个方法。</span></div><div>下图依然是装箱和拆箱的例子:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [35].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>---------------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>因为包装类是不可变类, 所以也跟String类一样, 也支持常量池的技术, 也就是说一些比较常用的数据已经预先在常量池里缓存好了, 除了 Float类和Double类以外,其他的包装类都有缓存。</div><div><br/></div><div>boolean 是预先缓存了的, 因为它的结果也很简单,当然先缓存好, 它的所有值就一个0和一个1,对应false和true。 </div><div>整数(包括byte、short、int、long)：他们这几种类型在常量池里预先缓存好的范围是:  -128 到 127。其他值如果还需要就需要</div><div>char类型预先缓存的是: ASCII码为 0 - 127范围内的字符</div><div>如果用自动装箱或者用valueOf()方法装箱一个基本数据类型时(用&quot;new&quot;来装箱的方式是不行的,这样必然新建一个对象), 对应的基本类型的值是以上的范围内的量, 则不会新建对象,直接在常量池里面取即可。</div><div><br/></div><div><span style="color: rgb(209, 0, 255);">注意</span>: 以上说的是具体的数据类型的值的范围, 但实际上是各个包装类里的一个个对象里面存了这些值。范围里有多少个值,则该基本类型所对应的包装类就预先缓存了多少个对象。所以,我们所说的不会新建对象, 是<span style="color: rgb(166, 0, 196);">只</span>指用包装类的自动装箱和valueOf()方法装箱时(如Integer i = new Integer(5)),而不是用基本数据类型定义并初始化变量时(如 int i = 5;<span style="font-size: unset; color: unset; font-family: unset;">)。基本数据类型定义并初始化时跟对象根本没关系,也就没有什么新不新建对象的事了,所以上面所说的常量池有没有缓存这件事跟他们没关系。基本数据类型的定义的数据都是直接以值的方式存在栈里的, 所以也不会去调用常量池里的对象。</span></div><div><br/></div><div>这种预先在常量池里缓存的情况, 我们从Integer的valueOf()方法就看的出来, 这里的Integer对象,从low到high相应的int值的大小已经缓存好了,保存在cache里。这里的low==-128, high==127,而cache是一个final修饰的数组, 数组里存的元素是一个一个的Integer对象, 而这些对象对应的int值正好是从-128到127。</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [36].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>举例说明常量池里到底有没有预先缓存,以及什么情况会用预先缓存的数据: </div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [37].png" type="image/png" data-filename="Image.png"/></div><div>    上图中, 22是属于-128~127范围内的, 所以不会新建Integer对象,而是直接引用常量池里的,所以i1和i2都会引用常量池里的同一个对象。而456不属于那个范围, 所以要创建Integer对象, 所以i3和i4要创建两个对象。而从i5和i6可以看出来, 即使22在那个范围里, &quot;new&quot;这种装箱的方式也不会使用常量池里已经预先缓存好的Integer对象里,毕竟&quot;new&quot;这个关键字就是用来创建(新建)对象的,所以必然会是使用新对象(此时的int类型的值22应该是会直接保存在堆里的Integer对象里 (而不会去像String类一样,再在对象内部用一个引用来引用常量池的int类型的数据22),而且常量池里也并没有int类型的值,只有Integer类型的对象)。</div><div><br/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>查看各个基本类型的表示范围的方法: (所有包装类都类似)</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [38].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>字符串转数字的三种方法:  (注意num2和num3都用到了自动拆箱)</div><div style="margin-left: 40px;">num1这种方法是最常用的。字符串转其他数字类型如double的方法则是Double.parseDouble(s);  转float则是Float.parseFloat(s);  。都是类似的</div><div>    <img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [39].png" type="image/png" data-filename="Image.png"/></div><div style="margin-left: 40px;">上图中,num2实际上就是valueOf(int)的重载方法valueOf(String)-先用parseInt()方法把s转换为数字, 再调用valueOf(int)方法, 如下图。num3所用的构造方法也是这个套路,所以还不如直接用parseInt效率高, 也不用再用一步拆箱的操作</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [40].png" type="image/png" data-filename="Image.png"/></div><div>数字转字符串的各种方法:</div><div>    s1的字符串拼接是最常用的,直接拼接一个空串即可</div><div><span style="color: rgb(166, 0, 196);">    从s2可以看出, 可以转字符串的类都有个toString()方法将其对象转换为字符串</span></div><div>    <span style="color: rgb(166, 0, 196);">从s3可以看出, valueOf()真是啥类型都可以&quot;装箱&quot;成valueOf()所在的类的对象。基本上可以进行类型转换的类都有个</span><span style="color: rgb(166, 0, 196);">valueOf()函数来将别的类型转换为自己这个类的类型</span></div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [41].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>包装类中的进制转换方法:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [42].png" type="image/png" data-filename="Image.png"/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------------</div><div>日期时间： (如何获取系统的当前日期和时间)</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">第一种用于日期时间的类库:</span></div><div>父类是 java.util.Date类</div><div>下面三个类是java.util.Date类的子类, 都位于java.sql包中:</div><div>     Date(只表示日期)     Time(只表示时间)    Timestamp(日期+时间)  </div><div><br/></div><div>java.util.Date的应用举例</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [43].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>java.util.Date的三个子类的应用举例: (注意, 下图中除第一行代码外的三个类都是来自java.sql包中的, 尤其注意下图中的dt1对象对应的Date类,注意和java.util.Date类进行区分)</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [44].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">日期的格式化</span><span style="color: rgb(166, 0, 196);">: (下面这些类都位于java.text包中)</span></div><div>格式化类的继承结构如下图所示。Format类我们用的最多的就是他的两个子类NumberFormat和DateFormat, 而NumberFormat类中用的最多的格式化类是DecimalFormat, DateFormat类用的最多的格式化类是SimpleDataFormat。</div><div style="margin-left: 80px;">                      Format</div><div style="margin-left: 80px;">                            |</div><div style="margin-left: 80px;">NumberFormat       DateFormat</div><div style="margin-left: 80px;">          |                                 |</div><div style="margin-left: 80px;">DecimalFormat       SimpleDateFormat</div><div><br/></div><div>SimpleDateFormat中的各种格式的表示形式如下:</div><div>    年: y     月: M     日: d     时:h(h是12小时制,H则是24小时制)      分: m     秒: s     毫秒: S </div><div>    (从上面可以看出,之所以用大写的&quot;M&quot;来表示&quot;月&quot;,是因为小写的&quot;m&quot;要表示&quot;分&quot;。准确的来说&quot;S&quot;并不是表示毫秒,要格式化正好取秒的小数点后三位时才是表示毫秒)</div><div>    想展示几位, 就用上面的字母占几位, 就像下图这样:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [45].png" type="image/png" data-filename="Image.png"/></div><div>    所以如上图所示, 这种方法可以用来格式化父类java.util.Date的时间格式。</div><div><br/></div><div><span style="color: rgb(166, 0, 196);">Calendar类:</span></div><div>    注意到上面的java.util.Date类的很多方法都已经弃用了,现在已经可以用java.util.Calendar类来代替Date类的功能了,而Calendar类是一个抽象类,所以Calendar类不能用new来创建自己的对象,可以通过静态方法getInstance()方法来得到一个对象,但其实得到的这个对象也是它的子类的对象(要注意Calendar类并不是单例模式, 因为它不是只允许系统中只能有唯一一个Calendar对象<span style="font-size: unset; color: unset; font-family: unset;">)。</span></div><div><br/></div><div><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">需要注意的是: 抽象类(或接口)是不能创建对象, 但能引用它的子类(或实现类)的对象，也就是说, 抽象类(或接口)的引用如果要用new来得到对象时, 赋值运算符后边的new不能是new他们自己，但可以new他们的非抽象的子类(或实现类)。形如:</span></div><div><span style="color: rgb(255, 0, 0);">    抽象类 抽象类的对象 = new 该抽象类的非抽象子类() </span></div><div><br/></div><div>下面是Calendar类的常用方法:(需要注意的是Calendar是JDK8.0之前就支持的获取日期时间的方法)</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [46].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><span style="color: rgb(166, 0, 196);">LocalDate、LocalTime、LocalDateTime三个类:</span></div><div>(这三个类都位于java.time包中,这是JDK8.0版本新增的获取日期时间的方法,比Calendar更加简便)</div><div>三个类的具体使用见如下</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [47].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [48].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [49].png" type="image/png" data-filename="Image.png"/></div><div>还有一个同样位于java.time包中的Duration类也很好用:</div><div><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/Image [50].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div style="text-align: center;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">——————————————————————</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手写与上传资料分割线</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(134, 0, 164); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">—————————————————————</span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><a href="day12,13-String、StringBuffer、StringBuilder、正则_files/day10 - LIU_API.pdf"><img src="day12,13-String、StringBuffer、StringBuilder、正则_files/c82dcef0f676efb30d4de4b2721e2e6b.png" alt="day10 - LIU_API.pdf"></a></div><div><br/></div></span>
</div></body></html> 