<html>
<head>
  <title>day20-网络编程</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="7305"/>
<h1>day20-网络编程</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/12/18 17:14</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/4/7 10:01</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div><span style="font-size: unset; color: unset; font-family: unset;">网络：一组网线连接的计算机。</span></div><div><br/></div><div>网络的作用：</div><div>  1.资源共享；</div><div>  2.信息传输；</div><div>  3.分布式处理；</div><div>  4.综合信息处理。比如对货物的跟踪处理</div><div><br/></div><div>internet:互联网</div><div>     </div><div>Internet：因特网,因特网是互联网众多网络中最大的一个。</div><div>  </div><div>www:万维网, 万维网是因特网的一个服务, 也就是我们常说的web网, 万维网这个服务的作用是使客户端可以通过浏览器去访问服务端的信息, 获得服务端的资源。对于英特网的服务来说, 除了万维网还有其他的, 比如文件传输的ftp, 还有邮件服务的,远程登录之类的服务</div><div><br/></div><div>协议： 网络中计算机之间通信的规则。</div><div><img src="day20-网络编程_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>  IP：只要 在网络中的计算机遵循了IP协议, 就能进行信息的传输</div><div>  TCP: 控制传输数据的准确性。所以遵循了TCP/IP协议, 不但能传输信息, 还能保证信息传输的准确性了。</div><div>  HTTP: 可以通过超链接打开网页(通过超链接准确定位到网页)</div><div>FTP: 传输文件</div><div>SMTP: 传输邮件</div><div><br/></div><div>  </div><div>-------------------------</div><div>IP地址：</div><div>  标识 网络中 的一个通信实体。</div><div><img src="day20-网络编程_files/Image [1].png" type="image/png" data-filename="Image.png" width="668"/>  </div><div><br/></div><div><span style="color: rgb(255, 0, 0); font-weight: bold;">网络编程用到的类都位于java.net包下。</span></div><div>下面有一个获取IP地址的类:</div><div><img src="day20-网络编程_files/Image [2].png" type="image/png" data-filename="Image.png" width="428"/></div><div>使用如下: 可以打印出本机的主机名和IP地址之类的信息(不过不知道为什么打印的是我的虚拟机的虚拟网卡的地址???)</div><div><img src="day20-网络编程_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><img src="day20-网络编程_files/Image [4].png" type="image/png" data-filename="Image.png" width="708"/></div><div>端口号分布在 0~65535 之间, 前1024个端口是已经给tcp/ip预留的端口,已经预置相应的程序功能。 </div><div><br/></div><div>域名其实对应的也是一个IP地址(也可能是多个, 因为很多网站都有多台服务器),域名和IP地址的对应是通过域名解析器(DNS)来解析实现的。</div><div>我们可以通过IP地址找到我们要访问的那台服务器(或计算机), 但是要具体与该服务器里的哪个程序通信, 要通过端口号才能访问到。</div><div>域名不完全等于网址(URL), 有的网址很长, 带有很多&quot;?&quot;和&quot;#&quot;这样的符号, 那么这样的中的前半段才是真正的域名, 后面的&quot;?&quot;和&quot;#&quot;这样的内容已经对应于该域名中具体的某个资源了。</div><div><br/></div><div><br/></div><div>URL：统一资源定位符。</div><div><img src="day20-网络编程_files/Image [5].png" type="image/png" data-filename="Image.png" width="675"/></div><div>URL格式: protocol :// hostname[:port] / path / [?query]#fragment</div><div>protocol: 协议(如http)</div><div>hostname: 主机(可以是主机名或者是ip),表示的是资源所在的服务器</div><div>port: 端口,标识与主机上的哪个程序进行通信</div><div>path: 路径。比如访问的是哪个盘下的哪个文件或文件夹。</div><div>query: 指定查询字符串, 比如需要查询某个内容时可以直接指定</div><div>fragment: 片段。指定我们要查询的资源的具体的位置, 可以定位到某个文件的某一页的某个具体的段落。</div><div><br/></div><div>上图中的相应的get方法就是相应的得到上面这些内容。举例如下:</div><div><img src="day20-网络编程_files/Image [6].png" type="image/png" data-filename="Image.png"/></div><div>打印结果如下:</div><div><img src="day20-网络编程_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><img src="day20-网络编程_files/Image [8].png" type="image/png" data-filename="Image.png" width="357"/></div><div><br/></div><div>可以直接将URL中的资源下载, 但要注意的是: 如果URL指向具体的资源,则下载的是具体的资源, 如果指向的是网页, 则下载的就是网页了。下图就是下载一张图片到本地磁盘的例子:</div><div><img src="day20-网络编程_files/Image [9].png" type="image/png" data-filename="Image.png" width="791"/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------</div><div><br/></div><div>网络编程:  (基于tcp/ip协议)</div><div><img src="day20-网络编程_files/Image [10].png" type="image/png" data-filename="Image.png" width="557"/></div><div>基于tcp/ip的好处是传输数据非常准确, 坏处就是很容易阻塞, 因为如果接收数据的一端一直没有响应的话, 发送方会一直阻塞等待, </div><div>而基于UDP的话好处自然是不容易阻塞了, 因为发送方将数据发送出去后, 它就不管了, 也不管接收方有没有接收到,但这样的坏处就是不可靠。</div><div>所以tcp/ip传输速度总的来说是慢于udp的。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>编写的程序有两种模式:</div><div>C/S</div><div>  客户端 (即要装一个软件,如QQ)</div><div>  服务器</div><div><br/></div><div>B/S</div><div>  浏览器</div><div>  服务器</div><div><br/></div><div><img src="day20-网络编程_files/Image [11].png" type="image/png" data-filename="Image.png" width="548"/></div><div><img src="day20-网络编程_files/Image [12].png" type="image/png" data-filename="Image.png" width="658"/></div><div>Socket类作为客户端, 客户端的功能用该类实现;</div><div><span style="font-size: unset; color: unset; font-family: unset;">ServerSocket类作为服务器, 服务器的功能由该类实现</span></div><div><span style="font-size: unset;"><br/></span></div><div>当设计Socket类时, 因为客户端需要访问服务器上的某个程序来请求资源,<span style="font-size: unset; color: unset; font-family: unset;">所以设计</span><span style="font-size: unset; color: unset; font-family: unset;">Socket类的构造方法时要让它传入两个参数, 一个是服务器的IP地址, 一个是端口号。下面的示例中, 是用自己的机器先模拟客户端和服务器, 成功之后,再部署到真正的服务器。</span><span style="min-height: 14pt; font-size: 14pt; background: rgb(232, 242, 254); color: rgb(63, 127, 95); font-family: &quot;Courier New&quot;;">记住: 服务器设置的端口要与客户端访问的端口一致。</span></div><div><img src="day20-网络编程_files/Image [13].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>ServerSocket在设计时,只需要设置自己的端口号就行, 因为它不需要访问别人, 而是等待别人来访问, 所以只要设置一个端口号, 让客户端们知道该通过哪个端口访问到服务器的对应程序即可。</div><div><img src="day20-网络编程_files/Image [14].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>Socket类和ServerSocket类是如何实现通信的? </div><div>还是通过流来通信的, Socket类和ServerSocket类底层都已经实现了socket流(是个字节流), socket流是一个双向流,包含连个流, 一个输入流一个输出流, 这两个类都实现了这两个流, 然后通过该流来进行通信</div><div>------------------------------------------------------------------------------------------------------------------------------------------------</div><div>基于 TCP协议的信息传输：</div><div>分为两类</div><div>    Socket (客户端)</div><div>    ServerSocket  (服务器)</div><div>------------------------------------------------------------------------------------------------------------------------------------------------</div><div>用Socket类和ServerSocket类实现客户端和服务器之间的通信举例1:</div><div>对于客户端来说, 所有输入流读的就必然是服务器, 所有输出流就必然输出到服务器。</div><div>对于服务器来说, 所有输入流读的就必然是客户端, 所有输出流就必然输出到客户端。</div><div>而不是像以前的输入输出流一样, 从磁盘输入, 或者输出到磁盘或控制台。</div><div><img src="day20-网络编程_files/Image [15].png" type="image/png" data-filename="Image.png" width="774"/></div><div><br/></div><div><br/></div><div><img src="day20-网络编程_files/Image [16].png" type="image/png" data-filename="Image.png" width="703"/></div><div>客户端要与服务器真正通信上, 要保证客户端和服务器用的流是完全一样的流才行, 两者读到消息才能顺利解析(只要求底层流(socket流)一致即可, 不要求包装流也一样, 因为真正进行数据读写时就是底层流, 所以真正负责写出去的流就是底层的流 通过该流来传输数据, 包装流的信息是不会写出去的。读的时候也一样)。</div><div>但服务器并不是收到客户请求就直接获得一个socket流, 而是要通过三次握手后才获得(服务器通过ServerSocket的accept()方法进行三次握手并返回一个socket流)。如果三次握手没有成功, accept()方法是会一直阻塞的, 是不会返回一个socket流的。</div><div><br/></div><div>注意 这两个程序运行时, 要先启动服务器, 再启动客户端, 不然客户端找不到服务器,会抛异常。</div><div>可以再新加一个控制台窗口, 两个控制台窗口, 一个放客户端, 一个放服务器。</div><div>    新加方法如下:</div><div>    <img src="day20-网络编程_files/Image [17].png" type="image/png" data-filename="Image.png" width="414"/></div><div>将两个控制台摆放好位置后,启动服务器和客户端。并通过下面两个小按钮分别调出客户端和服务端各在一个控制台窗口, 并且固定住, 不让它们每从键盘输入一次窗口就发生变动。</div><div>首先服务器输出的两条语句客户端收到了, 如下图绿框。其次, 在客户端依次输入hello、hi, 服务器都会立刻将结果打印出来(<span style="color: rgb(166, 0, 196);">因为流一直开着, 所以他们能保持通信, 相当于有一个通道</span>), 等客户端输入end时, 客户端和服务器都关闭了流, 程序运行结束, 如下图蓝框。</div><div><img src="day20-网络编程_files/Image [18].png" type="image/png" data-filename="Image.png" width="508"/></div><div><br/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------</div><div>用Socket类和ServerSocket类实现客户端和服务器之间的通信举例2:</div><div>对举例1进行改进: 实现多个客户端<span style="font-size: unset; color: unset; font-family: unset;">和一个服务器通信。</span></div><div><img src="day20-网络编程_files/Image [19].png" type="image/png" data-filename="Image.png" width="453"/></div><div>如果不用多线程的话, 那就是每个客户端依次和服务器通信。此时客户端的代码是不需要改的, 因为每个客户端都需要具备举例1中的功能, 而服务端的代码是需要改的, 但也很简单, 把原先处理客户端请求的代码全部放到一个循环里, 这样就能处理完一个客户端请求, 就关闭一个客户端的流,接着处理下一个客户端,如下图。<span style="color: rgb(166, 0, 196);">从这里可以看出, 服务器是不创建新的socket流的,它只是接收了从客户端过来的流, 服务器和客户端共享着同一个socket流用来通信, 就像是一个通道。所以服务器进行关流的操作关的还是客户端的流, 而不是服务器自己的流。所以服务器和客户端都有权利可以结束通信。</span></div><div><img src="day20-网络编程_files/Image [20].png" type="image/png" data-filename="Image.png" width="661"/></div><div>再添加一个控制台窗口, 然后启动服务器,run一下Server.java, 再run两下Client.java启动两个客户端, 如下图, 两个客户端虽然是同一个类运行的, 但是运行的时间不一样, 所以创建的Socket客户端对象也不一样。</div><div>可以看到每个客户端是顺序访问服务器的,直到输入了end,下一个客户端才能访问服务器, 否则会一直被阻塞。</div><div><img src="day20-网络编程_files/Image [21].png" type="image/png" data-filename="Image.png" width="634"/></div><div><br/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------</div><div>用Socket类和ServerSocket类实现客户端和服务器之间的通信举例3:</div><div>再对举例2进行改进: 用多线程的方式实现多个客户端<span style="font-size: unset; color: unset; font-family: unset;">和一个服务器通信, 以实现可以</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">同时</span></span><span style="font-size: unset; color: unset; font-family: unset;">通信, 而不是依次通信。</span></div><div><span style="color: rgb(255, 0, 0);">要实现同时通信, 我们要意识到一个问题, 就是为什么举例2中不能同时通信, 就是因为每个客户端有不同的socket, 而服务器只有一个线程的话,服务器一次只能保持连接一个socket流, 只有等当前socket流关闭后, 服务器才能接收下一个客户端的socket流, 所以现在的方法就是服务器创建多个线程, 每个线程接收一个客户端的socket流, 就能实现一个服务器与多个客户端同时通信了</span></div><div>相对于上一版的变化也就是将上上图中红框中的代码,除了第一行,其余全部放在了线程类的run()方法中。将这些代码不再循环执行而是每个线程只执行一遍, 主方法的while(true)循环体里则变成了只需循环创建线程即可。  </div><div><img src="day20-网络编程_files/Image [22].png" type="image/png" data-filename="Image.png" width="854"/></div><div>控制台的配置同于举例2,先启动两个客户端, 再<span style="font-size: unset; color: unset; font-family: unset;">启动一个服务器: 可以看到两个客户端已经可以同时和服务器通信了。其中一个客户端发送一条消息给服务器后, 服务器立刻收到,打印出来, 紧接着另一个客户端发送一条消息给服务器, 服务器又立刻打印, 原先那个客户端再发送一条,依旧可以迅速打印出来,如下图蓝框和绿框。</span></div><div><img src="day20-网络编程_files/Image [23].png" type="image/png" data-filename="Image.png" width="629"/></div><div>------------------------------------------------------------------------------------------------------------------------------------------------</div><div>用Socket类和ServerSocket类实现客户端和服务器之间的通信举例4:</div><div>在举例2的基础上实现如下例题:</div><div><img src="day20-网络编程_files/Image [24].png" type="image/png" data-filename="Image.png"/></div><div>代码如下: </div><div>改的主要是服务器, 客户端只是把前面例1的客户端代码整合了一下:</div><div><img src="day20-网络编程_files/Image [25].png" type="image/png" data-filename="Image.png" width="765"/></div><div><br/></div><div><br/></div><div><img src="day20-网络编程_files/Image [26].png" type="image/png" data-filename="Image.png" width="782"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><a href="day20-网络编程_files/day18 - LIU_网络编程_new.pdf"><img src="day20-网络编程_files/2c83d19f8dafc3e137dbdb6852cfb5e7.png" alt="day18 - LIU_网络编程_new.pdf"></a></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 