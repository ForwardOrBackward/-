<html>
<head>
  <title>day3-sql的函数、高级查询、事务、存储引擎</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603932 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 12pt;
    }
  </style>
</head>
<body>
<a name="4583"/>
<h1>day3-sql的函数、高级查询、事务、存储引擎</h1>
<div>
<table bgcolor="#D4DDE5" border="0">
<tr><td><b>创建时间：</b></td><td><i>2020/4/15 11:30</i></td></tr>
<tr><td><b>更新时间：</b></td><td><i>2021/8/24 12:44</i></td></tr>
</table>
</div>
<br/>

<div>
<span><div>下面是三张数据库表的字段跟记录。下面的内容的很多查询语句都是基于这三张表写的</div><div><img src="day3-sql的函数、高级查询、事务、存储引擎_files/skitch.png" type="image/png" data-filename="skitch.png"/></div><div><img src="day3-sql的函数、高级查询、事务、存储引擎_files/skitch [1].png" type="image/png" data-filename="skitch.png"/></div><div><img src="day3-sql的函数、高级查询、事务、存储引擎_files/skitch [2].png" type="image/png" data-filename="skitch.png"/></div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">1.函数</span></div><div>  1.1 单行函数</div><div>    #1.数学函数</div><div>        select ABS(-10);  #绝对值</div><div>        select CEIL(-12.3); #向上取整</div><div>        select FLOOR(-12.3); #向下取整</div><div>        select PI();      #π。圆周率</div><div>        select RAND(); #随机数。范围是[0,1)</div><div>        select MOD(5,2); #取模运算,即取余</div><div>        select ROUND(12.46,1); #四舍五入。结果是12.5, 意思是保留小数点后1位</div><div>        select ROUND(12.46,0); #四舍五入。结果是12, 意思是保留小数点后0位</div><div>        select POW(2,10);  #幂运算,相当于2^10</div><div>        select SQRT(36);  #开方,开根号</div><div>    #2.字符函数(字符串运算:长度,转换大小写,连接,替换...)    </div><div>       #参数可以是:字段,表达式</div><div>        select LENGTH(ename) from emp;    #计算ename的字符串长度</div><div>        select UPPER(ename) from emp;    #将字符串中的字母小写转换为大写</div><div>        select LOWER(ename) from emp;    #将字符串中的字母大写转换为小写</div><div>        select CONCAT('aa-',ename) from emp;    #将两个字符串进行字符串的拼接</div><div>        select SUBSTR('abcdef',1,3);  #字符串的截取。结果是 abc。第一个参数是字符串，第二个参数是起始截取位置(<span style="color: rgb(255, 0, 0);">位置下标从1开</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">始而不是0</span><span style="font-size: unset; color: unset; font-family: unset;">,因为它表示的是位置而不是索引,索引肯定是从0开始),第三个参数是要截取的长度。</span></div><div>        select REPLACE('abcdef','bcd','aa');  #字符串部分替换。第一个参数是字符串,第二个参数是要替换掉的子串,<span style="font-size: unset; color: unset; font-family: unset;">第三个参数是要替换成的子串。这里结果是 aaaef</span></div><div>      select LPAD('aa',10,'xc');  #左填充。结果是 xcxcxcxcaa。意思是左边以某个字符来填充到一定长度。第一个参数是要填充的字符串, <span style="font-size: unset; color: unset; font-family: unset;">第二个参数是填充完后字符串的长度,第三个参数是用来填充的字符或者字符串。    </span></div><div>        select RPAD('aa',<span style="color: rgb(255, 0, 0);">11</span>,'xc'); #右填充。结果是 aaxcxcxcxcx (注意当第二个参数为奇数和上面这个例子为偶数的区别)。意思是右边以某个字符来填充到一定长度。第一个参数是要填充的字符串, <span style="font-size: unset; color: unset; font-family: unset;">第二个参数是填充完后字符串的长度,第三个参数是用来填充的字符或者字符串。</span></div><div>        select trim('    ab   c    ');#去空格。只能去掉左右两边的空格。结果是ab   c。 </div><div>    #3.日期函数</div><div>        #下面三个都是获取当前时间</div><div>        select NOW();     #获取现在日期+时间</div><div>        select SYSDATE();    #获取系统日期+时间</div><div>        select CURRENT_TIMESTAMP();  #获取当前时间戳</div><div>  </div><div>        select CURRENT_DATE();    #获取当前日期</div><div>        select CURRENT_TIME();    #获取当前时间</div><div>        select YEAR(NOW());           #获取年份</div><div>        select MONTH(NOW());      #获取月份</div><div>        select DAY(NOW());            #获取日</div><div>        </div><div>        #日期计算</div><div>        select DATE_ADD('2018-09-09',interval 2 MONTH); #向前或向后计算日期。这里计算的是2018.09.09的两个月以后</div><div>        <span style="font-size: medium; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">select DATE_ADD('2018-09-09',interval -2 WEEK);</span>    #负号就代表向前计算日期。这里计算的是2018.09.09的两星期以前                     </div><div>        select LAST_DAY('2019-02-02');  #计算该日期对应月份的最后一天。结果是 2019-02-28</div><div><br/></div><div>  1.2 聚合函数 (聚合函数通常喜欢和分组函数一起使用)</div><div>     #1.<span style="color: rgb(166, 0, 196);">对整张表进行聚合运算时,聚合的结果只有一条记录,所以要切忌将聚合的结果和其他字段放在一起查询,</span><span style="color: rgb(166, 0, 196);">即</span><span style="color: rgb(166, 0, 196);">任何字段不</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">能和聚合运算放在同一句查询语句里(除非有group by 子句),放在一起查询</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">那将会导致查询出来的的结果只有一条记录</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">(注意, 只是导致了查询出来的结果不对,而不是执行报错。这样的sql语句依然可以成功执行, 不会报错)</span></span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">,如   </span></div><div><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">        select ename,max(sal) from emp; </span></div><div><span style="color: rgb(166, 0, 196);">      要知道select ename是会得到整张表的所有ename,结果并不是只有一条,这样和max(sal)放在</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">一起会使得查询出来的结果只显示一条记录。所以要注意字段查询出来的结果和聚合运算出来的结果数量不匹配的问题。</span></div><div><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">      但是</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">这样写的话是可以的: </span></div><div><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">        select ename,max(sal) from emp group by ename;  </span></div><div><span style="font-size: unset;"><br/></span></div><div>    常见的聚合函数有:</div><div>         select max(sal) from emp;</div><div>         select min(sal) from emp;</div><div>         select count(*) from emp;  #统计所有记录数</div><div>         select count(1) from emp;  #和count(*)一样,统计所有记录数</div><div>         select count(comm) from emp; #统计某字段的数量(统计时会将该字段为null的值排除在外)</div><div>         select sum(sal) from emp;</div><div>         select avg(sal) from emp;</div><div><br/></div><div><br/></div><div>  1.3 分组函数(分组,每组返回一条记录) </div><div>        group by 分组字段</div><div>        <span style="color: rgb(166, 0, 196);">#查询每一个部门的平均工资</span></div><div><span style="color: rgb(166, 0, 196);">        select  deptno,avg(sal) from emp group by deptno;</span></div><div><span style="color: rgb(166, 0, 196);">            注意:有了分组后,分组字段就可以和聚合函数放在同一句查询语句里了。因为分完组对应的每个分组里,分组</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">字段的值都是一模一样的,所以一组只返回一个值完全没问题</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">(实际上返回的是该组的第一条记录对应的</span></span><span style="color: rgb(255, 0, 0);">deptno的</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">值)</span></span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">。所以deptno和avg(sal)一起每组返回</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">一条记录是没有问题的。但如果查询语句是select  ename,avg(sal) from emp group by deptno;  </span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">那就是错误的了,因为在根据deptno分组的每个分组里, ename字段的取值就不一定都是一样了。</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">这个时候每组返回一个ename的值</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">(实际上返回的是该组的第一条记录对应的</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">ename</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">字段的值)</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">,那就是哪个排在前面出现哪个值了,就和不分组时字段和聚合函数放在</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">同一句查询语句里的情况一样了。所以只有分组字段key和聚合函数放在同一句查询语句里,其他字段不可以</span></div><div>            查询结果如下:</div><div>        <img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>    having (<span style="color: rgb(255, 0, 0);"> having主要用于分组之后再次进行一些操作。</span>)</div><div>        #求平均工资&gt;2000的部门编号和平均工资</div><div>            首先select  deptno,avg(sal) from emp group by deptno where avg(sal) &gt;2000; 这肯定是错误的,因为<span style="color: rgb(255, 0, 0);">where子</span><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">句要放在group by子句之前</span><span style="font-size: unset; color: unset; font-family: unset;">。其次select  deptno,avg(sal) from emp where avg(sal) &gt;2000 group by deptno; </span><span style="font-size: unset; color: unset; font-family: unset;">这肯定也是错误的, 因为</span><span style="font-size: unset;"><span style="font-size: unset; color: rgb(255, 0, 0); font-family: unset;">where子句中不能使用聚合函数</span></span><span style="font-size: unset; color: unset; font-family: unset;">, 其实也很好理解为什么有这个规定, 这里语句这样组织(设计的目的</span><span style="font-size: unset; color: unset; font-family: unset;">明显是为了先执行where子句筛选掉不需要的记录,再执行group by进行分组, 而where里出现了聚合函数的话,group by还有什么意义, where在group by之前执行, 也就是说where里的聚集函数会对所有记录进行聚合, 而不会先分组再聚合。</span><span style="font-size: unset; color: unset; font-family: unset;">所以这里要使用having。首先having的好处是在group by 之后执行,其次having可以使用聚合函数。</span></div><div>        select  deptno,avg(sal) from emp group by deptno having avg(sal) &gt;2000; </div><div><br/></div><div>   <span style="color: rgb(255, 0, 0);"> having主要用于分组之后再次进行一些操作。</span></div><div>    <span style="color: rgb(166, 0, 196);">where和having区别:</span></div><div>         1.顺序:where在group by之前,having在group by之后</div><div>         2.是否能够使用聚合函数: where不能使用聚合函数,having可以</div><div>         3.<span style="color: rgb(166, 0, 196);">where和having可以同时使用，两个关键字使用的顺序不一样，where是计算结果前筛选，having是结果出来后筛选。</span></div><div>         4. HAVING 只能与 SELECT 语句一起使用,而where还可以出现在DML语句里(insert into、 update、delete都可以和where搭配使用)。<span style="color: rgb(166, 0, 196);">HAVING 通常在 GROUP BY 子句中使用</span>。如果不使用 GROUP BY 子句，<span style="font-size: unset; color: unset; font-family: unset;">则 HAVING 的行为与 WHERE 子句一样。所以说having也不一定要有group by才能使用, 但一般都这样搭配。</span></div><div><span style="font-size: unset;"><br/></span></div><div><span style="font-size: unset;"><br/></span></div><div>  1.4 加密函数</div><div>        #注册      登录</div><div>          select MD5('root');    #MD5方式进行加密,不可逆加密(即加密后不能解密)</div><div>          select SHA('root');    #SHA方式进行加密,不可逆加密。</div><div>          select PASSWORD('root');  #mysql用户密码默认使用的就是这种加密方式</div><div>  </div><div><span style="font-weight: bold;">2.高级查询</span></div><div>  2.1 多表查询(关联查询,连接查询)</div><div>      笛卡尔积: 集合A X 集合B。 下图这样的查询语句结果就是笛卡尔积。</div><div><img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div>      1)内连接 [inner] join ... on ...(内连接分为等值连接和非等值连接) (join是inner join的简写)</div><div style="margin-left: 40px;">等值连接（等值连接区别于自然连接）：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复属性。举例如下:</div><div style="margin-left: 40px;">    select * from emp,dept where emp.deptno = dept.deptno;(方言形式,但其实方言形式用的多)</div><div style="margin-left: 40px;">    select * from emp inner join dept on emp.deptno = dept.deptno; (标准形式) (这种写法是MySQL独有的?)</div><div style="margin-left: 40px;">非等值连接： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的 列的列值。这些运算符包括&gt;、&gt;=、&lt;=、&lt;、!&gt;、!&lt;和&lt;&gt;。 </div><div style="margin-left: 40px;">    select * from emp inner join dept on emp.deptno &gt; dept.deptno;</div><div style="margin-left: 40px;">    select * from emp inner join dept on emp.deptno &lt;&gt; dept.deptno;</div><div><br/></div><div>        #当是等值连接且连接字段的名称一致时,可以直接使用using来代替标准形式</div><div>        select * from emp inner join dept using(deptno);</div><div><br/></div><div>       内连接特点:</div><div>          1.内连接后的记录与连接顺序无关(被连接的多张表没有主次之分)  (当然不同的写法连接后<span style="font-size: unset; color: unset; font-family: unset;">的记录里的字段顺序可能不一样,但每条记录包含的内容以及总记录数是不会因为写法而改变的)</span></div><div>          2.连接的字段的值在待连接的所有表里都出现的记录才会出现在结果集</div><div><br/></div><div>      2)自然连接  (natural join。自动对名称一致的字段进行等值连接,并且会去重除重复列<span style="color: rgb(255, 0, 0);">(自然连接会去除重复列, </span><span style="color: rgb(255, 0, 0);">等值连</span><span style="color: rgb(255, 0, 0);">接不会去除重复列)</span>, 后面不能跟连接条件)    (下面这种写法是MySQL独有的?)</div><div>        select * from emp natural join dept;</div><div><br/></div><div>      3)<span style="color: rgb(166, 0, 196);">外连接 [outer] join ... on ...  </span></div><div><span style="color: rgb(166, 0, 196);">        左外连接: left </span><span style="color: rgb(166, 0, 196);">[outer]</span> <span style="color: rgb(166, 0, 196);">join ... on ...</span></div><div><span style="color: rgb(166, 0, 196);">        右外连接: right</span> <span style="color: rgb(166, 0, 196);">[outer] </span><span style="color: rgb(166, 0, 196);">join ... on ...    </span></div><div><span style="color: rgb(166, 0, 196);">        左外连接和右外连接的特点:</span></div><div><span style="color: rgb(166, 0, 196);">          1.有主从表之分,与连接顺序有关  (左外连接的主表为</span><span style="color: rgb(166, 0, 196);">&quot;</span><span style="color: rgb(166, 0, 196);">left </span><span style="color: rgb(166, 0, 196);">join&quot;关键字</span><span style="color: rgb(166, 0, 196);">左边的表</span><span style="color: rgb(166, 0, 196);">, 右外连接主表为</span><span style="color: rgb(166, 0, 196);">&quot;right </span><span style="color: rgb(166, 0, 196);">join&quot;关键字</span><span style="color: rgb(166, 0, 196);">左边的表</span><span style="color: rgb(166, 0, 196);">)</span></div><div><span style="color: rgb(166, 0, 196);">          2.以主表为驱动(基准),依次在从表进行匹配;如果匹配到则连接并显示在</span></div><div><span style="color: rgb(166, 0, 196);">              结果集中;如果不能匹配到也显示在结果集中,并且主表没有的字段以null填充。</span></div><div><span style="color: rgb(166, 0, 196);">          3.</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">左向外联接的结果集包括</span> <span style="color: rgb(166, 0, 196);">&quot;</span><span style="color: rgb(166, 0, 196);">left </span><span style="color: rgb(166, 0, 196);">join&quot;关键字</span><span style="color: rgb(166, 0, 196);">左边的表</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。 </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">                </span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">右向外联接是左向外联接的反向联接。将返回右表(</span><span style="color: rgb(166, 0, 196);">&quot;right </span><span style="color: rgb(166, 0, 196);">join&quot;关键字</span><span style="color: rgb(166, 0, 196);">左边的表</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">)的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。       </span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-variant-caps: normal; font-variant-ligatures: normal;">      </span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="color: rgb(166, 0, 196);">        外连接的特点:</span></div><div><span style="color: rgb(166, 0, 196);">            而外连接又与左外连接、右外连接不同。不同在于: 外连接是把连接的多张表中每张表的没有匹配上的记录全都</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">显示在结果集中,同样也是表中没有的字段就用null填充。但是左外连接和右外连接就是只有主表没有匹配上的记录</span><span style="font-size: unset; color: rgb(166, 0, 196); font-family: unset;">才显示在结果集中。而外连接没有主从表之分,所以它展示所有表中相互没有匹配上的记录。</span></div><div>           </div><div>        下面以左外连接为例进行详细的说明</div><div>        <img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image [2].png" type="image/png" data-filename="Image.png" width="795"/></div><div>        上图中的查询结果如下: 可以看出只有十四条记录,从表中未被匹配的记录被忽略了</div><div>        <img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image [3].png" type="image/png" data-filename="Image.png" width="769"/></div><div><br/></div><div>        接来下是另一种情况,主表和从表顺序交换:</div><div>        <img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image [4].png" type="image/png" data-filename="Image.png" width="789"/></div><div>        当主表变为dept时,主表中未被匹配的记录也作为一条结果记录被保留了下来。如下图</div><div>        <img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image [5].png" type="image/png" data-filename="Image.png" width="785"/></div><div><br/></div><div>        4)自连接:自身连接自身</div><div>        #查询员工及其领导的姓名</div><div>         select e1.ename,e2.ename from emp e1,emp e2 where e1.mgr = e2.empno;       </div><div>  2.2 子查询</div><div>      嵌套查询,按最自然的想法查询的方式。</div><div>      1)单行子查询: 子查询返回结果是一条记录 <span style="color: rgb(255, 0, 0);">(注意: &gt;,&lt;,=,!=都是只能对应子查询结果返回的结果是一条记录)</span></div><div>         select dname from dept where deptno = (select deptno from emp where empno = 7788);</div><div><span>    </span><span>     #用主查询dept表每一次执行给的deptno, 来执行一遍子查询。</span><br/></div><div><span>    </span><span>     </span>select dname from dept where deptno = (select deptno from emp where emp.empno = dept.deptno);<br/></div><div>      2)多行子查询: 子查询返回结果<span style="color: rgb(166, 0, 196);">多条记录</span></div><div>         要用<span style="color: rgb(209, 0, 255);">in</span>(当然一条记录用in也可以,<span style="color: rgb(209, 0, 255);">所以,为了方便,子查询就用in吧)</span></div><div>        #查询工资&gt;2000的员工所在部门的名称</div><div>        select dname from dept where deptno <span style="color: rgb(166, 0, 196);">in</span>(select distinct deptno from emp where sal &gt; 2000);</div><div>        select dname from dept where deptno<span style="color: rgb(166, 0, 196);">=any</span>(select distinct deptno from emp where sal &gt; 2000);</div><div>         其中, any:  </div><div style="margin-left: 120px;">=any 相当于in  </div><div style="margin-left: 120px;">&gt;any 大于最小值  </div><div style="margin-left: 120px;">&lt;any 小于最大值</div><div>                 all:  </div><div style="margin-left: 120px;">&gt;all 大于最大值  </div><div style="margin-left: 120px;">&lt;all 小于最小值</div><div style="margin-left: 120px;"><br/></div><div>        <b><font style="color: rgb(255, 0, 0);">注意: 单行子查询和多行子查询的执行顺序是有区别的:</font></b></div><div><span>        <b>单行子查询</b>: </span>先执行主查询,主查询将每条记录依次交给子查询;子查询使用主查询的记录里包含的信息进行自查询,</div><div>            如果子查询能根据主查询提供的信息查询到满足条件的结果,则返回给主查询, 主查询根据子查询的结果继续查询</div><div>            如果子查询中没有满足条件的记录,则子查询返回null(主查询根据null继续匹配?)</div><div><span>    </span><span>    </span><b>多行子查询</b>: <span style="color: rgb(166, 0, 196);">先执行完子查询</span>,子查询将结果返回给主查询,主查询继续执行后续操作。</div><div><br/></div><div>#1<span style="color: rgb(255, 0, 0);">.查询超过所在部门平均工资的员工信息</span></div><div>   #<span style="color: rgb(166, 0, 196);">第一种思路:子查询结果集作为一张表表join来使用  (以前用的少。好像效果还不错,易于理解)</span></div><div>         #1.先求每个部门平均工资</div><div>         select deptno,avg(sal) from emp group by deptno;</div><div>         #2.关联emp表<span style="color: rgb(166, 0, 196);">(将上面求得的子查询直接作为一张表来和其他表关联使用)</span></div><div>         select emp.* from emp,<span style="color: rgb(166, 0, 196);">(select deptno,avg(sal) avg from emp group by deptno</span><span style="color: rgb(166, 0, 196);">)</span> <span style="color: rgb(166, 0, 196);">e</span> </div><div>            where emp.deptno = e.deptno and sal &gt; e.avg;</div><div>     #<span style="color: rgb(255, 0, 0);">第二种思路:</span>子查询作为条件来使用 (比较难于理解),这种的好处是不用分组。</div><div>     select * from emp e1 where sal &gt; (</div><div>        select avg(sal) from emp e2 where <span style="color: rgb(166, 0, 196);">e2.deptno = e1.deptno</span></div><div>     );  </div><div>            <span style="color: rgb(255, 0, 0);">上面这个sql语句的执行逻辑:</span>    (首先我们要理解到,sql语句也是从前往后执行的,当然有些关键字不一样,比如in)</div><div style="margin-left: 40px;">     #1.主查询遍历emp的每条记录</div><div style="margin-left: 40px;">     #2.主查询将自己所在记录的deptno传输给子查询</div><div style="margin-left: 40px;">     #3.子查询根据主查询的deptno查询指定部门的平均工资,返回给主查询</div><div style="margin-left: 40px;">     #4.主查询根据返回的结果执行后续操作</div><div style="margin-left: 40px;">    #相当于<span style="color: rgb(166, 0, 196);">主</span>查询遍历第一条记录时 <span style="color: rgb(166, 0, 196);">子</span>查询语句是</div><div style="margin-left: 40px;">        select * from emp e1 where sal <span style="color: rgb(255, 0, 0);">&gt;</span> (</div><div style="margin-left: 40px;">            select avg(sal) from emp e2 where <span style="color: rgb(166, 0, 196);">e2.deptno = 10</span></div><div style="margin-left: 40px;">        );  </div><div style="margin-left: 40px;">        这样求出来的avg(sal)就是10号部门的平均工资,所以说不用分组查询,而且这里可以用&quot;&gt;&quot;也是因为</div><div style="margin-left: 40px;">        每次执行子查询只返回一个结果,正好也是因为没有分组</div><div style="margin-left: 40px;">        即主查询每遍历一条记录,子查询就执行一次select avg(sal) from emp e2 where <span style="color: rgb(166, 0, 196);">e2.deptno = xx;</span></div><div style="margin-left: 40px;"><span style="color: rgb(166, 0, 196);">    </span><span style="color: rgb(166, 0, 196);">   </span> 这样的话就相当主查询每遍历e1表的一条记录,子查询就遍历一遍e2表所有记录,求得e2.deptno = xx时的平均工资</div><div style="margin-left: 40px;"></div><div>#2.查询工资超过2000的员工所在部门的信息</div><div>   select * from dept where deptno in(</div><div>   select deptno from emp where sal &gt; 2000);</div><div>    </div><div>     select * from dept where exists</div><div>     (select * from emp where sal &gt; 2000 and dept.deptno = emp.deptno);</div><div>    </div><div><b>     #in和exists区别</b></div><div>      #1.<span style="color: rgb(255, 0, 0);">in</span>: <span style="color: rgb(166, 0, 196);">先执行完子查询</span>,子查询将结果返回给主查询,主查询继续执行后续操作。</div><div>      #2.exists: 先执行主查询,主查询将每条记录依次交给子查询;子查询使用主查询的记录里包含的信息进行自查询,</div><div>            如果子查询能根据主查询提供的信息查询到满足条件的记录,则返回true, <span style="color: rgb(166, 0, 196);">查询结果显示主查询的查询结果</span>;</div><div>            如果子查询中没有满足条件的记录,则返回false,则不显示主查询的该条查询结果。<font color="#FF0000">(前面的嵌套查询中</font></div><div><font color="#FF0000"><span>    </span><span>    </span><span>    的单行子查询也是一样的原理, 即</span>&gt;,&lt;,=,!=) </font></div><div><br/></div><div>#3.查询30号部门最高工资的员工信息及其部门信息(考虑最高工资有并列的情况)</div><div>  select * from dept,</div><div>  (select * from emp where deptno =30 and sal = (select max(sal)</div><div>    from emp where deptno =30)) e</div><div>    where e.deptno = dept.deptno;</div><div>#4.查询30号部门工资次高的员工信息(&lt;any)</div><div>  select * from emp where deptno = 30 and sal &lt; any(select sal from emp where deptno = 30) </div><div>                order by sal desc limit 1;</div><div><br/></div><div>  2.3 联合查询  </div><div>     union / union all:将多个结果集进行联合,合并成一个结果集,即求并集</div><div>    其中union会对多个结果集中相同的记录去重、union all 不去重</div><div>     条件: 多个结果集的字段必须一致</div><div>    什么时候会用到联合查询?</div><div>     #1.已经单独处理两个结果集,直接联合一下即可</div><div>     #2.性能考虑。索引会大幅提升查找效率,但是索引不能和or一起用,这个时候只能用联合</div><div><br/></div><div>#1.查询工资&gt;2000的员工或者30号部门员工信息。</div><div>        #普通写法</div><div>       select * from emp where sal &gt; 2000 or deptno = 30;</div><div>        #联合查询写法</div><div>         select * from emp where sal &gt; 2000</div><div>         union</div><div>         select * from emp where deptno  =30;</div><div>    </div><div><span style="font-weight: bold;">3.事务</span></div><div>  1.存储引擎</div><div>    mysql核心就是存储引擎。MySQL是通过存储引擎来操作增删改查的。</div><div>    在mysql中有许多不同的存储引擎,存储机制、索引技巧、锁定水平都不太相同。</div><div>    可以根据不同功能设置不同存储引擎(插件,可插拔)。</div><div>    InnoDB是事务型数据库的首选，执行安全性数据库，行锁定和外键。mysql5.5之后默认使用。</div><div>    MyISAM插入速度和查询效率较高，但不支持事务。</div><div>    MEMORY将表中的数据存储在内存中，速度较快。</div><div><img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image [6].png" type="image/png" data-filename="Image.png" width="724"/></div><div><br/></div><div>    #查看存储引擎</div><div>    show engines;  </div><div>    永久修改存储引擎: 找到my.ini配置文件: </div><div>        C:\ProgramData\MySQL\MySQL Server 5.7\my.ini --&gt;修改: default-storage-engine=INNODB</div><div>    #查看mysql的编码方式是不是utf-8</div><div>    show variables  like '%char%'</div><div><img src="day3-sql的函数、高级查询、事务、存储引擎_files/Image [7].png" type="image/png" data-filename="Image.png"/></div><div>    修改MySQL的编码方式:找到my.ini配置文件:</div><div>       [client]字段中加上一句:</div><div>          default-character-set=utf8</div><div>       [mysqld]字段加上两句:</div><div>          character-set-server=utf8</div><div>          collation-server=utf8_general_ci (设置排序规则编码)</div><div>    重启mysql服务(通过命令行): net stop mysql/net start mysql   (或者直接在&quot;服务&quot;里找到MySQL右键重启)   </div><div><br/></div><div>   2.事务</div><div>      由一组DML操作组成,要么同时成功,要么同时失败。</div><div>      一个事务的步骤分三步:</div><div style="margin-left: 40px;">        开启事务</div><div style="margin-left: 40px;">        dml操作</div><div style="margin-left: 40px;">        提交事务/回滚事务</div><div style="margin-left: 40px;"></div><div>      mysql默认自动提交事务,并且每一个增删改都默认在一个单独的事务里面,会将每个dml当做独立事务处理:</div><div>             #查看事务是否自动提交</div><div>            show variables like 'autocommit';</div><div>      </div><div>      mysql一个事务执行多条dml语句的方法:(手动提交事务)</div><div>          #1.首先要关闭事务自动提交</div><div>           set autocommit = 0;</div><div>            #写下一系列dml语句(在手动提交前,就算执行这些语句,执行结果也不会写入磁盘文件,只是在内存进行了修改而已)</div><div>             delete from student where sid = 1;</div><div>            delete from student where sid = 2;</div><div>            delete from student where sid = 3;</div><div>             #手动提交</div><div>               commit;    (如果这里是rollback;  则会直接回滚到执行这些语句前的状态)</div><div>      </div><div>        #重新设置为自动提交事务的语句是:      </div><div>        set autocommit = 1;      </div><div>        </div><div>  </div><div>  </div><div>  </div><div>  </div><div>  </div><div>  </div><div>  </div></span>
</div></body></html> 